/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.app = (function() {

    /**
     * Namespace app.
     * @exports app
     * @namespace
     */
    var app = {};

    app.ResultSet = (function() {

        /**
         * Properties of a ResultSet.
         * @memberof app
         * @interface IResultSet
         * @property {Array.<Uint8Array>|null} [results] ResultSet results
         */

        /**
         * Constructs a new ResultSet.
         * @memberof app
         * @classdesc ResultSet contains a list of keys or values
         * @implements IResultSet
         * @constructor
         * @param {app.IResultSet=} [properties] Properties to set
         */
        function ResultSet(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResultSet results.
         * @member {Array.<Uint8Array>} results
         * @memberof app.ResultSet
         * @instance
         */
        ResultSet.prototype.results = $util.emptyArray;

        /**
         * Creates a new ResultSet instance using the specified properties.
         * @function create
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet=} [properties] Properties to set
         * @returns {app.ResultSet} ResultSet instance
         */
        ResultSet.create = function create(properties) {
            return new ResultSet(properties);
        };

        /**
         * Encodes the specified ResultSet message. Does not implicitly {@link app.ResultSet.verify|verify} messages.
         * @function encode
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.results[i]);
            return writer;
        };

        /**
         * Encodes the specified ResultSet message, length delimited. Does not implicitly {@link app.ResultSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer.
         * @function decode
         * @memberof app.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {app.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.app.ResultSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof app.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {app.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResultSet message.
         * @function verify
         * @memberof app.ResultSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResultSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i)
                    if (!(message.results[i] && typeof message.results[i].length === "number" || $util.isString(message.results[i])))
                        return "results: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ResultSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof app.ResultSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {app.ResultSet} ResultSet
         */
        ResultSet.fromObject = function fromObject(object) {
            if (object instanceof $root.app.ResultSet)
                return object;
            var message = new $root.app.ResultSet();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".app.ResultSet.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i)
                    if (typeof object.results[i] === "string")
                        $util.base64.decode(object.results[i], message.results[i] = $util.newBuffer($util.base64.length(object.results[i])), 0);
                    else if (object.results[i].length)
                        message.results[i] = object.results[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ResultSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof app.ResultSet
         * @static
         * @param {app.ResultSet} message ResultSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResultSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = options.bytes === String ? $util.base64.encode(message.results[j], 0, message.results[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.results[j]) : message.results[j];
            }
            return object;
        };

        /**
         * Converts this ResultSet to JSON.
         * @function toJSON
         * @memberof app.ResultSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResultSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResultSet;
    })();

    return app;
})();

$root.bnsd = (function() {

    /**
     * Namespace bnsd.
     * @exports bnsd
     * @namespace
     */
    var bnsd = {};

    bnsd.Tx = (function() {

        /**
         * Properties of a Tx.
         * @memberof bnsd
         * @interface ITx
         * @property {cash.IFeeInfo|null} [fees] Tx fees
         * @property {Array.<sigs.IStdSignature>|null} [signatures] Tx signatures
         * @property {Array.<Uint8Array>|null} [multisig] as if it never got supplied.
         * @property {cash.ISendMsg|null} [cashSendMsg] Tx cashSendMsg
         * @property {escrow.ICreateMsg|null} [escrowCreateMsg] Tx escrowCreateMsg
         * @property {escrow.IReleaseMsg|null} [escrowReleaseMsg] Tx escrowReleaseMsg
         * @property {escrow.IReturnMsg|null} [escrowReturnMsg] Tx escrowReturnMsg
         * @property {escrow.IUpdatePartiesMsg|null} [escrowUpdatePartiesMsg] Tx escrowUpdatePartiesMsg
         * @property {multisig.ICreateMsg|null} [multisigCreateMsg] Tx multisigCreateMsg
         * @property {multisig.IUpdateMsg|null} [multisigUpdateMsg] Tx multisigUpdateMsg
         * @property {validators.IApplyDiffMsg|null} [validatorsApplyDiffMsg] Tx validatorsApplyDiffMsg
         * @property {currency.ICreateMsg|null} [currencyCreateMsg] Tx currencyCreateMsg
         * @property {bnsd.IExecuteBatchMsg|null} [executeBatchMsg] Tx executeBatchMsg
         * @property {username.IRegisterTokenMsg|null} [usernameRegisterTokenMsg] Tx usernameRegisterTokenMsg
         * @property {username.ITransferTokenMsg|null} [usernameTransferTokenMsg] Tx usernameTransferTokenMsg
         * @property {username.IChangeTokenTargetsMsg|null} [usernameChangeTokenTargetsMsg] Tx usernameChangeTokenTargetsMsg
         * @property {distribution.ICreateMsg|null} [distributionCreateMsg] Tx distributionCreateMsg
         * @property {distribution.IDistributeMsg|null} [distributionMsg] Tx distributionMsg
         * @property {distribution.IResetMsg|null} [distributionResetMsg] Tx distributionResetMsg
         * @property {migration.IUpgradeSchemaMsg|null} [migrationUpgradeSchemaMsg] Tx migrationUpgradeSchemaMsg
         * @property {aswap.ICreateMsg|null} [aswapCreateMsg] Tx aswapCreateMsg
         * @property {aswap.IReleaseMsg|null} [aswapReleaseMsg] Tx aswapReleaseMsg
         * @property {aswap.IReturnMsg|null} [aswapReturnMsg] Tx aswapReturnMsg
         * @property {gov.ICreateProposalMsg|null} [govCreateProposalMsg] Tx govCreateProposalMsg
         * @property {gov.IDeleteProposalMsg|null} [govDeleteProposalMsg] Tx govDeleteProposalMsg
         * @property {gov.IVoteMsg|null} [govVoteMsg] Tx govVoteMsg
         * @property {gov.IUpdateElectorateMsg|null} [govUpdateElectorateMsg] gov.TallyMsg gov_tally_msg = 76;
         * @property {gov.IUpdateElectionRuleMsg|null} [govUpdateElectionRuleMsg] Tx govUpdateElectionRuleMsg
         * @property {msgfee.ISetMsgFeeMsg|null} [msgfeeSetMsgFeeMsg] 79 is reserved (see ProposalOptions: TextResolutionMsg)
         */

        /**
         * Constructs a new Tx.
         * @memberof bnsd
         * @classdesc old fields got deprecated. This is done to maintain binary compatibility.
         * @implements ITx
         * @constructor
         * @param {bnsd.ITx=} [properties] Properties to set
         */
        function Tx(properties) {
            this.signatures = [];
            this.multisig = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tx fees.
         * @member {cash.IFeeInfo|null|undefined} fees
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.fees = null;

        /**
         * Tx signatures.
         * @member {Array.<sigs.IStdSignature>} signatures
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.signatures = $util.emptyArray;

        /**
         * as if it never got supplied.
         * @member {Array.<Uint8Array>} multisig
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.multisig = $util.emptyArray;

        /**
         * Tx cashSendMsg.
         * @member {cash.ISendMsg|null|undefined} cashSendMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.cashSendMsg = null;

        /**
         * Tx escrowCreateMsg.
         * @member {escrow.ICreateMsg|null|undefined} escrowCreateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.escrowCreateMsg = null;

        /**
         * Tx escrowReleaseMsg.
         * @member {escrow.IReleaseMsg|null|undefined} escrowReleaseMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.escrowReleaseMsg = null;

        /**
         * Tx escrowReturnMsg.
         * @member {escrow.IReturnMsg|null|undefined} escrowReturnMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.escrowReturnMsg = null;

        /**
         * Tx escrowUpdatePartiesMsg.
         * @member {escrow.IUpdatePartiesMsg|null|undefined} escrowUpdatePartiesMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.escrowUpdatePartiesMsg = null;

        /**
         * Tx multisigCreateMsg.
         * @member {multisig.ICreateMsg|null|undefined} multisigCreateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.multisigCreateMsg = null;

        /**
         * Tx multisigUpdateMsg.
         * @member {multisig.IUpdateMsg|null|undefined} multisigUpdateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.multisigUpdateMsg = null;

        /**
         * Tx validatorsApplyDiffMsg.
         * @member {validators.IApplyDiffMsg|null|undefined} validatorsApplyDiffMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.validatorsApplyDiffMsg = null;

        /**
         * Tx currencyCreateMsg.
         * @member {currency.ICreateMsg|null|undefined} currencyCreateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.currencyCreateMsg = null;

        /**
         * Tx executeBatchMsg.
         * @member {bnsd.IExecuteBatchMsg|null|undefined} executeBatchMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.executeBatchMsg = null;

        /**
         * Tx usernameRegisterTokenMsg.
         * @member {username.IRegisterTokenMsg|null|undefined} usernameRegisterTokenMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.usernameRegisterTokenMsg = null;

        /**
         * Tx usernameTransferTokenMsg.
         * @member {username.ITransferTokenMsg|null|undefined} usernameTransferTokenMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.usernameTransferTokenMsg = null;

        /**
         * Tx usernameChangeTokenTargetsMsg.
         * @member {username.IChangeTokenTargetsMsg|null|undefined} usernameChangeTokenTargetsMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.usernameChangeTokenTargetsMsg = null;

        /**
         * Tx distributionCreateMsg.
         * @member {distribution.ICreateMsg|null|undefined} distributionCreateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.distributionCreateMsg = null;

        /**
         * Tx distributionMsg.
         * @member {distribution.IDistributeMsg|null|undefined} distributionMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.distributionMsg = null;

        /**
         * Tx distributionResetMsg.
         * @member {distribution.IResetMsg|null|undefined} distributionResetMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.distributionResetMsg = null;

        /**
         * Tx migrationUpgradeSchemaMsg.
         * @member {migration.IUpgradeSchemaMsg|null|undefined} migrationUpgradeSchemaMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.migrationUpgradeSchemaMsg = null;

        /**
         * Tx aswapCreateMsg.
         * @member {aswap.ICreateMsg|null|undefined} aswapCreateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.aswapCreateMsg = null;

        /**
         * Tx aswapReleaseMsg.
         * @member {aswap.IReleaseMsg|null|undefined} aswapReleaseMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.aswapReleaseMsg = null;

        /**
         * Tx aswapReturnMsg.
         * @member {aswap.IReturnMsg|null|undefined} aswapReturnMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.aswapReturnMsg = null;

        /**
         * Tx govCreateProposalMsg.
         * @member {gov.ICreateProposalMsg|null|undefined} govCreateProposalMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.govCreateProposalMsg = null;

        /**
         * Tx govDeleteProposalMsg.
         * @member {gov.IDeleteProposalMsg|null|undefined} govDeleteProposalMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.govDeleteProposalMsg = null;

        /**
         * Tx govVoteMsg.
         * @member {gov.IVoteMsg|null|undefined} govVoteMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.govVoteMsg = null;

        /**
         * gov.TallyMsg gov_tally_msg = 76;
         * @member {gov.IUpdateElectorateMsg|null|undefined} govUpdateElectorateMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.govUpdateElectorateMsg = null;

        /**
         * Tx govUpdateElectionRuleMsg.
         * @member {gov.IUpdateElectionRuleMsg|null|undefined} govUpdateElectionRuleMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.govUpdateElectionRuleMsg = null;

        /**
         * 79 is reserved (see ProposalOptions: TextResolutionMsg)
         * @member {msgfee.ISetMsgFeeMsg|null|undefined} msgfeeSetMsgFeeMsg
         * @memberof bnsd.Tx
         * @instance
         */
        Tx.prototype.msgfeeSetMsgFeeMsg = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * msg is a sum type over all allowed messages on this chain.
         * @member {"cashSendMsg"|"escrowCreateMsg"|"escrowReleaseMsg"|"escrowReturnMsg"|"escrowUpdatePartiesMsg"|"multisigCreateMsg"|"multisigUpdateMsg"|"validatorsApplyDiffMsg"|"currencyCreateMsg"|"executeBatchMsg"|"usernameRegisterTokenMsg"|"usernameTransferTokenMsg"|"usernameChangeTokenTargetsMsg"|"distributionCreateMsg"|"distributionMsg"|"distributionResetMsg"|"migrationUpgradeSchemaMsg"|"aswapCreateMsg"|"aswapReleaseMsg"|"aswapReturnMsg"|"govCreateProposalMsg"|"govDeleteProposalMsg"|"govVoteMsg"|"govUpdateElectorateMsg"|"govUpdateElectionRuleMsg"|"msgfeeSetMsgFeeMsg"|undefined} sum
         * @memberof bnsd.Tx
         * @instance
         */
        Object.defineProperty(Tx.prototype, "sum", {
            get: $util.oneOfGetter($oneOfFields = ["cashSendMsg", "escrowCreateMsg", "escrowReleaseMsg", "escrowReturnMsg", "escrowUpdatePartiesMsg", "multisigCreateMsg", "multisigUpdateMsg", "validatorsApplyDiffMsg", "currencyCreateMsg", "executeBatchMsg", "usernameRegisterTokenMsg", "usernameTransferTokenMsg", "usernameChangeTokenTargetsMsg", "distributionCreateMsg", "distributionMsg", "distributionResetMsg", "migrationUpgradeSchemaMsg", "aswapCreateMsg", "aswapReleaseMsg", "aswapReturnMsg", "govCreateProposalMsg", "govDeleteProposalMsg", "govVoteMsg", "govUpdateElectorateMsg", "govUpdateElectionRuleMsg", "msgfeeSetMsgFeeMsg"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Tx instance using the specified properties.
         * @function create
         * @memberof bnsd.Tx
         * @static
         * @param {bnsd.ITx=} [properties] Properties to set
         * @returns {bnsd.Tx} Tx instance
         */
        Tx.create = function create(properties) {
            return new Tx(properties);
        };

        /**
         * Encodes the specified Tx message. Does not implicitly {@link bnsd.Tx.verify|verify} messages.
         * @function encode
         * @memberof bnsd.Tx
         * @static
         * @param {bnsd.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fees != null && message.hasOwnProperty("fees"))
                $root.cash.FeeInfo.encode(message.fees, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signatures != null && message.signatures.length)
                for (var i = 0; i < message.signatures.length; ++i)
                    $root.sigs.StdSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.multisig != null && message.multisig.length)
                for (var i = 0; i < message.multisig.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.multisig[i]);
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg"))
                $root.cash.SendMsg.encode(message.cashSendMsg, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg"))
                $root.escrow.CreateMsg.encode(message.escrowCreateMsg, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg"))
                $root.escrow.ReleaseMsg.encode(message.escrowReleaseMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg"))
                $root.escrow.ReturnMsg.encode(message.escrowReturnMsg, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg"))
                $root.escrow.UpdatePartiesMsg.encode(message.escrowUpdatePartiesMsg, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg"))
                $root.multisig.CreateMsg.encode(message.multisigCreateMsg, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg"))
                $root.multisig.UpdateMsg.encode(message.multisigUpdateMsg, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg"))
                $root.validators.ApplyDiffMsg.encode(message.validatorsApplyDiffMsg, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg"))
                $root.currency.CreateMsg.encode(message.currencyCreateMsg, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
            if (message.executeBatchMsg != null && message.hasOwnProperty("executeBatchMsg"))
                $root.bnsd.ExecuteBatchMsg.encode(message.executeBatchMsg, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg"))
                $root.username.RegisterTokenMsg.encode(message.usernameRegisterTokenMsg, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg"))
                $root.username.TransferTokenMsg.encode(message.usernameTransferTokenMsg, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg"))
                $root.username.ChangeTokenTargetsMsg.encode(message.usernameChangeTokenTargetsMsg, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg"))
                $root.distribution.CreateMsg.encode(message.distributionCreateMsg, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg"))
                $root.distribution.DistributeMsg.encode(message.distributionMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg"))
                $root.distribution.ResetMsg.encode(message.distributionResetMsg, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg"))
                $root.migration.UpgradeSchemaMsg.encode(message.migrationUpgradeSchemaMsg, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
            if (message.aswapCreateMsg != null && message.hasOwnProperty("aswapCreateMsg"))
                $root.aswap.CreateMsg.encode(message.aswapCreateMsg, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg"))
                $root.aswap.ReleaseMsg.encode(message.aswapReleaseMsg, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
            if (message.aswapReturnMsg != null && message.hasOwnProperty("aswapReturnMsg"))
                $root.aswap.ReturnMsg.encode(message.aswapReturnMsg, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
            if (message.govCreateProposalMsg != null && message.hasOwnProperty("govCreateProposalMsg"))
                $root.gov.CreateProposalMsg.encode(message.govCreateProposalMsg, writer.uint32(/* id 73, wireType 2 =*/586).fork()).ldelim();
            if (message.govDeleteProposalMsg != null && message.hasOwnProperty("govDeleteProposalMsg"))
                $root.gov.DeleteProposalMsg.encode(message.govDeleteProposalMsg, writer.uint32(/* id 74, wireType 2 =*/594).fork()).ldelim();
            if (message.govVoteMsg != null && message.hasOwnProperty("govVoteMsg"))
                $root.gov.VoteMsg.encode(message.govVoteMsg, writer.uint32(/* id 75, wireType 2 =*/602).fork()).ldelim();
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg"))
                $root.gov.UpdateElectorateMsg.encode(message.govUpdateElectorateMsg, writer.uint32(/* id 77, wireType 2 =*/618).fork()).ldelim();
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg"))
                $root.gov.UpdateElectionRuleMsg.encode(message.govUpdateElectionRuleMsg, writer.uint32(/* id 78, wireType 2 =*/626).fork()).ldelim();
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg"))
                $root.msgfee.SetMsgFeeMsg.encode(message.msgfeeSetMsgFeeMsg, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Tx message, length delimited. Does not implicitly {@link bnsd.Tx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bnsd.Tx
         * @static
         * @param {bnsd.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tx message from the specified reader or buffer.
         * @function decode
         * @memberof bnsd.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bnsd.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.Tx();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fees = $root.cash.FeeInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.signatures && message.signatures.length))
                        message.signatures = [];
                    message.signatures.push($root.sigs.StdSignature.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.multisig && message.multisig.length))
                        message.multisig = [];
                    message.multisig.push(reader.bytes());
                    break;
                case 51:
                    message.cashSendMsg = $root.cash.SendMsg.decode(reader, reader.uint32());
                    break;
                case 52:
                    message.escrowCreateMsg = $root.escrow.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.escrowReleaseMsg = $root.escrow.ReleaseMsg.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.escrowReturnMsg = $root.escrow.ReturnMsg.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.multisigCreateMsg = $root.multisig.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 57:
                    message.multisigUpdateMsg = $root.multisig.UpdateMsg.decode(reader, reader.uint32());
                    break;
                case 58:
                    message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.decode(reader, reader.uint32());
                    break;
                case 59:
                    message.currencyCreateMsg = $root.currency.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 60:
                    message.executeBatchMsg = $root.bnsd.ExecuteBatchMsg.decode(reader, reader.uint32());
                    break;
                case 61:
                    message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.decode(reader, reader.uint32());
                    break;
                case 62:
                    message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.decode(reader, reader.uint32());
                    break;
                case 63:
                    message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.decode(reader, reader.uint32());
                    break;
                case 66:
                    message.distributionCreateMsg = $root.distribution.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 67:
                    message.distributionMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                    break;
                case 68:
                    message.distributionResetMsg = $root.distribution.ResetMsg.decode(reader, reader.uint32());
                    break;
                case 69:
                    message.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.decode(reader, reader.uint32());
                    break;
                case 70:
                    message.aswapCreateMsg = $root.aswap.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 71:
                    message.aswapReleaseMsg = $root.aswap.ReleaseMsg.decode(reader, reader.uint32());
                    break;
                case 72:
                    message.aswapReturnMsg = $root.aswap.ReturnMsg.decode(reader, reader.uint32());
                    break;
                case 73:
                    message.govCreateProposalMsg = $root.gov.CreateProposalMsg.decode(reader, reader.uint32());
                    break;
                case 74:
                    message.govDeleteProposalMsg = $root.gov.DeleteProposalMsg.decode(reader, reader.uint32());
                    break;
                case 75:
                    message.govVoteMsg = $root.gov.VoteMsg.decode(reader, reader.uint32());
                    break;
                case 77:
                    message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.decode(reader, reader.uint32());
                    break;
                case 78:
                    message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.decode(reader, reader.uint32());
                    break;
                case 80:
                    message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bnsd.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bnsd.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tx message.
         * @function verify
         * @memberof bnsd.Tx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tx.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.fees != null && message.hasOwnProperty("fees")) {
                var error = $root.cash.FeeInfo.verify(message.fees);
                if (error)
                    return "fees." + error;
            }
            if (message.signatures != null && message.hasOwnProperty("signatures")) {
                if (!Array.isArray(message.signatures))
                    return "signatures: array expected";
                for (var i = 0; i < message.signatures.length; ++i) {
                    var error = $root.sigs.StdSignature.verify(message.signatures[i]);
                    if (error)
                        return "signatures." + error;
                }
            }
            if (message.multisig != null && message.hasOwnProperty("multisig")) {
                if (!Array.isArray(message.multisig))
                    return "multisig: array expected";
                for (var i = 0; i < message.multisig.length; ++i)
                    if (!(message.multisig[i] && typeof message.multisig[i].length === "number" || $util.isString(message.multisig[i])))
                        return "multisig: buffer[] expected";
            }
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                properties.sum = 1;
                {
                    var error = $root.cash.SendMsg.verify(message.cashSendMsg);
                    if (error)
                        return "cashSendMsg." + error;
                }
            }
            if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.CreateMsg.verify(message.escrowCreateMsg);
                    if (error)
                        return "escrowCreateMsg." + error;
                }
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.ReleaseMsg.verify(message.escrowReleaseMsg);
                    if (error)
                        return "escrowReleaseMsg." + error;
                }
            }
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.ReturnMsg.verify(message.escrowReturnMsg);
                    if (error)
                        return "escrowReturnMsg." + error;
                }
            }
            if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.UpdatePartiesMsg.verify(message.escrowUpdatePartiesMsg);
                    if (error)
                        return "escrowUpdatePartiesMsg." + error;
                }
            }
            if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.multisig.CreateMsg.verify(message.multisigCreateMsg);
                    if (error)
                        return "multisigCreateMsg." + error;
                }
            }
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.multisig.UpdateMsg.verify(message.multisigUpdateMsg);
                    if (error)
                        return "multisigUpdateMsg." + error;
                }
            }
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.validators.ApplyDiffMsg.verify(message.validatorsApplyDiffMsg);
                    if (error)
                        return "validatorsApplyDiffMsg." + error;
                }
            }
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.currency.CreateMsg.verify(message.currencyCreateMsg);
                    if (error)
                        return "currencyCreateMsg." + error;
                }
            }
            if (message.executeBatchMsg != null && message.hasOwnProperty("executeBatchMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.bnsd.ExecuteBatchMsg.verify(message.executeBatchMsg);
                    if (error)
                        return "executeBatchMsg." + error;
                }
            }
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.RegisterTokenMsg.verify(message.usernameRegisterTokenMsg);
                    if (error)
                        return "usernameRegisterTokenMsg." + error;
                }
            }
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.TransferTokenMsg.verify(message.usernameTransferTokenMsg);
                    if (error)
                        return "usernameTransferTokenMsg." + error;
                }
            }
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.ChangeTokenTargetsMsg.verify(message.usernameChangeTokenTargetsMsg);
                    if (error)
                        return "usernameChangeTokenTargetsMsg." + error;
                }
            }
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.CreateMsg.verify(message.distributionCreateMsg);
                    if (error)
                        return "distributionCreateMsg." + error;
                }
            }
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.DistributeMsg.verify(message.distributionMsg);
                    if (error)
                        return "distributionMsg." + error;
                }
            }
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.ResetMsg.verify(message.distributionResetMsg);
                    if (error)
                        return "distributionResetMsg." + error;
                }
            }
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.migration.UpgradeSchemaMsg.verify(message.migrationUpgradeSchemaMsg);
                    if (error)
                        return "migrationUpgradeSchemaMsg." + error;
                }
            }
            if (message.aswapCreateMsg != null && message.hasOwnProperty("aswapCreateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.CreateMsg.verify(message.aswapCreateMsg);
                    if (error)
                        return "aswapCreateMsg." + error;
                }
            }
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.ReleaseMsg.verify(message.aswapReleaseMsg);
                    if (error)
                        return "aswapReleaseMsg." + error;
                }
            }
            if (message.aswapReturnMsg != null && message.hasOwnProperty("aswapReturnMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.ReturnMsg.verify(message.aswapReturnMsg);
                    if (error)
                        return "aswapReturnMsg." + error;
                }
            }
            if (message.govCreateProposalMsg != null && message.hasOwnProperty("govCreateProposalMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.CreateProposalMsg.verify(message.govCreateProposalMsg);
                    if (error)
                        return "govCreateProposalMsg." + error;
                }
            }
            if (message.govDeleteProposalMsg != null && message.hasOwnProperty("govDeleteProposalMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.DeleteProposalMsg.verify(message.govDeleteProposalMsg);
                    if (error)
                        return "govDeleteProposalMsg." + error;
                }
            }
            if (message.govVoteMsg != null && message.hasOwnProperty("govVoteMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.VoteMsg.verify(message.govVoteMsg);
                    if (error)
                        return "govVoteMsg." + error;
                }
            }
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.UpdateElectorateMsg.verify(message.govUpdateElectorateMsg);
                    if (error)
                        return "govUpdateElectorateMsg." + error;
                }
            }
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.UpdateElectionRuleMsg.verify(message.govUpdateElectionRuleMsg);
                    if (error)
                        return "govUpdateElectionRuleMsg." + error;
                }
            }
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.msgfee.SetMsgFeeMsg.verify(message.msgfeeSetMsgFeeMsg);
                    if (error)
                        return "msgfeeSetMsgFeeMsg." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Tx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bnsd.Tx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bnsd.Tx} Tx
         */
        Tx.fromObject = function fromObject(object) {
            if (object instanceof $root.bnsd.Tx)
                return object;
            var message = new $root.bnsd.Tx();
            if (object.fees != null) {
                if (typeof object.fees !== "object")
                    throw TypeError(".bnsd.Tx.fees: object expected");
                message.fees = $root.cash.FeeInfo.fromObject(object.fees);
            }
            if (object.signatures) {
                if (!Array.isArray(object.signatures))
                    throw TypeError(".bnsd.Tx.signatures: array expected");
                message.signatures = [];
                for (var i = 0; i < object.signatures.length; ++i) {
                    if (typeof object.signatures[i] !== "object")
                        throw TypeError(".bnsd.Tx.signatures: object expected");
                    message.signatures[i] = $root.sigs.StdSignature.fromObject(object.signatures[i]);
                }
            }
            if (object.multisig) {
                if (!Array.isArray(object.multisig))
                    throw TypeError(".bnsd.Tx.multisig: array expected");
                message.multisig = [];
                for (var i = 0; i < object.multisig.length; ++i)
                    if (typeof object.multisig[i] === "string")
                        $util.base64.decode(object.multisig[i], message.multisig[i] = $util.newBuffer($util.base64.length(object.multisig[i])), 0);
                    else if (object.multisig[i].length)
                        message.multisig[i] = object.multisig[i];
            }
            if (object.cashSendMsg != null) {
                if (typeof object.cashSendMsg !== "object")
                    throw TypeError(".bnsd.Tx.cashSendMsg: object expected");
                message.cashSendMsg = $root.cash.SendMsg.fromObject(object.cashSendMsg);
            }
            if (object.escrowCreateMsg != null) {
                if (typeof object.escrowCreateMsg !== "object")
                    throw TypeError(".bnsd.Tx.escrowCreateMsg: object expected");
                message.escrowCreateMsg = $root.escrow.CreateMsg.fromObject(object.escrowCreateMsg);
            }
            if (object.escrowReleaseMsg != null) {
                if (typeof object.escrowReleaseMsg !== "object")
                    throw TypeError(".bnsd.Tx.escrowReleaseMsg: object expected");
                message.escrowReleaseMsg = $root.escrow.ReleaseMsg.fromObject(object.escrowReleaseMsg);
            }
            if (object.escrowReturnMsg != null) {
                if (typeof object.escrowReturnMsg !== "object")
                    throw TypeError(".bnsd.Tx.escrowReturnMsg: object expected");
                message.escrowReturnMsg = $root.escrow.ReturnMsg.fromObject(object.escrowReturnMsg);
            }
            if (object.escrowUpdatePartiesMsg != null) {
                if (typeof object.escrowUpdatePartiesMsg !== "object")
                    throw TypeError(".bnsd.Tx.escrowUpdatePartiesMsg: object expected");
                message.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.fromObject(object.escrowUpdatePartiesMsg);
            }
            if (object.multisigCreateMsg != null) {
                if (typeof object.multisigCreateMsg !== "object")
                    throw TypeError(".bnsd.Tx.multisigCreateMsg: object expected");
                message.multisigCreateMsg = $root.multisig.CreateMsg.fromObject(object.multisigCreateMsg);
            }
            if (object.multisigUpdateMsg != null) {
                if (typeof object.multisigUpdateMsg !== "object")
                    throw TypeError(".bnsd.Tx.multisigUpdateMsg: object expected");
                message.multisigUpdateMsg = $root.multisig.UpdateMsg.fromObject(object.multisigUpdateMsg);
            }
            if (object.validatorsApplyDiffMsg != null) {
                if (typeof object.validatorsApplyDiffMsg !== "object")
                    throw TypeError(".bnsd.Tx.validatorsApplyDiffMsg: object expected");
                message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.fromObject(object.validatorsApplyDiffMsg);
            }
            if (object.currencyCreateMsg != null) {
                if (typeof object.currencyCreateMsg !== "object")
                    throw TypeError(".bnsd.Tx.currencyCreateMsg: object expected");
                message.currencyCreateMsg = $root.currency.CreateMsg.fromObject(object.currencyCreateMsg);
            }
            if (object.executeBatchMsg != null) {
                if (typeof object.executeBatchMsg !== "object")
                    throw TypeError(".bnsd.Tx.executeBatchMsg: object expected");
                message.executeBatchMsg = $root.bnsd.ExecuteBatchMsg.fromObject(object.executeBatchMsg);
            }
            if (object.usernameRegisterTokenMsg != null) {
                if (typeof object.usernameRegisterTokenMsg !== "object")
                    throw TypeError(".bnsd.Tx.usernameRegisterTokenMsg: object expected");
                message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.fromObject(object.usernameRegisterTokenMsg);
            }
            if (object.usernameTransferTokenMsg != null) {
                if (typeof object.usernameTransferTokenMsg !== "object")
                    throw TypeError(".bnsd.Tx.usernameTransferTokenMsg: object expected");
                message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.fromObject(object.usernameTransferTokenMsg);
            }
            if (object.usernameChangeTokenTargetsMsg != null) {
                if (typeof object.usernameChangeTokenTargetsMsg !== "object")
                    throw TypeError(".bnsd.Tx.usernameChangeTokenTargetsMsg: object expected");
                message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.fromObject(object.usernameChangeTokenTargetsMsg);
            }
            if (object.distributionCreateMsg != null) {
                if (typeof object.distributionCreateMsg !== "object")
                    throw TypeError(".bnsd.Tx.distributionCreateMsg: object expected");
                message.distributionCreateMsg = $root.distribution.CreateMsg.fromObject(object.distributionCreateMsg);
            }
            if (object.distributionMsg != null) {
                if (typeof object.distributionMsg !== "object")
                    throw TypeError(".bnsd.Tx.distributionMsg: object expected");
                message.distributionMsg = $root.distribution.DistributeMsg.fromObject(object.distributionMsg);
            }
            if (object.distributionResetMsg != null) {
                if (typeof object.distributionResetMsg !== "object")
                    throw TypeError(".bnsd.Tx.distributionResetMsg: object expected");
                message.distributionResetMsg = $root.distribution.ResetMsg.fromObject(object.distributionResetMsg);
            }
            if (object.migrationUpgradeSchemaMsg != null) {
                if (typeof object.migrationUpgradeSchemaMsg !== "object")
                    throw TypeError(".bnsd.Tx.migrationUpgradeSchemaMsg: object expected");
                message.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.fromObject(object.migrationUpgradeSchemaMsg);
            }
            if (object.aswapCreateMsg != null) {
                if (typeof object.aswapCreateMsg !== "object")
                    throw TypeError(".bnsd.Tx.aswapCreateMsg: object expected");
                message.aswapCreateMsg = $root.aswap.CreateMsg.fromObject(object.aswapCreateMsg);
            }
            if (object.aswapReleaseMsg != null) {
                if (typeof object.aswapReleaseMsg !== "object")
                    throw TypeError(".bnsd.Tx.aswapReleaseMsg: object expected");
                message.aswapReleaseMsg = $root.aswap.ReleaseMsg.fromObject(object.aswapReleaseMsg);
            }
            if (object.aswapReturnMsg != null) {
                if (typeof object.aswapReturnMsg !== "object")
                    throw TypeError(".bnsd.Tx.aswapReturnMsg: object expected");
                message.aswapReturnMsg = $root.aswap.ReturnMsg.fromObject(object.aswapReturnMsg);
            }
            if (object.govCreateProposalMsg != null) {
                if (typeof object.govCreateProposalMsg !== "object")
                    throw TypeError(".bnsd.Tx.govCreateProposalMsg: object expected");
                message.govCreateProposalMsg = $root.gov.CreateProposalMsg.fromObject(object.govCreateProposalMsg);
            }
            if (object.govDeleteProposalMsg != null) {
                if (typeof object.govDeleteProposalMsg !== "object")
                    throw TypeError(".bnsd.Tx.govDeleteProposalMsg: object expected");
                message.govDeleteProposalMsg = $root.gov.DeleteProposalMsg.fromObject(object.govDeleteProposalMsg);
            }
            if (object.govVoteMsg != null) {
                if (typeof object.govVoteMsg !== "object")
                    throw TypeError(".bnsd.Tx.govVoteMsg: object expected");
                message.govVoteMsg = $root.gov.VoteMsg.fromObject(object.govVoteMsg);
            }
            if (object.govUpdateElectorateMsg != null) {
                if (typeof object.govUpdateElectorateMsg !== "object")
                    throw TypeError(".bnsd.Tx.govUpdateElectorateMsg: object expected");
                message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.fromObject(object.govUpdateElectorateMsg);
            }
            if (object.govUpdateElectionRuleMsg != null) {
                if (typeof object.govUpdateElectionRuleMsg !== "object")
                    throw TypeError(".bnsd.Tx.govUpdateElectionRuleMsg: object expected");
                message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.fromObject(object.govUpdateElectionRuleMsg);
            }
            if (object.msgfeeSetMsgFeeMsg != null) {
                if (typeof object.msgfeeSetMsgFeeMsg !== "object")
                    throw TypeError(".bnsd.Tx.msgfeeSetMsgFeeMsg: object expected");
                message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.fromObject(object.msgfeeSetMsgFeeMsg);
            }
            return message;
        };

        /**
         * Creates a plain object from a Tx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bnsd.Tx
         * @static
         * @param {bnsd.Tx} message Tx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tx.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.signatures = [];
                object.multisig = [];
            }
            if (options.defaults)
                object.fees = null;
            if (message.fees != null && message.hasOwnProperty("fees"))
                object.fees = $root.cash.FeeInfo.toObject(message.fees, options);
            if (message.signatures && message.signatures.length) {
                object.signatures = [];
                for (var j = 0; j < message.signatures.length; ++j)
                    object.signatures[j] = $root.sigs.StdSignature.toObject(message.signatures[j], options);
            }
            if (message.multisig && message.multisig.length) {
                object.multisig = [];
                for (var j = 0; j < message.multisig.length; ++j)
                    object.multisig[j] = options.bytes === String ? $util.base64.encode(message.multisig[j], 0, message.multisig[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.multisig[j]) : message.multisig[j];
            }
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                object.cashSendMsg = $root.cash.SendMsg.toObject(message.cashSendMsg, options);
                if (options.oneofs)
                    object.sum = "cashSendMsg";
            }
            if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg")) {
                object.escrowCreateMsg = $root.escrow.CreateMsg.toObject(message.escrowCreateMsg, options);
                if (options.oneofs)
                    object.sum = "escrowCreateMsg";
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                object.escrowReleaseMsg = $root.escrow.ReleaseMsg.toObject(message.escrowReleaseMsg, options);
                if (options.oneofs)
                    object.sum = "escrowReleaseMsg";
            }
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                object.escrowReturnMsg = $root.escrow.ReturnMsg.toObject(message.escrowReturnMsg, options);
                if (options.oneofs)
                    object.sum = "escrowReturnMsg";
            }
            if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg")) {
                object.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.toObject(message.escrowUpdatePartiesMsg, options);
                if (options.oneofs)
                    object.sum = "escrowUpdatePartiesMsg";
            }
            if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg")) {
                object.multisigCreateMsg = $root.multisig.CreateMsg.toObject(message.multisigCreateMsg, options);
                if (options.oneofs)
                    object.sum = "multisigCreateMsg";
            }
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                object.multisigUpdateMsg = $root.multisig.UpdateMsg.toObject(message.multisigUpdateMsg, options);
                if (options.oneofs)
                    object.sum = "multisigUpdateMsg";
            }
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                object.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.toObject(message.validatorsApplyDiffMsg, options);
                if (options.oneofs)
                    object.sum = "validatorsApplyDiffMsg";
            }
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                object.currencyCreateMsg = $root.currency.CreateMsg.toObject(message.currencyCreateMsg, options);
                if (options.oneofs)
                    object.sum = "currencyCreateMsg";
            }
            if (message.executeBatchMsg != null && message.hasOwnProperty("executeBatchMsg")) {
                object.executeBatchMsg = $root.bnsd.ExecuteBatchMsg.toObject(message.executeBatchMsg, options);
                if (options.oneofs)
                    object.sum = "executeBatchMsg";
            }
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                object.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.toObject(message.usernameRegisterTokenMsg, options);
                if (options.oneofs)
                    object.sum = "usernameRegisterTokenMsg";
            }
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                object.usernameTransferTokenMsg = $root.username.TransferTokenMsg.toObject(message.usernameTransferTokenMsg, options);
                if (options.oneofs)
                    object.sum = "usernameTransferTokenMsg";
            }
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                object.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.toObject(message.usernameChangeTokenTargetsMsg, options);
                if (options.oneofs)
                    object.sum = "usernameChangeTokenTargetsMsg";
            }
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                object.distributionCreateMsg = $root.distribution.CreateMsg.toObject(message.distributionCreateMsg, options);
                if (options.oneofs)
                    object.sum = "distributionCreateMsg";
            }
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                object.distributionMsg = $root.distribution.DistributeMsg.toObject(message.distributionMsg, options);
                if (options.oneofs)
                    object.sum = "distributionMsg";
            }
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                object.distributionResetMsg = $root.distribution.ResetMsg.toObject(message.distributionResetMsg, options);
                if (options.oneofs)
                    object.sum = "distributionResetMsg";
            }
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg")) {
                object.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.toObject(message.migrationUpgradeSchemaMsg, options);
                if (options.oneofs)
                    object.sum = "migrationUpgradeSchemaMsg";
            }
            if (message.aswapCreateMsg != null && message.hasOwnProperty("aswapCreateMsg")) {
                object.aswapCreateMsg = $root.aswap.CreateMsg.toObject(message.aswapCreateMsg, options);
                if (options.oneofs)
                    object.sum = "aswapCreateMsg";
            }
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg")) {
                object.aswapReleaseMsg = $root.aswap.ReleaseMsg.toObject(message.aswapReleaseMsg, options);
                if (options.oneofs)
                    object.sum = "aswapReleaseMsg";
            }
            if (message.aswapReturnMsg != null && message.hasOwnProperty("aswapReturnMsg")) {
                object.aswapReturnMsg = $root.aswap.ReturnMsg.toObject(message.aswapReturnMsg, options);
                if (options.oneofs)
                    object.sum = "aswapReturnMsg";
            }
            if (message.govCreateProposalMsg != null && message.hasOwnProperty("govCreateProposalMsg")) {
                object.govCreateProposalMsg = $root.gov.CreateProposalMsg.toObject(message.govCreateProposalMsg, options);
                if (options.oneofs)
                    object.sum = "govCreateProposalMsg";
            }
            if (message.govDeleteProposalMsg != null && message.hasOwnProperty("govDeleteProposalMsg")) {
                object.govDeleteProposalMsg = $root.gov.DeleteProposalMsg.toObject(message.govDeleteProposalMsg, options);
                if (options.oneofs)
                    object.sum = "govDeleteProposalMsg";
            }
            if (message.govVoteMsg != null && message.hasOwnProperty("govVoteMsg")) {
                object.govVoteMsg = $root.gov.VoteMsg.toObject(message.govVoteMsg, options);
                if (options.oneofs)
                    object.sum = "govVoteMsg";
            }
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                object.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.toObject(message.govUpdateElectorateMsg, options);
                if (options.oneofs)
                    object.sum = "govUpdateElectorateMsg";
            }
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                object.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.toObject(message.govUpdateElectionRuleMsg, options);
                if (options.oneofs)
                    object.sum = "govUpdateElectionRuleMsg";
            }
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                object.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.toObject(message.msgfeeSetMsgFeeMsg, options);
                if (options.oneofs)
                    object.sum = "msgfeeSetMsgFeeMsg";
            }
            return object;
        };

        /**
         * Converts this Tx to JSON.
         * @function toJSON
         * @memberof bnsd.Tx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tx.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tx;
    })();

    bnsd.ExecuteBatchMsg = (function() {

        /**
         * Properties of an ExecuteBatchMsg.
         * @memberof bnsd
         * @interface IExecuteBatchMsg
         * @property {Array.<bnsd.ExecuteBatchMsg.IUnion>|null} [messages] ExecuteBatchMsg messages
         */

        /**
         * Constructs a new ExecuteBatchMsg.
         * @memberof bnsd
         * @classdesc ExecuteBatchMsg encapsulates multiple messages to support batch transaction
         * @implements IExecuteBatchMsg
         * @constructor
         * @param {bnsd.IExecuteBatchMsg=} [properties] Properties to set
         */
        function ExecuteBatchMsg(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteBatchMsg messages.
         * @member {Array.<bnsd.ExecuteBatchMsg.IUnion>} messages
         * @memberof bnsd.ExecuteBatchMsg
         * @instance
         */
        ExecuteBatchMsg.prototype.messages = $util.emptyArray;

        /**
         * Creates a new ExecuteBatchMsg instance using the specified properties.
         * @function create
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {bnsd.IExecuteBatchMsg=} [properties] Properties to set
         * @returns {bnsd.ExecuteBatchMsg} ExecuteBatchMsg instance
         */
        ExecuteBatchMsg.create = function create(properties) {
            return new ExecuteBatchMsg(properties);
        };

        /**
         * Encodes the specified ExecuteBatchMsg message. Does not implicitly {@link bnsd.ExecuteBatchMsg.verify|verify} messages.
         * @function encode
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {bnsd.IExecuteBatchMsg} message ExecuteBatchMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.bnsd.ExecuteBatchMsg.Union.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteBatchMsg message, length delimited. Does not implicitly {@link bnsd.ExecuteBatchMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {bnsd.IExecuteBatchMsg} message ExecuteBatchMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteBatchMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteBatchMsg message from the specified reader or buffer.
         * @function decode
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bnsd.ExecuteBatchMsg} ExecuteBatchMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.ExecuteBatchMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.bnsd.ExecuteBatchMsg.Union.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteBatchMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bnsd.ExecuteBatchMsg} ExecuteBatchMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteBatchMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteBatchMsg message.
         * @function verify
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteBatchMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.bnsd.ExecuteBatchMsg.Union.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecuteBatchMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bnsd.ExecuteBatchMsg} ExecuteBatchMsg
         */
        ExecuteBatchMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.bnsd.ExecuteBatchMsg)
                return object;
            var message = new $root.bnsd.ExecuteBatchMsg();
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".bnsd.ExecuteBatchMsg.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.messages: object expected");
                    message.messages[i] = $root.bnsd.ExecuteBatchMsg.Union.fromObject(object.messages[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteBatchMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bnsd.ExecuteBatchMsg
         * @static
         * @param {bnsd.ExecuteBatchMsg} message ExecuteBatchMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteBatchMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.bnsd.ExecuteBatchMsg.Union.toObject(message.messages[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecuteBatchMsg to JSON.
         * @function toJSON
         * @memberof bnsd.ExecuteBatchMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteBatchMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ExecuteBatchMsg.Union = (function() {

            /**
             * Properties of an Union.
             * @memberof bnsd.ExecuteBatchMsg
             * @interface IUnion
             * @property {cash.ISendMsg|null} [cashSendMsg] Union cashSendMsg
             * @property {escrow.ICreateMsg|null} [escrowCreateMsg] Union escrowCreateMsg
             * @property {escrow.IReleaseMsg|null} [escrowReleaseMsg] Union escrowReleaseMsg
             * @property {escrow.IReturnMsg|null} [escrowReturnMsg] Union escrowReturnMsg
             * @property {escrow.IUpdatePartiesMsg|null} [escrowUpdatePartiesMsg] Union escrowUpdatePartiesMsg
             * @property {multisig.ICreateMsg|null} [multisigCreateMsg] Union multisigCreateMsg
             * @property {multisig.IUpdateMsg|null} [multisigUpdateMsg] Union multisigUpdateMsg
             * @property {validators.IApplyDiffMsg|null} [validatorsApplyDiffMsg] Union validatorsApplyDiffMsg
             * @property {currency.ICreateMsg|null} [currencyCreateMsg] Union currencyCreateMsg
             * @property {username.IRegisterTokenMsg|null} [usernameRegisterTokenMsg] No recursive batches!
             * @property {username.ITransferTokenMsg|null} [usernameTransferTokenMsg] Union usernameTransferTokenMsg
             * @property {username.IChangeTokenTargetsMsg|null} [usernameChangeTokenTargetsMsg] Union usernameChangeTokenTargetsMsg
             * @property {distribution.ICreateMsg|null} [distributionCreateMsg] Union distributionCreateMsg
             * @property {distribution.IDistributeMsg|null} [distributionMsg] Union distributionMsg
             * @property {distribution.IResetMsg|null} [distributionResetMsg] Union distributionResetMsg
             * @property {msgfee.ISetMsgFeeMsg|null} [msgfeeSetMsgFeeMsg] aswap and gov don't make much sense as part of a batch (no vote buying)
             */

            /**
             * Constructs a new Union.
             * @memberof bnsd.ExecuteBatchMsg
             * @classdesc Represents an Union.
             * @implements IUnion
             * @constructor
             * @param {bnsd.ExecuteBatchMsg.IUnion=} [properties] Properties to set
             */
            function Union(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Union cashSendMsg.
             * @member {cash.ISendMsg|null|undefined} cashSendMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.cashSendMsg = null;

            /**
             * Union escrowCreateMsg.
             * @member {escrow.ICreateMsg|null|undefined} escrowCreateMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.escrowCreateMsg = null;

            /**
             * Union escrowReleaseMsg.
             * @member {escrow.IReleaseMsg|null|undefined} escrowReleaseMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.escrowReleaseMsg = null;

            /**
             * Union escrowReturnMsg.
             * @member {escrow.IReturnMsg|null|undefined} escrowReturnMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.escrowReturnMsg = null;

            /**
             * Union escrowUpdatePartiesMsg.
             * @member {escrow.IUpdatePartiesMsg|null|undefined} escrowUpdatePartiesMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.escrowUpdatePartiesMsg = null;

            /**
             * Union multisigCreateMsg.
             * @member {multisig.ICreateMsg|null|undefined} multisigCreateMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.multisigCreateMsg = null;

            /**
             * Union multisigUpdateMsg.
             * @member {multisig.IUpdateMsg|null|undefined} multisigUpdateMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.multisigUpdateMsg = null;

            /**
             * Union validatorsApplyDiffMsg.
             * @member {validators.IApplyDiffMsg|null|undefined} validatorsApplyDiffMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.validatorsApplyDiffMsg = null;

            /**
             * Union currencyCreateMsg.
             * @member {currency.ICreateMsg|null|undefined} currencyCreateMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.currencyCreateMsg = null;

            /**
             * No recursive batches!
             * @member {username.IRegisterTokenMsg|null|undefined} usernameRegisterTokenMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameRegisterTokenMsg = null;

            /**
             * Union usernameTransferTokenMsg.
             * @member {username.ITransferTokenMsg|null|undefined} usernameTransferTokenMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameTransferTokenMsg = null;

            /**
             * Union usernameChangeTokenTargetsMsg.
             * @member {username.IChangeTokenTargetsMsg|null|undefined} usernameChangeTokenTargetsMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameChangeTokenTargetsMsg = null;

            /**
             * Union distributionCreateMsg.
             * @member {distribution.ICreateMsg|null|undefined} distributionCreateMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionCreateMsg = null;

            /**
             * Union distributionMsg.
             * @member {distribution.IDistributeMsg|null|undefined} distributionMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionMsg = null;

            /**
             * Union distributionResetMsg.
             * @member {distribution.IResetMsg|null|undefined} distributionResetMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionResetMsg = null;

            /**
             * aswap and gov don't make much sense as part of a batch (no vote buying)
             * @member {msgfee.ISetMsgFeeMsg|null|undefined} msgfeeSetMsgFeeMsg
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Union.prototype.msgfeeSetMsgFeeMsg = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Union sum.
             * @member {"cashSendMsg"|"escrowCreateMsg"|"escrowReleaseMsg"|"escrowReturnMsg"|"escrowUpdatePartiesMsg"|"multisigCreateMsg"|"multisigUpdateMsg"|"validatorsApplyDiffMsg"|"currencyCreateMsg"|"usernameRegisterTokenMsg"|"usernameTransferTokenMsg"|"usernameChangeTokenTargetsMsg"|"distributionCreateMsg"|"distributionMsg"|"distributionResetMsg"|"msgfeeSetMsgFeeMsg"|undefined} sum
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             */
            Object.defineProperty(Union.prototype, "sum", {
                get: $util.oneOfGetter($oneOfFields = ["cashSendMsg", "escrowCreateMsg", "escrowReleaseMsg", "escrowReturnMsg", "escrowUpdatePartiesMsg", "multisigCreateMsg", "multisigUpdateMsg", "validatorsApplyDiffMsg", "currencyCreateMsg", "usernameRegisterTokenMsg", "usernameTransferTokenMsg", "usernameChangeTokenTargetsMsg", "distributionCreateMsg", "distributionMsg", "distributionResetMsg", "msgfeeSetMsgFeeMsg"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Union instance using the specified properties.
             * @function create
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteBatchMsg.IUnion=} [properties] Properties to set
             * @returns {bnsd.ExecuteBatchMsg.Union} Union instance
             */
            Union.create = function create(properties) {
                return new Union(properties);
            };

            /**
             * Encodes the specified Union message. Does not implicitly {@link bnsd.ExecuteBatchMsg.Union.verify|verify} messages.
             * @function encode
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteBatchMsg.IUnion} message Union message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Union.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg"))
                    $root.cash.SendMsg.encode(message.cashSendMsg, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg"))
                    $root.escrow.CreateMsg.encode(message.escrowCreateMsg, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg"))
                    $root.escrow.ReleaseMsg.encode(message.escrowReleaseMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
                if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg"))
                    $root.escrow.ReturnMsg.encode(message.escrowReturnMsg, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
                if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg"))
                    $root.escrow.UpdatePartiesMsg.encode(message.escrowUpdatePartiesMsg, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
                if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg"))
                    $root.multisig.CreateMsg.encode(message.multisigCreateMsg, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg"))
                    $root.multisig.UpdateMsg.encode(message.multisigUpdateMsg, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg"))
                    $root.validators.ApplyDiffMsg.encode(message.validatorsApplyDiffMsg, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
                if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg"))
                    $root.currency.CreateMsg.encode(message.currencyCreateMsg, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg"))
                    $root.username.RegisterTokenMsg.encode(message.usernameRegisterTokenMsg, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg"))
                    $root.username.TransferTokenMsg.encode(message.usernameTransferTokenMsg, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg"))
                    $root.username.ChangeTokenTargetsMsg.encode(message.usernameChangeTokenTargetsMsg, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg"))
                    $root.distribution.CreateMsg.encode(message.distributionCreateMsg, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg"))
                    $root.distribution.DistributeMsg.encode(message.distributionMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg"))
                    $root.distribution.ResetMsg.encode(message.distributionResetMsg, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg"))
                    $root.msgfee.SetMsgFeeMsg.encode(message.msgfeeSetMsgFeeMsg, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Union message, length delimited. Does not implicitly {@link bnsd.ExecuteBatchMsg.Union.verify|verify} messages.
             * @function encodeDelimited
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteBatchMsg.IUnion} message Union message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Union.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Union message from the specified reader or buffer.
             * @function decode
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {bnsd.ExecuteBatchMsg.Union} Union
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Union.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.ExecuteBatchMsg.Union();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 51:
                        message.cashSendMsg = $root.cash.SendMsg.decode(reader, reader.uint32());
                        break;
                    case 52:
                        message.escrowCreateMsg = $root.escrow.CreateMsg.decode(reader, reader.uint32());
                        break;
                    case 53:
                        message.escrowReleaseMsg = $root.escrow.ReleaseMsg.decode(reader, reader.uint32());
                        break;
                    case 54:
                        message.escrowReturnMsg = $root.escrow.ReturnMsg.decode(reader, reader.uint32());
                        break;
                    case 55:
                        message.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.decode(reader, reader.uint32());
                        break;
                    case 56:
                        message.multisigCreateMsg = $root.multisig.CreateMsg.decode(reader, reader.uint32());
                        break;
                    case 57:
                        message.multisigUpdateMsg = $root.multisig.UpdateMsg.decode(reader, reader.uint32());
                        break;
                    case 58:
                        message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.decode(reader, reader.uint32());
                        break;
                    case 59:
                        message.currencyCreateMsg = $root.currency.CreateMsg.decode(reader, reader.uint32());
                        break;
                    case 61:
                        message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.decode(reader, reader.uint32());
                        break;
                    case 62:
                        message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.decode(reader, reader.uint32());
                        break;
                    case 63:
                        message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.decode(reader, reader.uint32());
                        break;
                    case 66:
                        message.distributionCreateMsg = $root.distribution.CreateMsg.decode(reader, reader.uint32());
                        break;
                    case 67:
                        message.distributionMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                        break;
                    case 68:
                        message.distributionResetMsg = $root.distribution.ResetMsg.decode(reader, reader.uint32());
                        break;
                    case 80:
                        message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Union message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {bnsd.ExecuteBatchMsg.Union} Union
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Union.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Union message.
             * @function verify
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Union.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                    properties.sum = 1;
                    {
                        var error = $root.cash.SendMsg.verify(message.cashSendMsg);
                        if (error)
                            return "cashSendMsg." + error;
                    }
                }
                if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.CreateMsg.verify(message.escrowCreateMsg);
                        if (error)
                            return "escrowCreateMsg." + error;
                    }
                }
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.ReleaseMsg.verify(message.escrowReleaseMsg);
                        if (error)
                            return "escrowReleaseMsg." + error;
                    }
                }
                if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.ReturnMsg.verify(message.escrowReturnMsg);
                        if (error)
                            return "escrowReturnMsg." + error;
                    }
                }
                if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.UpdatePartiesMsg.verify(message.escrowUpdatePartiesMsg);
                        if (error)
                            return "escrowUpdatePartiesMsg." + error;
                    }
                }
                if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.multisig.CreateMsg.verify(message.multisigCreateMsg);
                        if (error)
                            return "multisigCreateMsg." + error;
                    }
                }
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.multisig.UpdateMsg.verify(message.multisigUpdateMsg);
                        if (error)
                            return "multisigUpdateMsg." + error;
                    }
                }
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.validators.ApplyDiffMsg.verify(message.validatorsApplyDiffMsg);
                        if (error)
                            return "validatorsApplyDiffMsg." + error;
                    }
                }
                if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.currency.CreateMsg.verify(message.currencyCreateMsg);
                        if (error)
                            return "currencyCreateMsg." + error;
                    }
                }
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.RegisterTokenMsg.verify(message.usernameRegisterTokenMsg);
                        if (error)
                            return "usernameRegisterTokenMsg." + error;
                    }
                }
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.TransferTokenMsg.verify(message.usernameTransferTokenMsg);
                        if (error)
                            return "usernameTransferTokenMsg." + error;
                    }
                }
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.ChangeTokenTargetsMsg.verify(message.usernameChangeTokenTargetsMsg);
                        if (error)
                            return "usernameChangeTokenTargetsMsg." + error;
                    }
                }
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.CreateMsg.verify(message.distributionCreateMsg);
                        if (error)
                            return "distributionCreateMsg." + error;
                    }
                }
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.DistributeMsg.verify(message.distributionMsg);
                        if (error)
                            return "distributionMsg." + error;
                    }
                }
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.ResetMsg.verify(message.distributionResetMsg);
                        if (error)
                            return "distributionResetMsg." + error;
                    }
                }
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.msgfee.SetMsgFeeMsg.verify(message.msgfeeSetMsgFeeMsg);
                        if (error)
                            return "msgfeeSetMsgFeeMsg." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Union message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {bnsd.ExecuteBatchMsg.Union} Union
             */
            Union.fromObject = function fromObject(object) {
                if (object instanceof $root.bnsd.ExecuteBatchMsg.Union)
                    return object;
                var message = new $root.bnsd.ExecuteBatchMsg.Union();
                if (object.cashSendMsg != null) {
                    if (typeof object.cashSendMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.cashSendMsg: object expected");
                    message.cashSendMsg = $root.cash.SendMsg.fromObject(object.cashSendMsg);
                }
                if (object.escrowCreateMsg != null) {
                    if (typeof object.escrowCreateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.escrowCreateMsg: object expected");
                    message.escrowCreateMsg = $root.escrow.CreateMsg.fromObject(object.escrowCreateMsg);
                }
                if (object.escrowReleaseMsg != null) {
                    if (typeof object.escrowReleaseMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.escrowReleaseMsg: object expected");
                    message.escrowReleaseMsg = $root.escrow.ReleaseMsg.fromObject(object.escrowReleaseMsg);
                }
                if (object.escrowReturnMsg != null) {
                    if (typeof object.escrowReturnMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.escrowReturnMsg: object expected");
                    message.escrowReturnMsg = $root.escrow.ReturnMsg.fromObject(object.escrowReturnMsg);
                }
                if (object.escrowUpdatePartiesMsg != null) {
                    if (typeof object.escrowUpdatePartiesMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.escrowUpdatePartiesMsg: object expected");
                    message.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.fromObject(object.escrowUpdatePartiesMsg);
                }
                if (object.multisigCreateMsg != null) {
                    if (typeof object.multisigCreateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.multisigCreateMsg: object expected");
                    message.multisigCreateMsg = $root.multisig.CreateMsg.fromObject(object.multisigCreateMsg);
                }
                if (object.multisigUpdateMsg != null) {
                    if (typeof object.multisigUpdateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.multisigUpdateMsg: object expected");
                    message.multisigUpdateMsg = $root.multisig.UpdateMsg.fromObject(object.multisigUpdateMsg);
                }
                if (object.validatorsApplyDiffMsg != null) {
                    if (typeof object.validatorsApplyDiffMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.validatorsApplyDiffMsg: object expected");
                    message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.fromObject(object.validatorsApplyDiffMsg);
                }
                if (object.currencyCreateMsg != null) {
                    if (typeof object.currencyCreateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.currencyCreateMsg: object expected");
                    message.currencyCreateMsg = $root.currency.CreateMsg.fromObject(object.currencyCreateMsg);
                }
                if (object.usernameRegisterTokenMsg != null) {
                    if (typeof object.usernameRegisterTokenMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.usernameRegisterTokenMsg: object expected");
                    message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.fromObject(object.usernameRegisterTokenMsg);
                }
                if (object.usernameTransferTokenMsg != null) {
                    if (typeof object.usernameTransferTokenMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.usernameTransferTokenMsg: object expected");
                    message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.fromObject(object.usernameTransferTokenMsg);
                }
                if (object.usernameChangeTokenTargetsMsg != null) {
                    if (typeof object.usernameChangeTokenTargetsMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.usernameChangeTokenTargetsMsg: object expected");
                    message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.fromObject(object.usernameChangeTokenTargetsMsg);
                }
                if (object.distributionCreateMsg != null) {
                    if (typeof object.distributionCreateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.distributionCreateMsg: object expected");
                    message.distributionCreateMsg = $root.distribution.CreateMsg.fromObject(object.distributionCreateMsg);
                }
                if (object.distributionMsg != null) {
                    if (typeof object.distributionMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.distributionMsg: object expected");
                    message.distributionMsg = $root.distribution.DistributeMsg.fromObject(object.distributionMsg);
                }
                if (object.distributionResetMsg != null) {
                    if (typeof object.distributionResetMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.distributionResetMsg: object expected");
                    message.distributionResetMsg = $root.distribution.ResetMsg.fromObject(object.distributionResetMsg);
                }
                if (object.msgfeeSetMsgFeeMsg != null) {
                    if (typeof object.msgfeeSetMsgFeeMsg !== "object")
                        throw TypeError(".bnsd.ExecuteBatchMsg.Union.msgfeeSetMsgFeeMsg: object expected");
                    message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.fromObject(object.msgfeeSetMsgFeeMsg);
                }
                return message;
            };

            /**
             * Creates a plain object from an Union message. Also converts values to other types if specified.
             * @function toObject
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteBatchMsg.Union} message Union
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Union.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                    object.cashSendMsg = $root.cash.SendMsg.toObject(message.cashSendMsg, options);
                    if (options.oneofs)
                        object.sum = "cashSendMsg";
                }
                if (message.escrowCreateMsg != null && message.hasOwnProperty("escrowCreateMsg")) {
                    object.escrowCreateMsg = $root.escrow.CreateMsg.toObject(message.escrowCreateMsg, options);
                    if (options.oneofs)
                        object.sum = "escrowCreateMsg";
                }
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                    object.escrowReleaseMsg = $root.escrow.ReleaseMsg.toObject(message.escrowReleaseMsg, options);
                    if (options.oneofs)
                        object.sum = "escrowReleaseMsg";
                }
                if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                    object.escrowReturnMsg = $root.escrow.ReturnMsg.toObject(message.escrowReturnMsg, options);
                    if (options.oneofs)
                        object.sum = "escrowReturnMsg";
                }
                if (message.escrowUpdatePartiesMsg != null && message.hasOwnProperty("escrowUpdatePartiesMsg")) {
                    object.escrowUpdatePartiesMsg = $root.escrow.UpdatePartiesMsg.toObject(message.escrowUpdatePartiesMsg, options);
                    if (options.oneofs)
                        object.sum = "escrowUpdatePartiesMsg";
                }
                if (message.multisigCreateMsg != null && message.hasOwnProperty("multisigCreateMsg")) {
                    object.multisigCreateMsg = $root.multisig.CreateMsg.toObject(message.multisigCreateMsg, options);
                    if (options.oneofs)
                        object.sum = "multisigCreateMsg";
                }
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                    object.multisigUpdateMsg = $root.multisig.UpdateMsg.toObject(message.multisigUpdateMsg, options);
                    if (options.oneofs)
                        object.sum = "multisigUpdateMsg";
                }
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                    object.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.toObject(message.validatorsApplyDiffMsg, options);
                    if (options.oneofs)
                        object.sum = "validatorsApplyDiffMsg";
                }
                if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                    object.currencyCreateMsg = $root.currency.CreateMsg.toObject(message.currencyCreateMsg, options);
                    if (options.oneofs)
                        object.sum = "currencyCreateMsg";
                }
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                    object.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.toObject(message.usernameRegisterTokenMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameRegisterTokenMsg";
                }
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                    object.usernameTransferTokenMsg = $root.username.TransferTokenMsg.toObject(message.usernameTransferTokenMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameTransferTokenMsg";
                }
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                    object.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.toObject(message.usernameChangeTokenTargetsMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameChangeTokenTargetsMsg";
                }
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                    object.distributionCreateMsg = $root.distribution.CreateMsg.toObject(message.distributionCreateMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionCreateMsg";
                }
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                    object.distributionMsg = $root.distribution.DistributeMsg.toObject(message.distributionMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionMsg";
                }
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                    object.distributionResetMsg = $root.distribution.ResetMsg.toObject(message.distributionResetMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionResetMsg";
                }
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                    object.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.toObject(message.msgfeeSetMsgFeeMsg, options);
                    if (options.oneofs)
                        object.sum = "msgfeeSetMsgFeeMsg";
                }
                return object;
            };

            /**
             * Converts this Union to JSON.
             * @function toJSON
             * @memberof bnsd.ExecuteBatchMsg.Union
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Union.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Union;
        })();

        return ExecuteBatchMsg;
    })();

    bnsd.ProposalOptions = (function() {

        /**
         * Properties of a ProposalOptions.
         * @memberof bnsd
         * @interface IProposalOptions
         * @property {cash.ISendMsg|null} [cashSendMsg] ProposalOptions cashSendMsg
         * @property {escrow.IReleaseMsg|null} [escrowReleaseMsg] ProposalOptions escrowReleaseMsg
         * @property {escrow.IUpdatePartiesMsg|null} [updateEscrowPartiesMsg] ProposalOptions updateEscrowPartiesMsg
         * @property {multisig.IUpdateMsg|null} [multisigUpdateMsg] ProposalOptions multisigUpdateMsg
         * @property {validators.IApplyDiffMsg|null} [validatorsApplyDiffMsg] ProposalOptions validatorsApplyDiffMsg
         * @property {currency.ICreateMsg|null} [currencyCreateMsg] ProposalOptions currencyCreateMsg
         * @property {bnsd.IExecuteProposalBatchMsg|null} [executeProposalBatchMsg] ProposalOptions executeProposalBatchMsg
         * @property {username.IRegisterTokenMsg|null} [usernameRegisterTokenMsg] ProposalOptions usernameRegisterTokenMsg
         * @property {username.ITransferTokenMsg|null} [usernameTransferTokenMsg] ProposalOptions usernameTransferTokenMsg
         * @property {username.IChangeTokenTargetsMsg|null} [usernameChangeTokenTargetsMsg] ProposalOptions usernameChangeTokenTargetsMsg
         * @property {distribution.ICreateMsg|null} [distributionCreateMsg] ProposalOptions distributionCreateMsg
         * @property {distribution.IDistributeMsg|null} [distributionMsg] ProposalOptions distributionMsg
         * @property {distribution.IResetMsg|null} [distributionResetMsg] ProposalOptions distributionResetMsg
         * @property {migration.IUpgradeSchemaMsg|null} [migrationUpgradeSchemaMsg] ProposalOptions migrationUpgradeSchemaMsg
         * @property {gov.IUpdateElectorateMsg|null} [govUpdateElectorateMsg] ProposalOptions govUpdateElectorateMsg
         * @property {gov.IUpdateElectionRuleMsg|null} [govUpdateElectionRuleMsg] ProposalOptions govUpdateElectionRuleMsg
         * @property {gov.ICreateTextResolutionMsg|null} [govCreateTextResolutionMsg] ProposalOptions govCreateTextResolutionMsg
         * @property {msgfee.ISetMsgFeeMsg|null} [msgfeeSetMsgFeeMsg] ProposalOptions msgfeeSetMsgFeeMsg
         */

        /**
         * Constructs a new ProposalOptions.
         * @memberof bnsd
         * @classdesc Trimmed down somewhat arbitrary to what is believed to be reasonable
         * @implements IProposalOptions
         * @constructor
         * @param {bnsd.IProposalOptions=} [properties] Properties to set
         */
        function ProposalOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalOptions cashSendMsg.
         * @member {cash.ISendMsg|null|undefined} cashSendMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.cashSendMsg = null;

        /**
         * ProposalOptions escrowReleaseMsg.
         * @member {escrow.IReleaseMsg|null|undefined} escrowReleaseMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.escrowReleaseMsg = null;

        /**
         * ProposalOptions updateEscrowPartiesMsg.
         * @member {escrow.IUpdatePartiesMsg|null|undefined} updateEscrowPartiesMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.updateEscrowPartiesMsg = null;

        /**
         * ProposalOptions multisigUpdateMsg.
         * @member {multisig.IUpdateMsg|null|undefined} multisigUpdateMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.multisigUpdateMsg = null;

        /**
         * ProposalOptions validatorsApplyDiffMsg.
         * @member {validators.IApplyDiffMsg|null|undefined} validatorsApplyDiffMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.validatorsApplyDiffMsg = null;

        /**
         * ProposalOptions currencyCreateMsg.
         * @member {currency.ICreateMsg|null|undefined} currencyCreateMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.currencyCreateMsg = null;

        /**
         * ProposalOptions executeProposalBatchMsg.
         * @member {bnsd.IExecuteProposalBatchMsg|null|undefined} executeProposalBatchMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.executeProposalBatchMsg = null;

        /**
         * ProposalOptions usernameRegisterTokenMsg.
         * @member {username.IRegisterTokenMsg|null|undefined} usernameRegisterTokenMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.usernameRegisterTokenMsg = null;

        /**
         * ProposalOptions usernameTransferTokenMsg.
         * @member {username.ITransferTokenMsg|null|undefined} usernameTransferTokenMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.usernameTransferTokenMsg = null;

        /**
         * ProposalOptions usernameChangeTokenTargetsMsg.
         * @member {username.IChangeTokenTargetsMsg|null|undefined} usernameChangeTokenTargetsMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.usernameChangeTokenTargetsMsg = null;

        /**
         * ProposalOptions distributionCreateMsg.
         * @member {distribution.ICreateMsg|null|undefined} distributionCreateMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.distributionCreateMsg = null;

        /**
         * ProposalOptions distributionMsg.
         * @member {distribution.IDistributeMsg|null|undefined} distributionMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.distributionMsg = null;

        /**
         * ProposalOptions distributionResetMsg.
         * @member {distribution.IResetMsg|null|undefined} distributionResetMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.distributionResetMsg = null;

        /**
         * ProposalOptions migrationUpgradeSchemaMsg.
         * @member {migration.IUpgradeSchemaMsg|null|undefined} migrationUpgradeSchemaMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.migrationUpgradeSchemaMsg = null;

        /**
         * ProposalOptions govUpdateElectorateMsg.
         * @member {gov.IUpdateElectorateMsg|null|undefined} govUpdateElectorateMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.govUpdateElectorateMsg = null;

        /**
         * ProposalOptions govUpdateElectionRuleMsg.
         * @member {gov.IUpdateElectionRuleMsg|null|undefined} govUpdateElectionRuleMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.govUpdateElectionRuleMsg = null;

        /**
         * ProposalOptions govCreateTextResolutionMsg.
         * @member {gov.ICreateTextResolutionMsg|null|undefined} govCreateTextResolutionMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.govCreateTextResolutionMsg = null;

        /**
         * ProposalOptions msgfeeSetMsgFeeMsg.
         * @member {msgfee.ISetMsgFeeMsg|null|undefined} msgfeeSetMsgFeeMsg
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.msgfeeSetMsgFeeMsg = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ProposalOptions option.
         * @member {"cashSendMsg"|"escrowReleaseMsg"|"updateEscrowPartiesMsg"|"multisigUpdateMsg"|"validatorsApplyDiffMsg"|"currencyCreateMsg"|"executeProposalBatchMsg"|"usernameRegisterTokenMsg"|"usernameTransferTokenMsg"|"usernameChangeTokenTargetsMsg"|"distributionCreateMsg"|"distributionMsg"|"distributionResetMsg"|"migrationUpgradeSchemaMsg"|"govUpdateElectorateMsg"|"govUpdateElectionRuleMsg"|"govCreateTextResolutionMsg"|"msgfeeSetMsgFeeMsg"|undefined} option
         * @memberof bnsd.ProposalOptions
         * @instance
         */
        Object.defineProperty(ProposalOptions.prototype, "option", {
            get: $util.oneOfGetter($oneOfFields = ["cashSendMsg", "escrowReleaseMsg", "updateEscrowPartiesMsg", "multisigUpdateMsg", "validatorsApplyDiffMsg", "currencyCreateMsg", "executeProposalBatchMsg", "usernameRegisterTokenMsg", "usernameTransferTokenMsg", "usernameChangeTokenTargetsMsg", "distributionCreateMsg", "distributionMsg", "distributionResetMsg", "migrationUpgradeSchemaMsg", "govUpdateElectorateMsg", "govUpdateElectionRuleMsg", "govCreateTextResolutionMsg", "msgfeeSetMsgFeeMsg"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ProposalOptions instance using the specified properties.
         * @function create
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {bnsd.IProposalOptions=} [properties] Properties to set
         * @returns {bnsd.ProposalOptions} ProposalOptions instance
         */
        ProposalOptions.create = function create(properties) {
            return new ProposalOptions(properties);
        };

        /**
         * Encodes the specified ProposalOptions message. Does not implicitly {@link bnsd.ProposalOptions.verify|verify} messages.
         * @function encode
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {bnsd.IProposalOptions} message ProposalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg"))
                $root.cash.SendMsg.encode(message.cashSendMsg, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg"))
                $root.escrow.ReleaseMsg.encode(message.escrowReleaseMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg"))
                $root.escrow.UpdatePartiesMsg.encode(message.updateEscrowPartiesMsg, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg"))
                $root.multisig.UpdateMsg.encode(message.multisigUpdateMsg, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg"))
                $root.validators.ApplyDiffMsg.encode(message.validatorsApplyDiffMsg, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg"))
                $root.currency.CreateMsg.encode(message.currencyCreateMsg, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
            if (message.executeProposalBatchMsg != null && message.hasOwnProperty("executeProposalBatchMsg"))
                $root.bnsd.ExecuteProposalBatchMsg.encode(message.executeProposalBatchMsg, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg"))
                $root.username.RegisterTokenMsg.encode(message.usernameRegisterTokenMsg, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg"))
                $root.username.TransferTokenMsg.encode(message.usernameTransferTokenMsg, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg"))
                $root.username.ChangeTokenTargetsMsg.encode(message.usernameChangeTokenTargetsMsg, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg"))
                $root.distribution.CreateMsg.encode(message.distributionCreateMsg, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg"))
                $root.distribution.DistributeMsg.encode(message.distributionMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg"))
                $root.distribution.ResetMsg.encode(message.distributionResetMsg, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg"))
                $root.migration.UpgradeSchemaMsg.encode(message.migrationUpgradeSchemaMsg, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg"))
                $root.gov.UpdateElectorateMsg.encode(message.govUpdateElectorateMsg, writer.uint32(/* id 77, wireType 2 =*/618).fork()).ldelim();
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg"))
                $root.gov.UpdateElectionRuleMsg.encode(message.govUpdateElectionRuleMsg, writer.uint32(/* id 78, wireType 2 =*/626).fork()).ldelim();
            if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg"))
                $root.gov.CreateTextResolutionMsg.encode(message.govCreateTextResolutionMsg, writer.uint32(/* id 79, wireType 2 =*/634).fork()).ldelim();
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg"))
                $root.msgfee.SetMsgFeeMsg.encode(message.msgfeeSetMsgFeeMsg, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProposalOptions message, length delimited. Does not implicitly {@link bnsd.ProposalOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {bnsd.IProposalOptions} message ProposalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalOptions message from the specified reader or buffer.
         * @function decode
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bnsd.ProposalOptions} ProposalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.ProposalOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 51:
                    message.cashSendMsg = $root.cash.SendMsg.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.escrowReleaseMsg = $root.escrow.ReleaseMsg.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.decode(reader, reader.uint32());
                    break;
                case 57:
                    message.multisigUpdateMsg = $root.multisig.UpdateMsg.decode(reader, reader.uint32());
                    break;
                case 58:
                    message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.decode(reader, reader.uint32());
                    break;
                case 59:
                    message.currencyCreateMsg = $root.currency.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 60:
                    message.executeProposalBatchMsg = $root.bnsd.ExecuteProposalBatchMsg.decode(reader, reader.uint32());
                    break;
                case 61:
                    message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.decode(reader, reader.uint32());
                    break;
                case 62:
                    message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.decode(reader, reader.uint32());
                    break;
                case 63:
                    message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.decode(reader, reader.uint32());
                    break;
                case 66:
                    message.distributionCreateMsg = $root.distribution.CreateMsg.decode(reader, reader.uint32());
                    break;
                case 67:
                    message.distributionMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                    break;
                case 68:
                    message.distributionResetMsg = $root.distribution.ResetMsg.decode(reader, reader.uint32());
                    break;
                case 69:
                    message.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.decode(reader, reader.uint32());
                    break;
                case 77:
                    message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.decode(reader, reader.uint32());
                    break;
                case 78:
                    message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.decode(reader, reader.uint32());
                    break;
                case 79:
                    message.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.decode(reader, reader.uint32());
                    break;
                case 80:
                    message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bnsd.ProposalOptions} ProposalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalOptions message.
         * @function verify
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                properties.option = 1;
                {
                    var error = $root.cash.SendMsg.verify(message.cashSendMsg);
                    if (error)
                        return "cashSendMsg." + error;
                }
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.escrow.ReleaseMsg.verify(message.escrowReleaseMsg);
                    if (error)
                        return "escrowReleaseMsg." + error;
                }
            }
            if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.escrow.UpdatePartiesMsg.verify(message.updateEscrowPartiesMsg);
                    if (error)
                        return "updateEscrowPartiesMsg." + error;
                }
            }
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.multisig.UpdateMsg.verify(message.multisigUpdateMsg);
                    if (error)
                        return "multisigUpdateMsg." + error;
                }
            }
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.validators.ApplyDiffMsg.verify(message.validatorsApplyDiffMsg);
                    if (error)
                        return "validatorsApplyDiffMsg." + error;
                }
            }
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.currency.CreateMsg.verify(message.currencyCreateMsg);
                    if (error)
                        return "currencyCreateMsg." + error;
                }
            }
            if (message.executeProposalBatchMsg != null && message.hasOwnProperty("executeProposalBatchMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.bnsd.ExecuteProposalBatchMsg.verify(message.executeProposalBatchMsg);
                    if (error)
                        return "executeProposalBatchMsg." + error;
                }
            }
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.username.RegisterTokenMsg.verify(message.usernameRegisterTokenMsg);
                    if (error)
                        return "usernameRegisterTokenMsg." + error;
                }
            }
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.username.TransferTokenMsg.verify(message.usernameTransferTokenMsg);
                    if (error)
                        return "usernameTransferTokenMsg." + error;
                }
            }
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.username.ChangeTokenTargetsMsg.verify(message.usernameChangeTokenTargetsMsg);
                    if (error)
                        return "usernameChangeTokenTargetsMsg." + error;
                }
            }
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.distribution.CreateMsg.verify(message.distributionCreateMsg);
                    if (error)
                        return "distributionCreateMsg." + error;
                }
            }
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.distribution.DistributeMsg.verify(message.distributionMsg);
                    if (error)
                        return "distributionMsg." + error;
                }
            }
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.distribution.ResetMsg.verify(message.distributionResetMsg);
                    if (error)
                        return "distributionResetMsg." + error;
                }
            }
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.migration.UpgradeSchemaMsg.verify(message.migrationUpgradeSchemaMsg);
                    if (error)
                        return "migrationUpgradeSchemaMsg." + error;
                }
            }
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.gov.UpdateElectorateMsg.verify(message.govUpdateElectorateMsg);
                    if (error)
                        return "govUpdateElectorateMsg." + error;
                }
            }
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.gov.UpdateElectionRuleMsg.verify(message.govUpdateElectionRuleMsg);
                    if (error)
                        return "govUpdateElectionRuleMsg." + error;
                }
            }
            if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.gov.CreateTextResolutionMsg.verify(message.govCreateTextResolutionMsg);
                    if (error)
                        return "govCreateTextResolutionMsg." + error;
                }
            }
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.msgfee.SetMsgFeeMsg.verify(message.msgfeeSetMsgFeeMsg);
                    if (error)
                        return "msgfeeSetMsgFeeMsg." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ProposalOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bnsd.ProposalOptions} ProposalOptions
         */
        ProposalOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.bnsd.ProposalOptions)
                return object;
            var message = new $root.bnsd.ProposalOptions();
            if (object.cashSendMsg != null) {
                if (typeof object.cashSendMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.cashSendMsg: object expected");
                message.cashSendMsg = $root.cash.SendMsg.fromObject(object.cashSendMsg);
            }
            if (object.escrowReleaseMsg != null) {
                if (typeof object.escrowReleaseMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.escrowReleaseMsg: object expected");
                message.escrowReleaseMsg = $root.escrow.ReleaseMsg.fromObject(object.escrowReleaseMsg);
            }
            if (object.updateEscrowPartiesMsg != null) {
                if (typeof object.updateEscrowPartiesMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.updateEscrowPartiesMsg: object expected");
                message.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.fromObject(object.updateEscrowPartiesMsg);
            }
            if (object.multisigUpdateMsg != null) {
                if (typeof object.multisigUpdateMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.multisigUpdateMsg: object expected");
                message.multisigUpdateMsg = $root.multisig.UpdateMsg.fromObject(object.multisigUpdateMsg);
            }
            if (object.validatorsApplyDiffMsg != null) {
                if (typeof object.validatorsApplyDiffMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.validatorsApplyDiffMsg: object expected");
                message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.fromObject(object.validatorsApplyDiffMsg);
            }
            if (object.currencyCreateMsg != null) {
                if (typeof object.currencyCreateMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.currencyCreateMsg: object expected");
                message.currencyCreateMsg = $root.currency.CreateMsg.fromObject(object.currencyCreateMsg);
            }
            if (object.executeProposalBatchMsg != null) {
                if (typeof object.executeProposalBatchMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.executeProposalBatchMsg: object expected");
                message.executeProposalBatchMsg = $root.bnsd.ExecuteProposalBatchMsg.fromObject(object.executeProposalBatchMsg);
            }
            if (object.usernameRegisterTokenMsg != null) {
                if (typeof object.usernameRegisterTokenMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.usernameRegisterTokenMsg: object expected");
                message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.fromObject(object.usernameRegisterTokenMsg);
            }
            if (object.usernameTransferTokenMsg != null) {
                if (typeof object.usernameTransferTokenMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.usernameTransferTokenMsg: object expected");
                message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.fromObject(object.usernameTransferTokenMsg);
            }
            if (object.usernameChangeTokenTargetsMsg != null) {
                if (typeof object.usernameChangeTokenTargetsMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.usernameChangeTokenTargetsMsg: object expected");
                message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.fromObject(object.usernameChangeTokenTargetsMsg);
            }
            if (object.distributionCreateMsg != null) {
                if (typeof object.distributionCreateMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.distributionCreateMsg: object expected");
                message.distributionCreateMsg = $root.distribution.CreateMsg.fromObject(object.distributionCreateMsg);
            }
            if (object.distributionMsg != null) {
                if (typeof object.distributionMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.distributionMsg: object expected");
                message.distributionMsg = $root.distribution.DistributeMsg.fromObject(object.distributionMsg);
            }
            if (object.distributionResetMsg != null) {
                if (typeof object.distributionResetMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.distributionResetMsg: object expected");
                message.distributionResetMsg = $root.distribution.ResetMsg.fromObject(object.distributionResetMsg);
            }
            if (object.migrationUpgradeSchemaMsg != null) {
                if (typeof object.migrationUpgradeSchemaMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.migrationUpgradeSchemaMsg: object expected");
                message.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.fromObject(object.migrationUpgradeSchemaMsg);
            }
            if (object.govUpdateElectorateMsg != null) {
                if (typeof object.govUpdateElectorateMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.govUpdateElectorateMsg: object expected");
                message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.fromObject(object.govUpdateElectorateMsg);
            }
            if (object.govUpdateElectionRuleMsg != null) {
                if (typeof object.govUpdateElectionRuleMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.govUpdateElectionRuleMsg: object expected");
                message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.fromObject(object.govUpdateElectionRuleMsg);
            }
            if (object.govCreateTextResolutionMsg != null) {
                if (typeof object.govCreateTextResolutionMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.govCreateTextResolutionMsg: object expected");
                message.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.fromObject(object.govCreateTextResolutionMsg);
            }
            if (object.msgfeeSetMsgFeeMsg != null) {
                if (typeof object.msgfeeSetMsgFeeMsg !== "object")
                    throw TypeError(".bnsd.ProposalOptions.msgfeeSetMsgFeeMsg: object expected");
                message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.fromObject(object.msgfeeSetMsgFeeMsg);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProposalOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bnsd.ProposalOptions
         * @static
         * @param {bnsd.ProposalOptions} message ProposalOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.cashSendMsg != null && message.hasOwnProperty("cashSendMsg")) {
                object.cashSendMsg = $root.cash.SendMsg.toObject(message.cashSendMsg, options);
                if (options.oneofs)
                    object.option = "cashSendMsg";
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                object.escrowReleaseMsg = $root.escrow.ReleaseMsg.toObject(message.escrowReleaseMsg, options);
                if (options.oneofs)
                    object.option = "escrowReleaseMsg";
            }
            if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg")) {
                object.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.toObject(message.updateEscrowPartiesMsg, options);
                if (options.oneofs)
                    object.option = "updateEscrowPartiesMsg";
            }
            if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                object.multisigUpdateMsg = $root.multisig.UpdateMsg.toObject(message.multisigUpdateMsg, options);
                if (options.oneofs)
                    object.option = "multisigUpdateMsg";
            }
            if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                object.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.toObject(message.validatorsApplyDiffMsg, options);
                if (options.oneofs)
                    object.option = "validatorsApplyDiffMsg";
            }
            if (message.currencyCreateMsg != null && message.hasOwnProperty("currencyCreateMsg")) {
                object.currencyCreateMsg = $root.currency.CreateMsg.toObject(message.currencyCreateMsg, options);
                if (options.oneofs)
                    object.option = "currencyCreateMsg";
            }
            if (message.executeProposalBatchMsg != null && message.hasOwnProperty("executeProposalBatchMsg")) {
                object.executeProposalBatchMsg = $root.bnsd.ExecuteProposalBatchMsg.toObject(message.executeProposalBatchMsg, options);
                if (options.oneofs)
                    object.option = "executeProposalBatchMsg";
            }
            if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                object.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.toObject(message.usernameRegisterTokenMsg, options);
                if (options.oneofs)
                    object.option = "usernameRegisterTokenMsg";
            }
            if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                object.usernameTransferTokenMsg = $root.username.TransferTokenMsg.toObject(message.usernameTransferTokenMsg, options);
                if (options.oneofs)
                    object.option = "usernameTransferTokenMsg";
            }
            if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                object.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.toObject(message.usernameChangeTokenTargetsMsg, options);
                if (options.oneofs)
                    object.option = "usernameChangeTokenTargetsMsg";
            }
            if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                object.distributionCreateMsg = $root.distribution.CreateMsg.toObject(message.distributionCreateMsg, options);
                if (options.oneofs)
                    object.option = "distributionCreateMsg";
            }
            if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                object.distributionMsg = $root.distribution.DistributeMsg.toObject(message.distributionMsg, options);
                if (options.oneofs)
                    object.option = "distributionMsg";
            }
            if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                object.distributionResetMsg = $root.distribution.ResetMsg.toObject(message.distributionResetMsg, options);
                if (options.oneofs)
                    object.option = "distributionResetMsg";
            }
            if (message.migrationUpgradeSchemaMsg != null && message.hasOwnProperty("migrationUpgradeSchemaMsg")) {
                object.migrationUpgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.toObject(message.migrationUpgradeSchemaMsg, options);
                if (options.oneofs)
                    object.option = "migrationUpgradeSchemaMsg";
            }
            if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                object.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.toObject(message.govUpdateElectorateMsg, options);
                if (options.oneofs)
                    object.option = "govUpdateElectorateMsg";
            }
            if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                object.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.toObject(message.govUpdateElectionRuleMsg, options);
                if (options.oneofs)
                    object.option = "govUpdateElectionRuleMsg";
            }
            if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg")) {
                object.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.toObject(message.govCreateTextResolutionMsg, options);
                if (options.oneofs)
                    object.option = "govCreateTextResolutionMsg";
            }
            if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                object.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.toObject(message.msgfeeSetMsgFeeMsg, options);
                if (options.oneofs)
                    object.option = "msgfeeSetMsgFeeMsg";
            }
            return object;
        };

        /**
         * Converts this ProposalOptions to JSON.
         * @function toJSON
         * @memberof bnsd.ProposalOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalOptions;
    })();

    bnsd.ExecuteProposalBatchMsg = (function() {

        /**
         * Properties of an ExecuteProposalBatchMsg.
         * @memberof bnsd
         * @interface IExecuteProposalBatchMsg
         * @property {Array.<bnsd.ExecuteProposalBatchMsg.IUnion>|null} [messages] ExecuteProposalBatchMsg messages
         */

        /**
         * Constructs a new ExecuteProposalBatchMsg.
         * @memberof bnsd
         * @classdesc Represents an ExecuteProposalBatchMsg.
         * @implements IExecuteProposalBatchMsg
         * @constructor
         * @param {bnsd.IExecuteProposalBatchMsg=} [properties] Properties to set
         */
        function ExecuteProposalBatchMsg(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecuteProposalBatchMsg messages.
         * @member {Array.<bnsd.ExecuteProposalBatchMsg.IUnion>} messages
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @instance
         */
        ExecuteProposalBatchMsg.prototype.messages = $util.emptyArray;

        /**
         * Creates a new ExecuteProposalBatchMsg instance using the specified properties.
         * @function create
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {bnsd.IExecuteProposalBatchMsg=} [properties] Properties to set
         * @returns {bnsd.ExecuteProposalBatchMsg} ExecuteProposalBatchMsg instance
         */
        ExecuteProposalBatchMsg.create = function create(properties) {
            return new ExecuteProposalBatchMsg(properties);
        };

        /**
         * Encodes the specified ExecuteProposalBatchMsg message. Does not implicitly {@link bnsd.ExecuteProposalBatchMsg.verify|verify} messages.
         * @function encode
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {bnsd.IExecuteProposalBatchMsg} message ExecuteProposalBatchMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteProposalBatchMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.bnsd.ExecuteProposalBatchMsg.Union.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecuteProposalBatchMsg message, length delimited. Does not implicitly {@link bnsd.ExecuteProposalBatchMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {bnsd.IExecuteProposalBatchMsg} message ExecuteProposalBatchMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecuteProposalBatchMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecuteProposalBatchMsg message from the specified reader or buffer.
         * @function decode
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bnsd.ExecuteProposalBatchMsg} ExecuteProposalBatchMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteProposalBatchMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.ExecuteProposalBatchMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.bnsd.ExecuteProposalBatchMsg.Union.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecuteProposalBatchMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bnsd.ExecuteProposalBatchMsg} ExecuteProposalBatchMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecuteProposalBatchMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecuteProposalBatchMsg message.
         * @function verify
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecuteProposalBatchMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.bnsd.ExecuteProposalBatchMsg.Union.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecuteProposalBatchMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bnsd.ExecuteProposalBatchMsg} ExecuteProposalBatchMsg
         */
        ExecuteProposalBatchMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.bnsd.ExecuteProposalBatchMsg)
                return object;
            var message = new $root.bnsd.ExecuteProposalBatchMsg();
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".bnsd.ExecuteProposalBatchMsg.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.messages: object expected");
                    message.messages[i] = $root.bnsd.ExecuteProposalBatchMsg.Union.fromObject(object.messages[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecuteProposalBatchMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @static
         * @param {bnsd.ExecuteProposalBatchMsg} message ExecuteProposalBatchMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecuteProposalBatchMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.bnsd.ExecuteProposalBatchMsg.Union.toObject(message.messages[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecuteProposalBatchMsg to JSON.
         * @function toJSON
         * @memberof bnsd.ExecuteProposalBatchMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecuteProposalBatchMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ExecuteProposalBatchMsg.Union = (function() {

            /**
             * Properties of an Union.
             * @memberof bnsd.ExecuteProposalBatchMsg
             * @interface IUnion
             * @property {cash.ISendMsg|null} [sendMsg] Union sendMsg
             * @property {escrow.IReleaseMsg|null} [escrowReleaseMsg] Union escrowReleaseMsg
             * @property {escrow.IUpdatePartiesMsg|null} [updateEscrowPartiesMsg] Union updateEscrowPartiesMsg
             * @property {multisig.IUpdateMsg|null} [multisigUpdateMsg] Union multisigUpdateMsg
             * @property {validators.IApplyDiffMsg|null} [validatorsApplyDiffMsg] Union validatorsApplyDiffMsg
             * @property {username.IRegisterTokenMsg|null} [usernameRegisterTokenMsg] no recursive batches
             * @property {username.ITransferTokenMsg|null} [usernameTransferTokenMsg] Union usernameTransferTokenMsg
             * @property {username.IChangeTokenTargetsMsg|null} [usernameChangeTokenTargetsMsg] Union usernameChangeTokenTargetsMsg
             * @property {distribution.ICreateMsg|null} [distributionCreateMsg] Union distributionCreateMsg
             * @property {distribution.IDistributeMsg|null} [distributionMsg] Union distributionMsg
             * @property {distribution.IResetMsg|null} [distributionResetMsg] Union distributionResetMsg
             * @property {gov.IUpdateElectorateMsg|null} [govUpdateElectorateMsg] don't allow UpgradeSchema as part of a batch, as effects are too confusing
             * @property {gov.IUpdateElectionRuleMsg|null} [govUpdateElectionRuleMsg] Union govUpdateElectionRuleMsg
             * @property {gov.ICreateTextResolutionMsg|null} [govCreateTextResolutionMsg] Union govCreateTextResolutionMsg
             * @property {msgfee.ISetMsgFeeMsg|null} [msgfeeSetMsgFeeMsg] Union msgfeeSetMsgFeeMsg
             */

            /**
             * Constructs a new Union.
             * @memberof bnsd.ExecuteProposalBatchMsg
             * @classdesc Represents an Union.
             * @implements IUnion
             * @constructor
             * @param {bnsd.ExecuteProposalBatchMsg.IUnion=} [properties] Properties to set
             */
            function Union(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Union sendMsg.
             * @member {cash.ISendMsg|null|undefined} sendMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.sendMsg = null;

            /**
             * Union escrowReleaseMsg.
             * @member {escrow.IReleaseMsg|null|undefined} escrowReleaseMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.escrowReleaseMsg = null;

            /**
             * Union updateEscrowPartiesMsg.
             * @member {escrow.IUpdatePartiesMsg|null|undefined} updateEscrowPartiesMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.updateEscrowPartiesMsg = null;

            /**
             * Union multisigUpdateMsg.
             * @member {multisig.IUpdateMsg|null|undefined} multisigUpdateMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.multisigUpdateMsg = null;

            /**
             * Union validatorsApplyDiffMsg.
             * @member {validators.IApplyDiffMsg|null|undefined} validatorsApplyDiffMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.validatorsApplyDiffMsg = null;

            /**
             * no recursive batches
             * @member {username.IRegisterTokenMsg|null|undefined} usernameRegisterTokenMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameRegisterTokenMsg = null;

            /**
             * Union usernameTransferTokenMsg.
             * @member {username.ITransferTokenMsg|null|undefined} usernameTransferTokenMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameTransferTokenMsg = null;

            /**
             * Union usernameChangeTokenTargetsMsg.
             * @member {username.IChangeTokenTargetsMsg|null|undefined} usernameChangeTokenTargetsMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.usernameChangeTokenTargetsMsg = null;

            /**
             * Union distributionCreateMsg.
             * @member {distribution.ICreateMsg|null|undefined} distributionCreateMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionCreateMsg = null;

            /**
             * Union distributionMsg.
             * @member {distribution.IDistributeMsg|null|undefined} distributionMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionMsg = null;

            /**
             * Union distributionResetMsg.
             * @member {distribution.IResetMsg|null|undefined} distributionResetMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.distributionResetMsg = null;

            /**
             * don't allow UpgradeSchema as part of a batch, as effects are too confusing
             * @member {gov.IUpdateElectorateMsg|null|undefined} govUpdateElectorateMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.govUpdateElectorateMsg = null;

            /**
             * Union govUpdateElectionRuleMsg.
             * @member {gov.IUpdateElectionRuleMsg|null|undefined} govUpdateElectionRuleMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.govUpdateElectionRuleMsg = null;

            /**
             * Union govCreateTextResolutionMsg.
             * @member {gov.ICreateTextResolutionMsg|null|undefined} govCreateTextResolutionMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.govCreateTextResolutionMsg = null;

            /**
             * Union msgfeeSetMsgFeeMsg.
             * @member {msgfee.ISetMsgFeeMsg|null|undefined} msgfeeSetMsgFeeMsg
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Union.prototype.msgfeeSetMsgFeeMsg = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Union sum.
             * @member {"sendMsg"|"escrowReleaseMsg"|"updateEscrowPartiesMsg"|"multisigUpdateMsg"|"validatorsApplyDiffMsg"|"usernameRegisterTokenMsg"|"usernameTransferTokenMsg"|"usernameChangeTokenTargetsMsg"|"distributionCreateMsg"|"distributionMsg"|"distributionResetMsg"|"govUpdateElectorateMsg"|"govUpdateElectionRuleMsg"|"govCreateTextResolutionMsg"|"msgfeeSetMsgFeeMsg"|undefined} sum
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             */
            Object.defineProperty(Union.prototype, "sum", {
                get: $util.oneOfGetter($oneOfFields = ["sendMsg", "escrowReleaseMsg", "updateEscrowPartiesMsg", "multisigUpdateMsg", "validatorsApplyDiffMsg", "usernameRegisterTokenMsg", "usernameTransferTokenMsg", "usernameChangeTokenTargetsMsg", "distributionCreateMsg", "distributionMsg", "distributionResetMsg", "govUpdateElectorateMsg", "govUpdateElectionRuleMsg", "govCreateTextResolutionMsg", "msgfeeSetMsgFeeMsg"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Union instance using the specified properties.
             * @function create
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteProposalBatchMsg.IUnion=} [properties] Properties to set
             * @returns {bnsd.ExecuteProposalBatchMsg.Union} Union instance
             */
            Union.create = function create(properties) {
                return new Union(properties);
            };

            /**
             * Encodes the specified Union message. Does not implicitly {@link bnsd.ExecuteProposalBatchMsg.Union.verify|verify} messages.
             * @function encode
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteProposalBatchMsg.IUnion} message Union message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Union.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sendMsg != null && message.hasOwnProperty("sendMsg"))
                    $root.cash.SendMsg.encode(message.sendMsg, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg"))
                    $root.escrow.ReleaseMsg.encode(message.escrowReleaseMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
                if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg"))
                    $root.escrow.UpdatePartiesMsg.encode(message.updateEscrowPartiesMsg, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg"))
                    $root.multisig.UpdateMsg.encode(message.multisigUpdateMsg, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg"))
                    $root.validators.ApplyDiffMsg.encode(message.validatorsApplyDiffMsg, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg"))
                    $root.username.RegisterTokenMsg.encode(message.usernameRegisterTokenMsg, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg"))
                    $root.username.TransferTokenMsg.encode(message.usernameTransferTokenMsg, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg"))
                    $root.username.ChangeTokenTargetsMsg.encode(message.usernameChangeTokenTargetsMsg, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg"))
                    $root.distribution.CreateMsg.encode(message.distributionCreateMsg, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg"))
                    $root.distribution.DistributeMsg.encode(message.distributionMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg"))
                    $root.distribution.ResetMsg.encode(message.distributionResetMsg, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
                if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg"))
                    $root.gov.UpdateElectorateMsg.encode(message.govUpdateElectorateMsg, writer.uint32(/* id 77, wireType 2 =*/618).fork()).ldelim();
                if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg"))
                    $root.gov.UpdateElectionRuleMsg.encode(message.govUpdateElectionRuleMsg, writer.uint32(/* id 78, wireType 2 =*/626).fork()).ldelim();
                if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg"))
                    $root.gov.CreateTextResolutionMsg.encode(message.govCreateTextResolutionMsg, writer.uint32(/* id 79, wireType 2 =*/634).fork()).ldelim();
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg"))
                    $root.msgfee.SetMsgFeeMsg.encode(message.msgfeeSetMsgFeeMsg, writer.uint32(/* id 80, wireType 2 =*/642).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Union message, length delimited. Does not implicitly {@link bnsd.ExecuteProposalBatchMsg.Union.verify|verify} messages.
             * @function encodeDelimited
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteProposalBatchMsg.IUnion} message Union message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Union.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Union message from the specified reader or buffer.
             * @function decode
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {bnsd.ExecuteProposalBatchMsg.Union} Union
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Union.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.ExecuteProposalBatchMsg.Union();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 51:
                        message.sendMsg = $root.cash.SendMsg.decode(reader, reader.uint32());
                        break;
                    case 53:
                        message.escrowReleaseMsg = $root.escrow.ReleaseMsg.decode(reader, reader.uint32());
                        break;
                    case 55:
                        message.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.decode(reader, reader.uint32());
                        break;
                    case 57:
                        message.multisigUpdateMsg = $root.multisig.UpdateMsg.decode(reader, reader.uint32());
                        break;
                    case 58:
                        message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.decode(reader, reader.uint32());
                        break;
                    case 61:
                        message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.decode(reader, reader.uint32());
                        break;
                    case 62:
                        message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.decode(reader, reader.uint32());
                        break;
                    case 63:
                        message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.decode(reader, reader.uint32());
                        break;
                    case 66:
                        message.distributionCreateMsg = $root.distribution.CreateMsg.decode(reader, reader.uint32());
                        break;
                    case 67:
                        message.distributionMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                        break;
                    case 68:
                        message.distributionResetMsg = $root.distribution.ResetMsg.decode(reader, reader.uint32());
                        break;
                    case 77:
                        message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.decode(reader, reader.uint32());
                        break;
                    case 78:
                        message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.decode(reader, reader.uint32());
                        break;
                    case 79:
                        message.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.decode(reader, reader.uint32());
                        break;
                    case 80:
                        message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Union message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {bnsd.ExecuteProposalBatchMsg.Union} Union
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Union.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Union message.
             * @function verify
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Union.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sendMsg != null && message.hasOwnProperty("sendMsg")) {
                    properties.sum = 1;
                    {
                        var error = $root.cash.SendMsg.verify(message.sendMsg);
                        if (error)
                            return "sendMsg." + error;
                    }
                }
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.ReleaseMsg.verify(message.escrowReleaseMsg);
                        if (error)
                            return "escrowReleaseMsg." + error;
                    }
                }
                if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.escrow.UpdatePartiesMsg.verify(message.updateEscrowPartiesMsg);
                        if (error)
                            return "updateEscrowPartiesMsg." + error;
                    }
                }
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.multisig.UpdateMsg.verify(message.multisigUpdateMsg);
                        if (error)
                            return "multisigUpdateMsg." + error;
                    }
                }
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.validators.ApplyDiffMsg.verify(message.validatorsApplyDiffMsg);
                        if (error)
                            return "validatorsApplyDiffMsg." + error;
                    }
                }
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.RegisterTokenMsg.verify(message.usernameRegisterTokenMsg);
                        if (error)
                            return "usernameRegisterTokenMsg." + error;
                    }
                }
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.TransferTokenMsg.verify(message.usernameTransferTokenMsg);
                        if (error)
                            return "usernameTransferTokenMsg." + error;
                    }
                }
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.username.ChangeTokenTargetsMsg.verify(message.usernameChangeTokenTargetsMsg);
                        if (error)
                            return "usernameChangeTokenTargetsMsg." + error;
                    }
                }
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.CreateMsg.verify(message.distributionCreateMsg);
                        if (error)
                            return "distributionCreateMsg." + error;
                    }
                }
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.DistributeMsg.verify(message.distributionMsg);
                        if (error)
                            return "distributionMsg." + error;
                    }
                }
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.distribution.ResetMsg.verify(message.distributionResetMsg);
                        if (error)
                            return "distributionResetMsg." + error;
                    }
                }
                if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.gov.UpdateElectorateMsg.verify(message.govUpdateElectorateMsg);
                        if (error)
                            return "govUpdateElectorateMsg." + error;
                    }
                }
                if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.gov.UpdateElectionRuleMsg.verify(message.govUpdateElectionRuleMsg);
                        if (error)
                            return "govUpdateElectionRuleMsg." + error;
                    }
                }
                if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.gov.CreateTextResolutionMsg.verify(message.govCreateTextResolutionMsg);
                        if (error)
                            return "govCreateTextResolutionMsg." + error;
                    }
                }
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                    if (properties.sum === 1)
                        return "sum: multiple values";
                    properties.sum = 1;
                    {
                        var error = $root.msgfee.SetMsgFeeMsg.verify(message.msgfeeSetMsgFeeMsg);
                        if (error)
                            return "msgfeeSetMsgFeeMsg." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Union message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {bnsd.ExecuteProposalBatchMsg.Union} Union
             */
            Union.fromObject = function fromObject(object) {
                if (object instanceof $root.bnsd.ExecuteProposalBatchMsg.Union)
                    return object;
                var message = new $root.bnsd.ExecuteProposalBatchMsg.Union();
                if (object.sendMsg != null) {
                    if (typeof object.sendMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.sendMsg: object expected");
                    message.sendMsg = $root.cash.SendMsg.fromObject(object.sendMsg);
                }
                if (object.escrowReleaseMsg != null) {
                    if (typeof object.escrowReleaseMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.escrowReleaseMsg: object expected");
                    message.escrowReleaseMsg = $root.escrow.ReleaseMsg.fromObject(object.escrowReleaseMsg);
                }
                if (object.updateEscrowPartiesMsg != null) {
                    if (typeof object.updateEscrowPartiesMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.updateEscrowPartiesMsg: object expected");
                    message.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.fromObject(object.updateEscrowPartiesMsg);
                }
                if (object.multisigUpdateMsg != null) {
                    if (typeof object.multisigUpdateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.multisigUpdateMsg: object expected");
                    message.multisigUpdateMsg = $root.multisig.UpdateMsg.fromObject(object.multisigUpdateMsg);
                }
                if (object.validatorsApplyDiffMsg != null) {
                    if (typeof object.validatorsApplyDiffMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.validatorsApplyDiffMsg: object expected");
                    message.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.fromObject(object.validatorsApplyDiffMsg);
                }
                if (object.usernameRegisterTokenMsg != null) {
                    if (typeof object.usernameRegisterTokenMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.usernameRegisterTokenMsg: object expected");
                    message.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.fromObject(object.usernameRegisterTokenMsg);
                }
                if (object.usernameTransferTokenMsg != null) {
                    if (typeof object.usernameTransferTokenMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.usernameTransferTokenMsg: object expected");
                    message.usernameTransferTokenMsg = $root.username.TransferTokenMsg.fromObject(object.usernameTransferTokenMsg);
                }
                if (object.usernameChangeTokenTargetsMsg != null) {
                    if (typeof object.usernameChangeTokenTargetsMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.usernameChangeTokenTargetsMsg: object expected");
                    message.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.fromObject(object.usernameChangeTokenTargetsMsg);
                }
                if (object.distributionCreateMsg != null) {
                    if (typeof object.distributionCreateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.distributionCreateMsg: object expected");
                    message.distributionCreateMsg = $root.distribution.CreateMsg.fromObject(object.distributionCreateMsg);
                }
                if (object.distributionMsg != null) {
                    if (typeof object.distributionMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.distributionMsg: object expected");
                    message.distributionMsg = $root.distribution.DistributeMsg.fromObject(object.distributionMsg);
                }
                if (object.distributionResetMsg != null) {
                    if (typeof object.distributionResetMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.distributionResetMsg: object expected");
                    message.distributionResetMsg = $root.distribution.ResetMsg.fromObject(object.distributionResetMsg);
                }
                if (object.govUpdateElectorateMsg != null) {
                    if (typeof object.govUpdateElectorateMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.govUpdateElectorateMsg: object expected");
                    message.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.fromObject(object.govUpdateElectorateMsg);
                }
                if (object.govUpdateElectionRuleMsg != null) {
                    if (typeof object.govUpdateElectionRuleMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.govUpdateElectionRuleMsg: object expected");
                    message.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.fromObject(object.govUpdateElectionRuleMsg);
                }
                if (object.govCreateTextResolutionMsg != null) {
                    if (typeof object.govCreateTextResolutionMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.govCreateTextResolutionMsg: object expected");
                    message.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.fromObject(object.govCreateTextResolutionMsg);
                }
                if (object.msgfeeSetMsgFeeMsg != null) {
                    if (typeof object.msgfeeSetMsgFeeMsg !== "object")
                        throw TypeError(".bnsd.ExecuteProposalBatchMsg.Union.msgfeeSetMsgFeeMsg: object expected");
                    message.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.fromObject(object.msgfeeSetMsgFeeMsg);
                }
                return message;
            };

            /**
             * Creates a plain object from an Union message. Also converts values to other types if specified.
             * @function toObject
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @static
             * @param {bnsd.ExecuteProposalBatchMsg.Union} message Union
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Union.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.sendMsg != null && message.hasOwnProperty("sendMsg")) {
                    object.sendMsg = $root.cash.SendMsg.toObject(message.sendMsg, options);
                    if (options.oneofs)
                        object.sum = "sendMsg";
                }
                if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                    object.escrowReleaseMsg = $root.escrow.ReleaseMsg.toObject(message.escrowReleaseMsg, options);
                    if (options.oneofs)
                        object.sum = "escrowReleaseMsg";
                }
                if (message.updateEscrowPartiesMsg != null && message.hasOwnProperty("updateEscrowPartiesMsg")) {
                    object.updateEscrowPartiesMsg = $root.escrow.UpdatePartiesMsg.toObject(message.updateEscrowPartiesMsg, options);
                    if (options.oneofs)
                        object.sum = "updateEscrowPartiesMsg";
                }
                if (message.multisigUpdateMsg != null && message.hasOwnProperty("multisigUpdateMsg")) {
                    object.multisigUpdateMsg = $root.multisig.UpdateMsg.toObject(message.multisigUpdateMsg, options);
                    if (options.oneofs)
                        object.sum = "multisigUpdateMsg";
                }
                if (message.validatorsApplyDiffMsg != null && message.hasOwnProperty("validatorsApplyDiffMsg")) {
                    object.validatorsApplyDiffMsg = $root.validators.ApplyDiffMsg.toObject(message.validatorsApplyDiffMsg, options);
                    if (options.oneofs)
                        object.sum = "validatorsApplyDiffMsg";
                }
                if (message.usernameRegisterTokenMsg != null && message.hasOwnProperty("usernameRegisterTokenMsg")) {
                    object.usernameRegisterTokenMsg = $root.username.RegisterTokenMsg.toObject(message.usernameRegisterTokenMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameRegisterTokenMsg";
                }
                if (message.usernameTransferTokenMsg != null && message.hasOwnProperty("usernameTransferTokenMsg")) {
                    object.usernameTransferTokenMsg = $root.username.TransferTokenMsg.toObject(message.usernameTransferTokenMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameTransferTokenMsg";
                }
                if (message.usernameChangeTokenTargetsMsg != null && message.hasOwnProperty("usernameChangeTokenTargetsMsg")) {
                    object.usernameChangeTokenTargetsMsg = $root.username.ChangeTokenTargetsMsg.toObject(message.usernameChangeTokenTargetsMsg, options);
                    if (options.oneofs)
                        object.sum = "usernameChangeTokenTargetsMsg";
                }
                if (message.distributionCreateMsg != null && message.hasOwnProperty("distributionCreateMsg")) {
                    object.distributionCreateMsg = $root.distribution.CreateMsg.toObject(message.distributionCreateMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionCreateMsg";
                }
                if (message.distributionMsg != null && message.hasOwnProperty("distributionMsg")) {
                    object.distributionMsg = $root.distribution.DistributeMsg.toObject(message.distributionMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionMsg";
                }
                if (message.distributionResetMsg != null && message.hasOwnProperty("distributionResetMsg")) {
                    object.distributionResetMsg = $root.distribution.ResetMsg.toObject(message.distributionResetMsg, options);
                    if (options.oneofs)
                        object.sum = "distributionResetMsg";
                }
                if (message.govUpdateElectorateMsg != null && message.hasOwnProperty("govUpdateElectorateMsg")) {
                    object.govUpdateElectorateMsg = $root.gov.UpdateElectorateMsg.toObject(message.govUpdateElectorateMsg, options);
                    if (options.oneofs)
                        object.sum = "govUpdateElectorateMsg";
                }
                if (message.govUpdateElectionRuleMsg != null && message.hasOwnProperty("govUpdateElectionRuleMsg")) {
                    object.govUpdateElectionRuleMsg = $root.gov.UpdateElectionRuleMsg.toObject(message.govUpdateElectionRuleMsg, options);
                    if (options.oneofs)
                        object.sum = "govUpdateElectionRuleMsg";
                }
                if (message.govCreateTextResolutionMsg != null && message.hasOwnProperty("govCreateTextResolutionMsg")) {
                    object.govCreateTextResolutionMsg = $root.gov.CreateTextResolutionMsg.toObject(message.govCreateTextResolutionMsg, options);
                    if (options.oneofs)
                        object.sum = "govCreateTextResolutionMsg";
                }
                if (message.msgfeeSetMsgFeeMsg != null && message.hasOwnProperty("msgfeeSetMsgFeeMsg")) {
                    object.msgfeeSetMsgFeeMsg = $root.msgfee.SetMsgFeeMsg.toObject(message.msgfeeSetMsgFeeMsg, options);
                    if (options.oneofs)
                        object.sum = "msgfeeSetMsgFeeMsg";
                }
                return object;
            };

            /**
             * Converts this Union to JSON.
             * @function toJSON
             * @memberof bnsd.ExecuteProposalBatchMsg.Union
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Union.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Union;
        })();

        return ExecuteProposalBatchMsg;
    })();

    bnsd.CronTask = (function() {

        /**
         * Properties of a CronTask.
         * @memberof bnsd
         * @interface ICronTask
         * @property {Array.<Uint8Array>|null} [authenticators] conditions required for execution, that will be inserted into the context.
         * @property {escrow.IReleaseMsg|null} [escrowReleaseMsg] CronTask escrowReleaseMsg
         * @property {escrow.IReturnMsg|null} [escrowReturnMsg] CronTask escrowReturnMsg
         * @property {distribution.IDistributeMsg|null} [distributionDistributeMsg] CronTask distributionDistributeMsg
         * @property {aswap.IReleaseMsg|null} [aswapReleaseMsg] CronTask aswapReleaseMsg
         * @property {gov.ITallyMsg|null} [govTallyMsg] CronTask govTallyMsg
         */

        /**
         * Constructs a new CronTask.
         * @memberof bnsd
         * @classdesc old fields got deprecated. This is done to maintain binary compatibility.
         * @implements ICronTask
         * @constructor
         * @param {bnsd.ICronTask=} [properties] Properties to set
         */
        function CronTask(properties) {
            this.authenticators = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * conditions required for execution, that will be inserted into the context.
         * @member {Array.<Uint8Array>} authenticators
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.authenticators = $util.emptyArray;

        /**
         * CronTask escrowReleaseMsg.
         * @member {escrow.IReleaseMsg|null|undefined} escrowReleaseMsg
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.escrowReleaseMsg = null;

        /**
         * CronTask escrowReturnMsg.
         * @member {escrow.IReturnMsg|null|undefined} escrowReturnMsg
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.escrowReturnMsg = null;

        /**
         * CronTask distributionDistributeMsg.
         * @member {distribution.IDistributeMsg|null|undefined} distributionDistributeMsg
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.distributionDistributeMsg = null;

        /**
         * CronTask aswapReleaseMsg.
         * @member {aswap.IReleaseMsg|null|undefined} aswapReleaseMsg
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.aswapReleaseMsg = null;

        /**
         * CronTask govTallyMsg.
         * @member {gov.ITallyMsg|null|undefined} govTallyMsg
         * @memberof bnsd.CronTask
         * @instance
         */
        CronTask.prototype.govTallyMsg = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Use the same indexes for the messages as the Tx message.
         * @member {"escrowReleaseMsg"|"escrowReturnMsg"|"distributionDistributeMsg"|"aswapReleaseMsg"|"govTallyMsg"|undefined} sum
         * @memberof bnsd.CronTask
         * @instance
         */
        Object.defineProperty(CronTask.prototype, "sum", {
            get: $util.oneOfGetter($oneOfFields = ["escrowReleaseMsg", "escrowReturnMsg", "distributionDistributeMsg", "aswapReleaseMsg", "govTallyMsg"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CronTask instance using the specified properties.
         * @function create
         * @memberof bnsd.CronTask
         * @static
         * @param {bnsd.ICronTask=} [properties] Properties to set
         * @returns {bnsd.CronTask} CronTask instance
         */
        CronTask.create = function create(properties) {
            return new CronTask(properties);
        };

        /**
         * Encodes the specified CronTask message. Does not implicitly {@link bnsd.CronTask.verify|verify} messages.
         * @function encode
         * @memberof bnsd.CronTask
         * @static
         * @param {bnsd.ICronTask} message CronTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CronTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authenticators != null && message.authenticators.length)
                for (var i = 0; i < message.authenticators.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.authenticators[i]);
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg"))
                $root.escrow.ReleaseMsg.encode(message.escrowReleaseMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg"))
                $root.escrow.ReturnMsg.encode(message.escrowReturnMsg, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.distributionDistributeMsg != null && message.hasOwnProperty("distributionDistributeMsg"))
                $root.distribution.DistributeMsg.encode(message.distributionDistributeMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg"))
                $root.aswap.ReleaseMsg.encode(message.aswapReleaseMsg, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
            if (message.govTallyMsg != null && message.hasOwnProperty("govTallyMsg"))
                $root.gov.TallyMsg.encode(message.govTallyMsg, writer.uint32(/* id 76, wireType 2 =*/610).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CronTask message, length delimited. Does not implicitly {@link bnsd.CronTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof bnsd.CronTask
         * @static
         * @param {bnsd.ICronTask} message CronTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CronTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CronTask message from the specified reader or buffer.
         * @function decode
         * @memberof bnsd.CronTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {bnsd.CronTask} CronTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CronTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.bnsd.CronTask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.authenticators && message.authenticators.length))
                        message.authenticators = [];
                    message.authenticators.push(reader.bytes());
                    break;
                case 53:
                    message.escrowReleaseMsg = $root.escrow.ReleaseMsg.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.escrowReturnMsg = $root.escrow.ReturnMsg.decode(reader, reader.uint32());
                    break;
                case 67:
                    message.distributionDistributeMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                    break;
                case 71:
                    message.aswapReleaseMsg = $root.aswap.ReleaseMsg.decode(reader, reader.uint32());
                    break;
                case 76:
                    message.govTallyMsg = $root.gov.TallyMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CronTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof bnsd.CronTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {bnsd.CronTask} CronTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CronTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CronTask message.
         * @function verify
         * @memberof bnsd.CronTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CronTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.authenticators != null && message.hasOwnProperty("authenticators")) {
                if (!Array.isArray(message.authenticators))
                    return "authenticators: array expected";
                for (var i = 0; i < message.authenticators.length; ++i)
                    if (!(message.authenticators[i] && typeof message.authenticators[i].length === "number" || $util.isString(message.authenticators[i])))
                        return "authenticators: buffer[] expected";
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                properties.sum = 1;
                {
                    var error = $root.escrow.ReleaseMsg.verify(message.escrowReleaseMsg);
                    if (error)
                        return "escrowReleaseMsg." + error;
                }
            }
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.ReturnMsg.verify(message.escrowReturnMsg);
                    if (error)
                        return "escrowReturnMsg." + error;
                }
            }
            if (message.distributionDistributeMsg != null && message.hasOwnProperty("distributionDistributeMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.DistributeMsg.verify(message.distributionDistributeMsg);
                    if (error)
                        return "distributionDistributeMsg." + error;
                }
            }
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.ReleaseMsg.verify(message.aswapReleaseMsg);
                    if (error)
                        return "aswapReleaseMsg." + error;
                }
            }
            if (message.govTallyMsg != null && message.hasOwnProperty("govTallyMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.gov.TallyMsg.verify(message.govTallyMsg);
                    if (error)
                        return "govTallyMsg." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CronTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof bnsd.CronTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {bnsd.CronTask} CronTask
         */
        CronTask.fromObject = function fromObject(object) {
            if (object instanceof $root.bnsd.CronTask)
                return object;
            var message = new $root.bnsd.CronTask();
            if (object.authenticators) {
                if (!Array.isArray(object.authenticators))
                    throw TypeError(".bnsd.CronTask.authenticators: array expected");
                message.authenticators = [];
                for (var i = 0; i < object.authenticators.length; ++i)
                    if (typeof object.authenticators[i] === "string")
                        $util.base64.decode(object.authenticators[i], message.authenticators[i] = $util.newBuffer($util.base64.length(object.authenticators[i])), 0);
                    else if (object.authenticators[i].length)
                        message.authenticators[i] = object.authenticators[i];
            }
            if (object.escrowReleaseMsg != null) {
                if (typeof object.escrowReleaseMsg !== "object")
                    throw TypeError(".bnsd.CronTask.escrowReleaseMsg: object expected");
                message.escrowReleaseMsg = $root.escrow.ReleaseMsg.fromObject(object.escrowReleaseMsg);
            }
            if (object.escrowReturnMsg != null) {
                if (typeof object.escrowReturnMsg !== "object")
                    throw TypeError(".bnsd.CronTask.escrowReturnMsg: object expected");
                message.escrowReturnMsg = $root.escrow.ReturnMsg.fromObject(object.escrowReturnMsg);
            }
            if (object.distributionDistributeMsg != null) {
                if (typeof object.distributionDistributeMsg !== "object")
                    throw TypeError(".bnsd.CronTask.distributionDistributeMsg: object expected");
                message.distributionDistributeMsg = $root.distribution.DistributeMsg.fromObject(object.distributionDistributeMsg);
            }
            if (object.aswapReleaseMsg != null) {
                if (typeof object.aswapReleaseMsg !== "object")
                    throw TypeError(".bnsd.CronTask.aswapReleaseMsg: object expected");
                message.aswapReleaseMsg = $root.aswap.ReleaseMsg.fromObject(object.aswapReleaseMsg);
            }
            if (object.govTallyMsg != null) {
                if (typeof object.govTallyMsg !== "object")
                    throw TypeError(".bnsd.CronTask.govTallyMsg: object expected");
                message.govTallyMsg = $root.gov.TallyMsg.fromObject(object.govTallyMsg);
            }
            return message;
        };

        /**
         * Creates a plain object from a CronTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof bnsd.CronTask
         * @static
         * @param {bnsd.CronTask} message CronTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CronTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.authenticators = [];
            if (message.authenticators && message.authenticators.length) {
                object.authenticators = [];
                for (var j = 0; j < message.authenticators.length; ++j)
                    object.authenticators[j] = options.bytes === String ? $util.base64.encode(message.authenticators[j], 0, message.authenticators[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.authenticators[j]) : message.authenticators[j];
            }
            if (message.escrowReleaseMsg != null && message.hasOwnProperty("escrowReleaseMsg")) {
                object.escrowReleaseMsg = $root.escrow.ReleaseMsg.toObject(message.escrowReleaseMsg, options);
                if (options.oneofs)
                    object.sum = "escrowReleaseMsg";
            }
            if (message.escrowReturnMsg != null && message.hasOwnProperty("escrowReturnMsg")) {
                object.escrowReturnMsg = $root.escrow.ReturnMsg.toObject(message.escrowReturnMsg, options);
                if (options.oneofs)
                    object.sum = "escrowReturnMsg";
            }
            if (message.distributionDistributeMsg != null && message.hasOwnProperty("distributionDistributeMsg")) {
                object.distributionDistributeMsg = $root.distribution.DistributeMsg.toObject(message.distributionDistributeMsg, options);
                if (options.oneofs)
                    object.sum = "distributionDistributeMsg";
            }
            if (message.aswapReleaseMsg != null && message.hasOwnProperty("aswapReleaseMsg")) {
                object.aswapReleaseMsg = $root.aswap.ReleaseMsg.toObject(message.aswapReleaseMsg, options);
                if (options.oneofs)
                    object.sum = "aswapReleaseMsg";
            }
            if (message.govTallyMsg != null && message.hasOwnProperty("govTallyMsg")) {
                object.govTallyMsg = $root.gov.TallyMsg.toObject(message.govTallyMsg, options);
                if (options.oneofs)
                    object.sum = "govTallyMsg";
            }
            return object;
        };

        /**
         * Converts this CronTask to JSON.
         * @function toJSON
         * @memberof bnsd.CronTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CronTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CronTask;
    })();

    return bnsd;
})();

$root.username = (function() {

    /**
     * Namespace username.
     * @exports username
     * @namespace
     */
    var username = {};

    username.Token = (function() {

        /**
         * Properties of a Token.
         * @memberof username
         * @interface IToken
         * @property {weave.IMetadata|null} [metadata] Token metadata
         * @property {Array.<username.IBlockchainAddress>|null} [targets] least one blockchain address elemenet.
         * @property {Uint8Array|null} [owner] modify a username token.
         */

        /**
         * Constructs a new Token.
         * @memberof username
         * @classdesc ourselves to certain patterns.
         * @implements IToken
         * @constructor
         * @param {username.IToken=} [properties] Properties to set
         */
        function Token(properties) {
            this.targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Token metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.Token
         * @instance
         */
        Token.prototype.metadata = null;

        /**
         * least one blockchain address elemenet.
         * @member {Array.<username.IBlockchainAddress>} targets
         * @memberof username.Token
         * @instance
         */
        Token.prototype.targets = $util.emptyArray;

        /**
         * modify a username token.
         * @member {Uint8Array} owner
         * @memberof username.Token
         * @instance
         */
        Token.prototype.owner = $util.newBuffer([]);

        /**
         * Creates a new Token instance using the specified properties.
         * @function create
         * @memberof username.Token
         * @static
         * @param {username.IToken=} [properties] Properties to set
         * @returns {username.Token} Token instance
         */
        Token.create = function create(properties) {
            return new Token(properties);
        };

        /**
         * Encodes the specified Token message. Does not implicitly {@link username.Token.verify|verify} messages.
         * @function encode
         * @memberof username.Token
         * @static
         * @param {username.IToken} message Token message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Token.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.targets != null && message.targets.length)
                for (var i = 0; i < message.targets.length; ++i)
                    $root.username.BlockchainAddress.encode(message.targets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.owner);
            return writer;
        };

        /**
         * Encodes the specified Token message, length delimited. Does not implicitly {@link username.Token.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.Token
         * @static
         * @param {username.IToken} message Token message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Token.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Token message from the specified reader or buffer.
         * @function decode
         * @memberof username.Token
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.Token} Token
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Token.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.Token();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.targets && message.targets.length))
                        message.targets = [];
                    message.targets.push($root.username.BlockchainAddress.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.owner = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Token message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.Token
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.Token} Token
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Token.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Token message.
         * @function verify
         * @memberof username.Token
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Token.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (var i = 0; i < message.targets.length; ++i) {
                    var error = $root.username.BlockchainAddress.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            return null;
        };

        /**
         * Creates a Token message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.Token
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.Token} Token
         */
        Token.fromObject = function fromObject(object) {
            if (object instanceof $root.username.Token)
                return object;
            var message = new $root.username.Token();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.Token.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".username.Token.targets: array expected");
                message.targets = [];
                for (var i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".username.Token.targets: object expected");
                    message.targets[i] = $root.username.BlockchainAddress.fromObject(object.targets[i]);
                }
            }
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            return message;
        };

        /**
         * Creates a plain object from a Token message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.Token
         * @static
         * @param {username.Token} message Token
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Token.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.targets = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (var j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.username.BlockchainAddress.toObject(message.targets[j], options);
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            return object;
        };

        /**
         * Converts this Token to JSON.
         * @function toJSON
         * @memberof username.Token
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Token.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Token;
    })();

    username.BlockchainAddress = (function() {

        /**
         * Properties of a BlockchainAddress.
         * @memberof username
         * @interface IBlockchainAddress
         * @property {string|null} [blockchainId] An arbitrary blockchain ID.
         * @property {string|null} [address] to use.
         */

        /**
         * Constructs a new BlockchainAddress.
         * @memberof username
         * @classdesc to an address on any blockchain network.
         * @implements IBlockchainAddress
         * @constructor
         * @param {username.IBlockchainAddress=} [properties] Properties to set
         */
        function BlockchainAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An arbitrary blockchain ID.
         * @member {string} blockchainId
         * @memberof username.BlockchainAddress
         * @instance
         */
        BlockchainAddress.prototype.blockchainId = "";

        /**
         * to use.
         * @member {string} address
         * @memberof username.BlockchainAddress
         * @instance
         */
        BlockchainAddress.prototype.address = "";

        /**
         * Creates a new BlockchainAddress instance using the specified properties.
         * @function create
         * @memberof username.BlockchainAddress
         * @static
         * @param {username.IBlockchainAddress=} [properties] Properties to set
         * @returns {username.BlockchainAddress} BlockchainAddress instance
         */
        BlockchainAddress.create = function create(properties) {
            return new BlockchainAddress(properties);
        };

        /**
         * Encodes the specified BlockchainAddress message. Does not implicitly {@link username.BlockchainAddress.verify|verify} messages.
         * @function encode
         * @memberof username.BlockchainAddress
         * @static
         * @param {username.IBlockchainAddress} message BlockchainAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockchainAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockchainId);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified BlockchainAddress message, length delimited. Does not implicitly {@link username.BlockchainAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.BlockchainAddress
         * @static
         * @param {username.IBlockchainAddress} message BlockchainAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockchainAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockchainAddress message from the specified reader or buffer.
         * @function decode
         * @memberof username.BlockchainAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.BlockchainAddress} BlockchainAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockchainAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.BlockchainAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockchainId = reader.string();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockchainAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.BlockchainAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.BlockchainAddress} BlockchainAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockchainAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockchainAddress message.
         * @function verify
         * @memberof username.BlockchainAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockchainAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                if (!$util.isString(message.blockchainId))
                    return "blockchainId: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a BlockchainAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.BlockchainAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.BlockchainAddress} BlockchainAddress
         */
        BlockchainAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.username.BlockchainAddress)
                return object;
            var message = new $root.username.BlockchainAddress();
            if (object.blockchainId != null)
                message.blockchainId = String(object.blockchainId);
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a BlockchainAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.BlockchainAddress
         * @static
         * @param {username.BlockchainAddress} message BlockchainAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockchainAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.blockchainId = "";
                object.address = "";
            }
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                object.blockchainId = message.blockchainId;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this BlockchainAddress to JSON.
         * @function toJSON
         * @memberof username.BlockchainAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockchainAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BlockchainAddress;
    })();

    username.RegisterTokenMsg = (function() {

        /**
         * Properties of a RegisterTokenMsg.
         * @memberof username
         * @interface IRegisterTokenMsg
         * @property {weave.IMetadata|null} [metadata] RegisterTokenMsg metadata
         * @property {string|null} [username] Username is the unique name of the token, for example alice*iov
         * @property {Array.<username.IBlockchainAddress>|null} [targets] Targets is a blockchain address list that this token should point to.
         */

        /**
         * Constructs a new RegisterTokenMsg.
         * @memberof username
         * @classdesc to the main signer.
         * @implements IRegisterTokenMsg
         * @constructor
         * @param {username.IRegisterTokenMsg=} [properties] Properties to set
         */
        function RegisterTokenMsg(properties) {
            this.targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterTokenMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.RegisterTokenMsg
         * @instance
         */
        RegisterTokenMsg.prototype.metadata = null;

        /**
         * Username is the unique name of the token, for example alice*iov
         * @member {string} username
         * @memberof username.RegisterTokenMsg
         * @instance
         */
        RegisterTokenMsg.prototype.username = "";

        /**
         * Targets is a blockchain address list that this token should point to.
         * @member {Array.<username.IBlockchainAddress>} targets
         * @memberof username.RegisterTokenMsg
         * @instance
         */
        RegisterTokenMsg.prototype.targets = $util.emptyArray;

        /**
         * Creates a new RegisterTokenMsg instance using the specified properties.
         * @function create
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {username.IRegisterTokenMsg=} [properties] Properties to set
         * @returns {username.RegisterTokenMsg} RegisterTokenMsg instance
         */
        RegisterTokenMsg.create = function create(properties) {
            return new RegisterTokenMsg(properties);
        };

        /**
         * Encodes the specified RegisterTokenMsg message. Does not implicitly {@link username.RegisterTokenMsg.verify|verify} messages.
         * @function encode
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {username.IRegisterTokenMsg} message RegisterTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterTokenMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.targets != null && message.targets.length)
                for (var i = 0; i < message.targets.length; ++i)
                    $root.username.BlockchainAddress.encode(message.targets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RegisterTokenMsg message, length delimited. Does not implicitly {@link username.RegisterTokenMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {username.IRegisterTokenMsg} message RegisterTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterTokenMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterTokenMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.RegisterTokenMsg} RegisterTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterTokenMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.RegisterTokenMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    if (!(message.targets && message.targets.length))
                        message.targets = [];
                    message.targets.push($root.username.BlockchainAddress.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterTokenMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.RegisterTokenMsg} RegisterTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterTokenMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterTokenMsg message.
         * @function verify
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterTokenMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (var i = 0; i < message.targets.length; ++i) {
                    var error = $root.username.BlockchainAddress.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RegisterTokenMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.RegisterTokenMsg} RegisterTokenMsg
         */
        RegisterTokenMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.RegisterTokenMsg)
                return object;
            var message = new $root.username.RegisterTokenMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.RegisterTokenMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.username != null)
                message.username = String(object.username);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".username.RegisterTokenMsg.targets: array expected");
                message.targets = [];
                for (var i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".username.RegisterTokenMsg.targets: object expected");
                    message.targets[i] = $root.username.BlockchainAddress.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RegisterTokenMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.RegisterTokenMsg
         * @static
         * @param {username.RegisterTokenMsg} message RegisterTokenMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterTokenMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.targets = [];
            if (options.defaults) {
                object.metadata = null;
                object.username = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (var j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.username.BlockchainAddress.toObject(message.targets[j], options);
            }
            return object;
        };

        /**
         * Converts this RegisterTokenMsg to JSON.
         * @function toJSON
         * @memberof username.RegisterTokenMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterTokenMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterTokenMsg;
    })();

    username.TransferTokenMsg = (function() {

        /**
         * Properties of a TransferTokenMsg.
         * @memberof username
         * @interface ITransferTokenMsg
         * @property {weave.IMetadata|null} [metadata] TransferTokenMsg metadata
         * @property {string|null} [username] Username is the unique name of the token, for example alice*iov
         * @property {Uint8Array|null} [newOwner] Owner is a weave address that will owns this token after the change.
         */

        /**
         * Constructs a new TransferTokenMsg.
         * @memberof username
         * @classdesc owner is not required in order to succeed.
         * @implements ITransferTokenMsg
         * @constructor
         * @param {username.ITransferTokenMsg=} [properties] Properties to set
         */
        function TransferTokenMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferTokenMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.TransferTokenMsg
         * @instance
         */
        TransferTokenMsg.prototype.metadata = null;

        /**
         * Username is the unique name of the token, for example alice*iov
         * @member {string} username
         * @memberof username.TransferTokenMsg
         * @instance
         */
        TransferTokenMsg.prototype.username = "";

        /**
         * Owner is a weave address that will owns this token after the change.
         * @member {Uint8Array} newOwner
         * @memberof username.TransferTokenMsg
         * @instance
         */
        TransferTokenMsg.prototype.newOwner = $util.newBuffer([]);

        /**
         * Creates a new TransferTokenMsg instance using the specified properties.
         * @function create
         * @memberof username.TransferTokenMsg
         * @static
         * @param {username.ITransferTokenMsg=} [properties] Properties to set
         * @returns {username.TransferTokenMsg} TransferTokenMsg instance
         */
        TransferTokenMsg.create = function create(properties) {
            return new TransferTokenMsg(properties);
        };

        /**
         * Encodes the specified TransferTokenMsg message. Does not implicitly {@link username.TransferTokenMsg.verify|verify} messages.
         * @function encode
         * @memberof username.TransferTokenMsg
         * @static
         * @param {username.ITransferTokenMsg} message TransferTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferTokenMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.newOwner != null && message.hasOwnProperty("newOwner"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.newOwner);
            return writer;
        };

        /**
         * Encodes the specified TransferTokenMsg message, length delimited. Does not implicitly {@link username.TransferTokenMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.TransferTokenMsg
         * @static
         * @param {username.ITransferTokenMsg} message TransferTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferTokenMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferTokenMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.TransferTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.TransferTokenMsg} TransferTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferTokenMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.TransferTokenMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.newOwner = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferTokenMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.TransferTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.TransferTokenMsg} TransferTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferTokenMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferTokenMsg message.
         * @function verify
         * @memberof username.TransferTokenMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferTokenMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.newOwner != null && message.hasOwnProperty("newOwner"))
                if (!(message.newOwner && typeof message.newOwner.length === "number" || $util.isString(message.newOwner)))
                    return "newOwner: buffer expected";
            return null;
        };

        /**
         * Creates a TransferTokenMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.TransferTokenMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.TransferTokenMsg} TransferTokenMsg
         */
        TransferTokenMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.TransferTokenMsg)
                return object;
            var message = new $root.username.TransferTokenMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.TransferTokenMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.username != null)
                message.username = String(object.username);
            if (object.newOwner != null)
                if (typeof object.newOwner === "string")
                    $util.base64.decode(object.newOwner, message.newOwner = $util.newBuffer($util.base64.length(object.newOwner)), 0);
                else if (object.newOwner.length)
                    message.newOwner = object.newOwner;
            return message;
        };

        /**
         * Creates a plain object from a TransferTokenMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.TransferTokenMsg
         * @static
         * @param {username.TransferTokenMsg} message TransferTokenMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferTokenMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.username = "";
                if (options.bytes === String)
                    object.newOwner = "";
                else {
                    object.newOwner = [];
                    if (options.bytes !== Array)
                        object.newOwner = $util.newBuffer(object.newOwner);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.newOwner != null && message.hasOwnProperty("newOwner"))
                object.newOwner = options.bytes === String ? $util.base64.encode(message.newOwner, 0, message.newOwner.length) : options.bytes === Array ? Array.prototype.slice.call(message.newOwner) : message.newOwner;
            return object;
        };

        /**
         * Converts this TransferTokenMsg to JSON.
         * @function toJSON
         * @memberof username.TransferTokenMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferTokenMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferTokenMsg;
    })();

    username.ChangeTokenTargetsMsg = (function() {

        /**
         * Properties of a ChangeTokenTargetsMsg.
         * @memberof username
         * @interface IChangeTokenTargetsMsg
         * @property {weave.IMetadata|null} [metadata] ChangeTokenTargetsMsg metadata
         * @property {string|null} [username] Username is the unique name of the token, for example alice*iov
         * @property {Array.<username.IBlockchainAddress>|null} [newTargets] to after the change. Old list is overwritten with what is provided.
         */

        /**
         * Constructs a new ChangeTokenTargetsMsg.
         * @memberof username
         * @classdesc points to. Only the owner of a token can request this operation.
         * @implements IChangeTokenTargetsMsg
         * @constructor
         * @param {username.IChangeTokenTargetsMsg=} [properties] Properties to set
         */
        function ChangeTokenTargetsMsg(properties) {
            this.newTargets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeTokenTargetsMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.ChangeTokenTargetsMsg
         * @instance
         */
        ChangeTokenTargetsMsg.prototype.metadata = null;

        /**
         * Username is the unique name of the token, for example alice*iov
         * @member {string} username
         * @memberof username.ChangeTokenTargetsMsg
         * @instance
         */
        ChangeTokenTargetsMsg.prototype.username = "";

        /**
         * to after the change. Old list is overwritten with what is provided.
         * @member {Array.<username.IBlockchainAddress>} newTargets
         * @memberof username.ChangeTokenTargetsMsg
         * @instance
         */
        ChangeTokenTargetsMsg.prototype.newTargets = $util.emptyArray;

        /**
         * Creates a new ChangeTokenTargetsMsg instance using the specified properties.
         * @function create
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {username.IChangeTokenTargetsMsg=} [properties] Properties to set
         * @returns {username.ChangeTokenTargetsMsg} ChangeTokenTargetsMsg instance
         */
        ChangeTokenTargetsMsg.create = function create(properties) {
            return new ChangeTokenTargetsMsg(properties);
        };

        /**
         * Encodes the specified ChangeTokenTargetsMsg message. Does not implicitly {@link username.ChangeTokenTargetsMsg.verify|verify} messages.
         * @function encode
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {username.IChangeTokenTargetsMsg} message ChangeTokenTargetsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTokenTargetsMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.newTargets != null && message.newTargets.length)
                for (var i = 0; i < message.newTargets.length; ++i)
                    $root.username.BlockchainAddress.encode(message.newTargets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeTokenTargetsMsg message, length delimited. Does not implicitly {@link username.ChangeTokenTargetsMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {username.IChangeTokenTargetsMsg} message ChangeTokenTargetsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeTokenTargetsMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeTokenTargetsMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.ChangeTokenTargetsMsg} ChangeTokenTargetsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTokenTargetsMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.ChangeTokenTargetsMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    if (!(message.newTargets && message.newTargets.length))
                        message.newTargets = [];
                    message.newTargets.push($root.username.BlockchainAddress.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeTokenTargetsMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.ChangeTokenTargetsMsg} ChangeTokenTargetsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeTokenTargetsMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeTokenTargetsMsg message.
         * @function verify
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeTokenTargetsMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.newTargets != null && message.hasOwnProperty("newTargets")) {
                if (!Array.isArray(message.newTargets))
                    return "newTargets: array expected";
                for (var i = 0; i < message.newTargets.length; ++i) {
                    var error = $root.username.BlockchainAddress.verify(message.newTargets[i]);
                    if (error)
                        return "newTargets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChangeTokenTargetsMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.ChangeTokenTargetsMsg} ChangeTokenTargetsMsg
         */
        ChangeTokenTargetsMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.ChangeTokenTargetsMsg)
                return object;
            var message = new $root.username.ChangeTokenTargetsMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.ChangeTokenTargetsMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.username != null)
                message.username = String(object.username);
            if (object.newTargets) {
                if (!Array.isArray(object.newTargets))
                    throw TypeError(".username.ChangeTokenTargetsMsg.newTargets: array expected");
                message.newTargets = [];
                for (var i = 0; i < object.newTargets.length; ++i) {
                    if (typeof object.newTargets[i] !== "object")
                        throw TypeError(".username.ChangeTokenTargetsMsg.newTargets: object expected");
                    message.newTargets[i] = $root.username.BlockchainAddress.fromObject(object.newTargets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeTokenTargetsMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.ChangeTokenTargetsMsg
         * @static
         * @param {username.ChangeTokenTargetsMsg} message ChangeTokenTargetsMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeTokenTargetsMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.newTargets = [];
            if (options.defaults) {
                object.metadata = null;
                object.username = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.newTargets && message.newTargets.length) {
                object.newTargets = [];
                for (var j = 0; j < message.newTargets.length; ++j)
                    object.newTargets[j] = $root.username.BlockchainAddress.toObject(message.newTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ChangeTokenTargetsMsg to JSON.
         * @function toJSON
         * @memberof username.ChangeTokenTargetsMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeTokenTargetsMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeTokenTargetsMsg;
    })();

    username.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof username
         * @interface IConfiguration
         * @property {weave.IMetadata|null} [metadata] Configuration metadata
         * @property {Uint8Array|null} [owner] needed to make use of gconf.NewUpdateConfigurationHandler
         * @property {string|null} [validUsernameName] part name must match (a username is <name>*<label>)
         * @property {string|null} [validUsernameLabel] namespace label must match (a username is <name>*<label>)
         */

        /**
         * Constructs a new Configuration.
         * @memberof username
         * @classdesc the functionality provided by gconf package.
         * @implements IConfiguration
         * @constructor
         * @param {username.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Configuration metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.Configuration
         * @instance
         */
        Configuration.prototype.metadata = null;

        /**
         * needed to make use of gconf.NewUpdateConfigurationHandler
         * @member {Uint8Array} owner
         * @memberof username.Configuration
         * @instance
         */
        Configuration.prototype.owner = $util.newBuffer([]);

        /**
         * part name must match (a username is <name>*<label>)
         * @member {string} validUsernameName
         * @memberof username.Configuration
         * @instance
         */
        Configuration.prototype.validUsernameName = "";

        /**
         * namespace label must match (a username is <name>*<label>)
         * @member {string} validUsernameLabel
         * @memberof username.Configuration
         * @instance
         */
        Configuration.prototype.validUsernameLabel = "";

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof username.Configuration
         * @static
         * @param {username.IConfiguration=} [properties] Properties to set
         * @returns {username.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link username.Configuration.verify|verify} messages.
         * @function encode
         * @memberof username.Configuration
         * @static
         * @param {username.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
            if (message.validUsernameName != null && message.hasOwnProperty("validUsernameName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.validUsernameName);
            if (message.validUsernameLabel != null && message.hasOwnProperty("validUsernameLabel"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.validUsernameLabel);
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link username.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.Configuration
         * @static
         * @param {username.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof username.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = reader.bytes();
                    break;
                case 3:
                    message.validUsernameName = reader.string();
                    break;
                case 4:
                    message.validUsernameLabel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof username.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.validUsernameName != null && message.hasOwnProperty("validUsernameName"))
                if (!$util.isString(message.validUsernameName))
                    return "validUsernameName: string expected";
            if (message.validUsernameLabel != null && message.hasOwnProperty("validUsernameLabel"))
                if (!$util.isString(message.validUsernameLabel))
                    return "validUsernameLabel: string expected";
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.username.Configuration)
                return object;
            var message = new $root.username.Configuration();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.Configuration.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.validUsernameName != null)
                message.validUsernameName = String(object.validUsernameName);
            if (object.validUsernameLabel != null)
                message.validUsernameLabel = String(object.validUsernameLabel);
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.Configuration
         * @static
         * @param {username.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                object.validUsernameName = "";
                object.validUsernameLabel = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.validUsernameName != null && message.hasOwnProperty("validUsernameName"))
                object.validUsernameName = message.validUsernameName;
            if (message.validUsernameLabel != null && message.hasOwnProperty("validUsernameLabel"))
                object.validUsernameLabel = message.validUsernameLabel;
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof username.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    username.UpdateConfigurationMsg = (function() {

        /**
         * Properties of an UpdateConfigurationMsg.
         * @memberof username
         * @interface IUpdateConfigurationMsg
         * @property {weave.IMetadata|null} [metadata] UpdateConfigurationMsg metadata
         * @property {username.IConfiguration|null} [patch] UpdateConfigurationMsg patch
         */

        /**
         * Constructs a new UpdateConfigurationMsg.
         * @memberof username
         * @classdesc configuration.
         * @implements IUpdateConfigurationMsg
         * @constructor
         * @param {username.IUpdateConfigurationMsg=} [properties] Properties to set
         */
        function UpdateConfigurationMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConfigurationMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof username.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.metadata = null;

        /**
         * UpdateConfigurationMsg patch.
         * @member {username.IConfiguration|null|undefined} patch
         * @memberof username.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.patch = null;

        /**
         * Creates a new UpdateConfigurationMsg instance using the specified properties.
         * @function create
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {username.IUpdateConfigurationMsg=} [properties] Properties to set
         * @returns {username.UpdateConfigurationMsg} UpdateConfigurationMsg instance
         */
        UpdateConfigurationMsg.create = function create(properties) {
            return new UpdateConfigurationMsg(properties);
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message. Does not implicitly {@link username.UpdateConfigurationMsg.verify|verify} messages.
         * @function encode
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {username.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.patch != null && message.hasOwnProperty("patch"))
                $root.username.Configuration.encode(message.patch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message, length delimited. Does not implicitly {@link username.UpdateConfigurationMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {username.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.UpdateConfigurationMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.patch = $root.username.Configuration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConfigurationMsg message.
         * @function verify
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConfigurationMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.patch != null && message.hasOwnProperty("patch")) {
                var error = $root.username.Configuration.verify(message.patch);
                if (error)
                    return "patch." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConfigurationMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.UpdateConfigurationMsg} UpdateConfigurationMsg
         */
        UpdateConfigurationMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.UpdateConfigurationMsg)
                return object;
            var message = new $root.username.UpdateConfigurationMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".username.UpdateConfigurationMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.patch != null) {
                if (typeof object.patch !== "object")
                    throw TypeError(".username.UpdateConfigurationMsg.patch: object expected");
                message.patch = $root.username.Configuration.fromObject(object.patch);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConfigurationMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.UpdateConfigurationMsg
         * @static
         * @param {username.UpdateConfigurationMsg} message UpdateConfigurationMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConfigurationMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.patch = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = $root.username.Configuration.toObject(message.patch, options);
            return object;
        };

        /**
         * Converts this UpdateConfigurationMsg to JSON.
         * @function toJSON
         * @memberof username.UpdateConfigurationMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConfigurationMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConfigurationMsg;
    })();

    return username;
})();

$root.weave = (function() {

    /**
     * Namespace weave.
     * @exports weave
     * @namespace
     */
    var weave = {};

    weave.Metadata = (function() {

        /**
         * Properties of a Metadata.
         * @memberof weave
         * @interface IMetadata
         * @property {number|null} [schema] Metadata schema
         */

        /**
         * Constructs a new Metadata.
         * @memberof weave
         * @classdesc weave.Metadata metadata = 1;
         * @implements IMetadata
         * @constructor
         * @param {weave.IMetadata=} [properties] Properties to set
         */
        function Metadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metadata schema.
         * @member {number} schema
         * @memberof weave.Metadata
         * @instance
         */
        Metadata.prototype.schema = 0;

        /**
         * Creates a new Metadata instance using the specified properties.
         * @function create
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata=} [properties] Properties to set
         * @returns {weave.Metadata} Metadata instance
         */
        Metadata.create = function create(properties) {
            return new Metadata(properties);
        };

        /**
         * Encodes the specified Metadata message. Does not implicitly {@link weave.Metadata.verify|verify} messages.
         * @function encode
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.schema);
            return writer;
        };

        /**
         * Encodes the specified Metadata message, length delimited. Does not implicitly {@link weave.Metadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer.
         * @function decode
         * @memberof weave.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {weave.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.weave.Metadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.schema = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof weave.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {weave.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metadata message.
         * @function verify
         * @memberof weave.Metadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isInteger(message.schema))
                    return "schema: integer expected";
            return null;
        };

        /**
         * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof weave.Metadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {weave.Metadata} Metadata
         */
        Metadata.fromObject = function fromObject(object) {
            if (object instanceof $root.weave.Metadata)
                return object;
            var message = new $root.weave.Metadata();
            if (object.schema != null)
                message.schema = object.schema >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Metadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof weave.Metadata
         * @static
         * @param {weave.Metadata} message Metadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.schema = 0;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            return object;
        };

        /**
         * Converts this Metadata to JSON.
         * @function toJSON
         * @memberof weave.Metadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Metadata;
    })();

    weave.ValidatorUpdates = (function() {

        /**
         * Properties of a ValidatorUpdates.
         * @memberof weave
         * @interface IValidatorUpdates
         * @property {Array.<weave.IValidatorUpdate>|null} [validatorUpdates] ValidatorUpdates validatorUpdates
         */

        /**
         * Constructs a new ValidatorUpdates.
         * @memberof weave
         * @classdesc ValidatorUpdates represents latest validator state, currently used to validate SetValidatorMsg transactions.
         * @implements IValidatorUpdates
         * @constructor
         * @param {weave.IValidatorUpdates=} [properties] Properties to set
         */
        function ValidatorUpdates(properties) {
            this.validatorUpdates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorUpdates validatorUpdates.
         * @member {Array.<weave.IValidatorUpdate>} validatorUpdates
         * @memberof weave.ValidatorUpdates
         * @instance
         */
        ValidatorUpdates.prototype.validatorUpdates = $util.emptyArray;

        /**
         * Creates a new ValidatorUpdates instance using the specified properties.
         * @function create
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {weave.IValidatorUpdates=} [properties] Properties to set
         * @returns {weave.ValidatorUpdates} ValidatorUpdates instance
         */
        ValidatorUpdates.create = function create(properties) {
            return new ValidatorUpdates(properties);
        };

        /**
         * Encodes the specified ValidatorUpdates message. Does not implicitly {@link weave.ValidatorUpdates.verify|verify} messages.
         * @function encode
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {weave.IValidatorUpdates} message ValidatorUpdates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdates.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validatorUpdates != null && message.validatorUpdates.length)
                for (var i = 0; i < message.validatorUpdates.length; ++i)
                    $root.weave.ValidatorUpdate.encode(message.validatorUpdates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ValidatorUpdates message, length delimited. Does not implicitly {@link weave.ValidatorUpdates.verify|verify} messages.
         * @function encodeDelimited
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {weave.IValidatorUpdates} message ValidatorUpdates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdates.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorUpdates message from the specified reader or buffer.
         * @function decode
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {weave.ValidatorUpdates} ValidatorUpdates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdates.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.weave.ValidatorUpdates();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.validatorUpdates && message.validatorUpdates.length))
                        message.validatorUpdates = [];
                    message.validatorUpdates.push($root.weave.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidatorUpdates message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {weave.ValidatorUpdates} ValidatorUpdates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdates.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorUpdates message.
         * @function verify
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorUpdates.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validatorUpdates != null && message.hasOwnProperty("validatorUpdates")) {
                if (!Array.isArray(message.validatorUpdates))
                    return "validatorUpdates: array expected";
                for (var i = 0; i < message.validatorUpdates.length; ++i) {
                    var error = $root.weave.ValidatorUpdate.verify(message.validatorUpdates[i]);
                    if (error)
                        return "validatorUpdates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ValidatorUpdates message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {weave.ValidatorUpdates} ValidatorUpdates
         */
        ValidatorUpdates.fromObject = function fromObject(object) {
            if (object instanceof $root.weave.ValidatorUpdates)
                return object;
            var message = new $root.weave.ValidatorUpdates();
            if (object.validatorUpdates) {
                if (!Array.isArray(object.validatorUpdates))
                    throw TypeError(".weave.ValidatorUpdates.validatorUpdates: array expected");
                message.validatorUpdates = [];
                for (var i = 0; i < object.validatorUpdates.length; ++i) {
                    if (typeof object.validatorUpdates[i] !== "object")
                        throw TypeError(".weave.ValidatorUpdates.validatorUpdates: object expected");
                    message.validatorUpdates[i] = $root.weave.ValidatorUpdate.fromObject(object.validatorUpdates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ValidatorUpdates message. Also converts values to other types if specified.
         * @function toObject
         * @memberof weave.ValidatorUpdates
         * @static
         * @param {weave.ValidatorUpdates} message ValidatorUpdates
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorUpdates.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.validatorUpdates = [];
            if (message.validatorUpdates && message.validatorUpdates.length) {
                object.validatorUpdates = [];
                for (var j = 0; j < message.validatorUpdates.length; ++j)
                    object.validatorUpdates[j] = $root.weave.ValidatorUpdate.toObject(message.validatorUpdates[j], options);
            }
            return object;
        };

        /**
         * Converts this ValidatorUpdates to JSON.
         * @function toJSON
         * @memberof weave.ValidatorUpdates
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorUpdates.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorUpdates;
    })();

    weave.ValidatorUpdate = (function() {

        /**
         * Properties of a ValidatorUpdate.
         * @memberof weave
         * @interface IValidatorUpdate
         * @property {weave.IPubKey|null} [pubKey] ValidatorUpdate pubKey
         * @property {number|Long|null} [power] ValidatorUpdate power
         */

        /**
         * Constructs a new ValidatorUpdate.
         * @memberof weave
         * @classdesc ValidatorUpdate represents an update to validator set.
         * @implements IValidatorUpdate
         * @constructor
         * @param {weave.IValidatorUpdate=} [properties] Properties to set
         */
        function ValidatorUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorUpdate pubKey.
         * @member {weave.IPubKey|null|undefined} pubKey
         * @memberof weave.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.pubKey = null;

        /**
         * ValidatorUpdate power.
         * @member {number|Long} power
         * @memberof weave.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ValidatorUpdate instance using the specified properties.
         * @function create
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {weave.IValidatorUpdate=} [properties] Properties to set
         * @returns {weave.ValidatorUpdate} ValidatorUpdate instance
         */
        ValidatorUpdate.create = function create(properties) {
            return new ValidatorUpdate(properties);
        };

        /**
         * Encodes the specified ValidatorUpdate message. Does not implicitly {@link weave.ValidatorUpdate.verify|verify} messages.
         * @function encode
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {weave.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                $root.weave.PubKey.encode(message.pubKey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.power != null && message.hasOwnProperty("power"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.power);
            return writer;
        };

        /**
         * Encodes the specified ValidatorUpdate message, length delimited. Does not implicitly {@link weave.ValidatorUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {weave.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {weave.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.weave.ValidatorUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = $root.weave.PubKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.power = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {weave.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorUpdate message.
         * @function verify
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey")) {
                var error = $root.weave.PubKey.verify(message.pubKey);
                if (error)
                    return "pubKey." + error;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            return null;
        };

        /**
         * Creates a ValidatorUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {weave.ValidatorUpdate} ValidatorUpdate
         */
        ValidatorUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.weave.ValidatorUpdate)
                return object;
            var message = new $root.weave.ValidatorUpdate();
            if (object.pubKey != null) {
                if (typeof object.pubKey !== "object")
                    throw TypeError(".weave.ValidatorUpdate.pubKey: object expected");
                message.pubKey = $root.weave.PubKey.fromObject(object.pubKey);
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ValidatorUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof weave.ValidatorUpdate
         * @static
         * @param {weave.ValidatorUpdate} message ValidatorUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pubKey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = $root.weave.PubKey.toObject(message.pubKey, options);
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            return object;
        };

        /**
         * Converts this ValidatorUpdate to JSON.
         * @function toJSON
         * @memberof weave.ValidatorUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorUpdate;
    })();

    weave.PubKey = (function() {

        /**
         * Properties of a PubKey.
         * @memberof weave
         * @interface IPubKey
         * @property {string|null} [type] PubKey type
         * @property {Uint8Array|null} [data] PubKey data
         */

        /**
         * Constructs a new PubKey.
         * @memberof weave
         * @classdesc PubKey represents a validator public key.
         * @implements IPubKey
         * @constructor
         * @param {weave.IPubKey=} [properties] Properties to set
         */
        function PubKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PubKey type.
         * @member {string} type
         * @memberof weave.PubKey
         * @instance
         */
        PubKey.prototype.type = "";

        /**
         * PubKey data.
         * @member {Uint8Array} data
         * @memberof weave.PubKey
         * @instance
         */
        PubKey.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new PubKey instance using the specified properties.
         * @function create
         * @memberof weave.PubKey
         * @static
         * @param {weave.IPubKey=} [properties] Properties to set
         * @returns {weave.PubKey} PubKey instance
         */
        PubKey.create = function create(properties) {
            return new PubKey(properties);
        };

        /**
         * Encodes the specified PubKey message. Does not implicitly {@link weave.PubKey.verify|verify} messages.
         * @function encode
         * @memberof weave.PubKey
         * @static
         * @param {weave.IPubKey} message PubKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified PubKey message, length delimited. Does not implicitly {@link weave.PubKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof weave.PubKey
         * @static
         * @param {weave.IPubKey} message PubKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PubKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PubKey message from the specified reader or buffer.
         * @function decode
         * @memberof weave.PubKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {weave.PubKey} PubKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.weave.PubKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PubKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof weave.PubKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {weave.PubKey} PubKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PubKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PubKey message.
         * @function verify
         * @memberof weave.PubKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PubKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a PubKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof weave.PubKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {weave.PubKey} PubKey
         */
        PubKey.fromObject = function fromObject(object) {
            if (object instanceof $root.weave.PubKey)
                return object;
            var message = new $root.weave.PubKey();
            if (object.type != null)
                message.type = String(object.type);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a PubKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof weave.PubKey
         * @static
         * @param {weave.PubKey} message PubKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PubKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this PubKey to JSON.
         * @function toJSON
         * @memberof weave.PubKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PubKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PubKey;
    })();

    return weave;
})();

$root.coin = (function() {

    /**
     * Namespace coin.
     * @exports coin
     * @namespace
     */
    var coin = {};

    coin.Coin = (function() {

        /**
         * Properties of a Coin.
         * @memberof coin
         * @interface ICoin
         * @property {number|Long|null} [whole] Whole coins, -10^15 < integer < 10^15
         * @property {number|Long|null} [fractional] If fractional != 0, must have same sign as integer
         * @property {string|null} [ticker] all Coins of the same currency can be combined
         */

        /**
         * Constructs a new Coin.
         * @memberof coin
         * @classdesc own type, possibly borrowing from this code.
         * @implements ICoin
         * @constructor
         * @param {coin.ICoin=} [properties] Properties to set
         */
        function Coin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whole coins, -10^15 < integer < 10^15
         * @member {number|Long} whole
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.whole = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * If fractional != 0, must have same sign as integer
         * @member {number|Long} fractional
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.fractional = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * all Coins of the same currency can be combined
         * @member {string} ticker
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.ticker = "";

        /**
         * Creates a new Coin instance using the specified properties.
         * @function create
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin=} [properties] Properties to set
         * @returns {coin.Coin} Coin instance
         */
        Coin.create = function create(properties) {
            return new Coin(properties);
        };

        /**
         * Encodes the specified Coin message. Does not implicitly {@link coin.Coin.verify|verify} messages.
         * @function encode
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.whole != null && message.hasOwnProperty("whole"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.whole);
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fractional);
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticker);
            return writer;
        };

        /**
         * Encodes the specified Coin message, length delimited. Does not implicitly {@link coin.Coin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coin message from the specified reader or buffer.
         * @function decode
         * @memberof coin.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {coin.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.coin.Coin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.whole = reader.int64();
                    break;
                case 2:
                    message.fractional = reader.int64();
                    break;
                case 3:
                    message.ticker = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof coin.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {coin.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coin message.
         * @function verify
         * @memberof coin.Coin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.whole != null && message.hasOwnProperty("whole"))
                if (!$util.isInteger(message.whole) && !(message.whole && $util.isInteger(message.whole.low) && $util.isInteger(message.whole.high)))
                    return "whole: integer|Long expected";
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                if (!$util.isInteger(message.fractional) && !(message.fractional && $util.isInteger(message.fractional.low) && $util.isInteger(message.fractional.high)))
                    return "fractional: integer|Long expected";
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            return null;
        };

        /**
         * Creates a Coin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof coin.Coin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {coin.Coin} Coin
         */
        Coin.fromObject = function fromObject(object) {
            if (object instanceof $root.coin.Coin)
                return object;
            var message = new $root.coin.Coin();
            if (object.whole != null)
                if ($util.Long)
                    (message.whole = $util.Long.fromValue(object.whole)).unsigned = false;
                else if (typeof object.whole === "string")
                    message.whole = parseInt(object.whole, 10);
                else if (typeof object.whole === "number")
                    message.whole = object.whole;
                else if (typeof object.whole === "object")
                    message.whole = new $util.LongBits(object.whole.low >>> 0, object.whole.high >>> 0).toNumber();
            if (object.fractional != null)
                if ($util.Long)
                    (message.fractional = $util.Long.fromValue(object.fractional)).unsigned = false;
                else if (typeof object.fractional === "string")
                    message.fractional = parseInt(object.fractional, 10);
                else if (typeof object.fractional === "number")
                    message.fractional = object.fractional;
                else if (typeof object.fractional === "object")
                    message.fractional = new $util.LongBits(object.fractional.low >>> 0, object.fractional.high >>> 0).toNumber();
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            return message;
        };

        /**
         * Creates a plain object from a Coin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof coin.Coin
         * @static
         * @param {coin.Coin} message Coin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.whole = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.whole = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fractional = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fractional = options.longs === String ? "0" : 0;
                object.ticker = "";
            }
            if (message.whole != null && message.hasOwnProperty("whole"))
                if (typeof message.whole === "number")
                    object.whole = options.longs === String ? String(message.whole) : message.whole;
                else
                    object.whole = options.longs === String ? $util.Long.prototype.toString.call(message.whole) : options.longs === Number ? new $util.LongBits(message.whole.low >>> 0, message.whole.high >>> 0).toNumber() : message.whole;
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                if (typeof message.fractional === "number")
                    object.fractional = options.longs === String ? String(message.fractional) : message.fractional;
                else
                    object.fractional = options.longs === String ? $util.Long.prototype.toString.call(message.fractional) : options.longs === Number ? new $util.LongBits(message.fractional.low >>> 0, message.fractional.high >>> 0).toNumber() : message.fractional;
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            return object;
        };

        /**
         * Converts this Coin to JSON.
         * @function toJSON
         * @memberof coin.Coin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coin;
    })();

    return coin;
})();

$root.crypto = (function() {

    /**
     * Namespace crypto.
     * @exports crypto
     * @namespace
     */
    var crypto = {};

    crypto.PublicKey = (function() {

        /**
         * Properties of a PublicKey.
         * @memberof crypto
         * @interface IPublicKey
         * @property {Uint8Array|null} [ed25519] PublicKey ed25519
         */

        /**
         * Constructs a new PublicKey.
         * @memberof crypto
         * @classdesc Represents a PublicKey.
         * @implements IPublicKey
         * @constructor
         * @param {crypto.IPublicKey=} [properties] Properties to set
         */
        function PublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicKey ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.PublicKey
         * @instance
         */
        PublicKey.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PublicKey pub.
         * @member {"ed25519"|undefined} pub
         * @memberof crypto.PublicKey
         * @instance
         */
        Object.defineProperty(PublicKey.prototype, "pub", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PublicKey instance using the specified properties.
         * @function create
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey=} [properties] Properties to set
         * @returns {crypto.PublicKey} PublicKey instance
         */
        PublicKey.create = function create(properties) {
            return new PublicKey(properties);
        };

        /**
         * Encodes the specified PublicKey message. Does not implicitly {@link crypto.PublicKey.verify|verify} messages.
         * @function encode
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified PublicKey message, length delimited. Does not implicitly {@link crypto.PublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.PublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicKey message.
         * @function verify
         * @memberof crypto.PublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.pub = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.PublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.PublicKey} PublicKey
         */
        PublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.PublicKey)
                return object;
            var message = new $root.crypto.PublicKey();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.PublicKey} message PublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.pub = "ed25519";
            }
            return object;
        };

        /**
         * Converts this PublicKey to JSON.
         * @function toJSON
         * @memberof crypto.PublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublicKey;
    })();

    crypto.PrivateKey = (function() {

        /**
         * Properties of a PrivateKey.
         * @memberof crypto
         * @interface IPrivateKey
         * @property {Uint8Array|null} [ed25519] PrivateKey ed25519
         */

        /**
         * Constructs a new PrivateKey.
         * @memberof crypto
         * @classdesc Represents a PrivateKey.
         * @implements IPrivateKey
         * @constructor
         * @param {crypto.IPrivateKey=} [properties] Properties to set
         */
        function PrivateKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateKey ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.PrivateKey
         * @instance
         */
        PrivateKey.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PrivateKey priv.
         * @member {"ed25519"|undefined} priv
         * @memberof crypto.PrivateKey
         * @instance
         */
        Object.defineProperty(PrivateKey.prototype, "priv", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PrivateKey instance using the specified properties.
         * @function create
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey=} [properties] Properties to set
         * @returns {crypto.PrivateKey} PrivateKey instance
         */
        PrivateKey.create = function create(properties) {
            return new PrivateKey(properties);
        };

        /**
         * Encodes the specified PrivateKey message. Does not implicitly {@link crypto.PrivateKey.verify|verify} messages.
         * @function encode
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey} message PrivateKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified PrivateKey message, length delimited. Does not implicitly {@link crypto.PrivateKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey} message PrivateKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateKey message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.PrivateKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.PrivateKey} PrivateKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.PrivateKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.PrivateKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.PrivateKey} PrivateKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateKey message.
         * @function verify
         * @memberof crypto.PrivateKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.priv = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.PrivateKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.PrivateKey} PrivateKey
         */
        PrivateKey.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.PrivateKey)
                return object;
            var message = new $root.crypto.PrivateKey();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.PrivateKey} message PrivateKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.priv = "ed25519";
            }
            return object;
        };

        /**
         * Converts this PrivateKey to JSON.
         * @function toJSON
         * @memberof crypto.PrivateKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrivateKey;
    })();

    crypto.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof crypto
         * @interface ISignature
         * @property {Uint8Array|null} [ed25519] Signature ed25519
         */

        /**
         * Constructs a new Signature.
         * @memberof crypto
         * @classdesc Represents a Signature.
         * @implements ISignature
         * @constructor
         * @param {crypto.ISignature=} [properties] Properties to set
         */
        function Signature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Signature ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Signature sig.
         * @member {"ed25519"|undefined} sig
         * @memberof crypto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "sig", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature=} [properties] Properties to set
         * @returns {crypto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link crypto.Signature.verify|verify} messages.
         * @function encode
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified Signature message, length delimited. Does not implicitly {@link crypto.Signature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.Signature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Signature message.
         * @function verify
         * @memberof crypto.Signature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Signature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.sig = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a Signature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.Signature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.Signature} Signature
         */
        Signature.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.Signature)
                return object;
            var message = new $root.crypto.Signature();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a Signature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.Signature
         * @static
         * @param {crypto.Signature} message Signature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Signature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.sig = "ed25519";
            }
            return object;
        };

        /**
         * Converts this Signature to JSON.
         * @function toJSON
         * @memberof crypto.Signature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Signature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Signature;
    })();

    return crypto;
})();

$root.migration = (function() {

    /**
     * Namespace migration.
     * @exports migration
     * @namespace
     */
    var migration = {};

    migration.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof migration
         * @interface IConfiguration
         * @property {Uint8Array|null} [admin] multisig.
         */

        /**
         * Constructs a new Configuration.
         * @memberof migration
         * @classdesc Represents a Configuration.
         * @implements IConfiguration
         * @constructor
         * @param {migration.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * multisig.
         * @member {Uint8Array} admin
         * @memberof migration.Configuration
         * @instance
         */
        Configuration.prototype.admin = $util.newBuffer([]);

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration=} [properties] Properties to set
         * @returns {migration.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link migration.Configuration.verify|verify} messages.
         * @function encode
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link migration.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof migration.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.admin = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof migration.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.Configuration)
                return object;
            var message = new $root.migration.Configuration();
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.Configuration
         * @static
         * @param {migration.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof migration.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    migration.Schema = (function() {

        /**
         * Properties of a Schema.
         * @memberof migration
         * @interface ISchema
         * @property {weave.IMetadata|null} [metadata] Schema metadata
         * @property {string|null} [pkg] For example, for extension `x/myext` package value is `myext`
         * @property {number|null} [version] Version holds the highest supported schema version.
         */

        /**
         * Constructs a new Schema.
         * @memberof migration
         * @classdesc Schema declares the maxiumum supported schema version for a package.
         * @implements ISchema
         * @constructor
         * @param {migration.ISchema=} [properties] Properties to set
         */
        function Schema(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Schema metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.metadata = null;

        /**
         * For example, for extension `x/myext` package value is `myext`
         * @member {string} pkg
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.pkg = "";

        /**
         * Version holds the highest supported schema version.
         * @member {number} version
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.version = 0;

        /**
         * Creates a new Schema instance using the specified properties.
         * @function create
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema=} [properties] Properties to set
         * @returns {migration.Schema} Schema instance
         */
        Schema.create = function create(properties) {
            return new Schema(properties);
        };

        /**
         * Encodes the specified Schema message. Does not implicitly {@link migration.Schema.verify|verify} messages.
         * @function encode
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pkg);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified Schema message, length delimited. Does not implicitly {@link migration.Schema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Schema message from the specified reader or buffer.
         * @function decode
         * @memberof migration.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.Schema();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pkg = reader.string();
                    break;
                case 3:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Schema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Schema message.
         * @function verify
         * @memberof migration.Schema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Schema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                if (!$util.isString(message.pkg))
                    return "pkg: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a Schema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.Schema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.Schema} Schema
         */
        Schema.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.Schema)
                return object;
            var message = new $root.migration.Schema();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".migration.Schema.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pkg != null)
                message.pkg = String(object.pkg);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Schema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.Schema
         * @static
         * @param {migration.Schema} message Schema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Schema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pkg = "";
                object.version = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                object.pkg = message.pkg;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this Schema to JSON.
         * @function toJSON
         * @memberof migration.Schema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Schema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Schema;
    })();

    migration.UpgradeSchemaMsg = (function() {

        /**
         * Properties of an UpgradeSchemaMsg.
         * @memberof migration
         * @interface IUpgradeSchemaMsg
         * @property {weave.IMetadata|null} [metadata] UpgradeSchemaMsg metadata
         * @property {string|null} [pkg] Name of the package that schema version upgrade is made for.
         */

        /**
         * Constructs a new UpgradeSchemaMsg.
         * @memberof migration
         * @classdesc by one version.
         * @implements IUpgradeSchemaMsg
         * @constructor
         * @param {migration.IUpgradeSchemaMsg=} [properties] Properties to set
         */
        function UpgradeSchemaMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpgradeSchemaMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         */
        UpgradeSchemaMsg.prototype.metadata = null;

        /**
         * Name of the package that schema version upgrade is made for.
         * @member {string} pkg
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         */
        UpgradeSchemaMsg.prototype.pkg = "";

        /**
         * Creates a new UpgradeSchemaMsg instance using the specified properties.
         * @function create
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg=} [properties] Properties to set
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg instance
         */
        UpgradeSchemaMsg.create = function create(properties) {
            return new UpgradeSchemaMsg(properties);
        };

        /**
         * Encodes the specified UpgradeSchemaMsg message. Does not implicitly {@link migration.UpgradeSchemaMsg.verify|verify} messages.
         * @function encode
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg} message UpgradeSchemaMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeSchemaMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pkg);
            return writer;
        };

        /**
         * Encodes the specified UpgradeSchemaMsg message, length delimited. Does not implicitly {@link migration.UpgradeSchemaMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg} message UpgradeSchemaMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeSchemaMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpgradeSchemaMsg message from the specified reader or buffer.
         * @function decode
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeSchemaMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.UpgradeSchemaMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pkg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpgradeSchemaMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeSchemaMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpgradeSchemaMsg message.
         * @function verify
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpgradeSchemaMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                if (!$util.isString(message.pkg))
                    return "pkg: string expected";
            return null;
        };

        /**
         * Creates an UpgradeSchemaMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         */
        UpgradeSchemaMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.UpgradeSchemaMsg)
                return object;
            var message = new $root.migration.UpgradeSchemaMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".migration.UpgradeSchemaMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pkg != null)
                message.pkg = String(object.pkg);
            return message;
        };

        /**
         * Creates a plain object from an UpgradeSchemaMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.UpgradeSchemaMsg} message UpgradeSchemaMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpgradeSchemaMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pkg = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                object.pkg = message.pkg;
            return object;
        };

        /**
         * Converts this UpgradeSchemaMsg to JSON.
         * @function toJSON
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpgradeSchemaMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpgradeSchemaMsg;
    })();

    return migration;
})();

$root.orm = (function() {

    /**
     * Namespace orm.
     * @exports orm
     * @namespace
     */
    var orm = {};

    orm.MultiRef = (function() {

        /**
         * Properties of a MultiRef.
         * @memberof orm
         * @interface IMultiRef
         * @property {Array.<Uint8Array>|null} [refs] MultiRef refs
         */

        /**
         * Constructs a new MultiRef.
         * @memberof orm
         * @classdesc MultiRef contains a list of references to pks
         * @implements IMultiRef
         * @constructor
         * @param {orm.IMultiRef=} [properties] Properties to set
         */
        function MultiRef(properties) {
            this.refs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MultiRef refs.
         * @member {Array.<Uint8Array>} refs
         * @memberof orm.MultiRef
         * @instance
         */
        MultiRef.prototype.refs = $util.emptyArray;

        /**
         * Creates a new MultiRef instance using the specified properties.
         * @function create
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef=} [properties] Properties to set
         * @returns {orm.MultiRef} MultiRef instance
         */
        MultiRef.create = function create(properties) {
            return new MultiRef(properties);
        };

        /**
         * Encodes the specified MultiRef message. Does not implicitly {@link orm.MultiRef.verify|verify} messages.
         * @function encode
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef} message MultiRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiRef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.refs != null && message.refs.length)
                for (var i = 0; i < message.refs.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.refs[i]);
            return writer;
        };

        /**
         * Encodes the specified MultiRef message, length delimited. Does not implicitly {@link orm.MultiRef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef} message MultiRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiRef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultiRef message from the specified reader or buffer.
         * @function decode
         * @memberof orm.MultiRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.MultiRef} MultiRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiRef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.MultiRef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.refs && message.refs.length))
                        message.refs = [];
                    message.refs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultiRef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.MultiRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.MultiRef} MultiRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiRef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultiRef message.
         * @function verify
         * @memberof orm.MultiRef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiRef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.refs != null && message.hasOwnProperty("refs")) {
                if (!Array.isArray(message.refs))
                    return "refs: array expected";
                for (var i = 0; i < message.refs.length; ++i)
                    if (!(message.refs[i] && typeof message.refs[i].length === "number" || $util.isString(message.refs[i])))
                        return "refs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a MultiRef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.MultiRef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.MultiRef} MultiRef
         */
        MultiRef.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.MultiRef)
                return object;
            var message = new $root.orm.MultiRef();
            if (object.refs) {
                if (!Array.isArray(object.refs))
                    throw TypeError(".orm.MultiRef.refs: array expected");
                message.refs = [];
                for (var i = 0; i < object.refs.length; ++i)
                    if (typeof object.refs[i] === "string")
                        $util.base64.decode(object.refs[i], message.refs[i] = $util.newBuffer($util.base64.length(object.refs[i])), 0);
                    else if (object.refs[i].length)
                        message.refs[i] = object.refs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a MultiRef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.MultiRef
         * @static
         * @param {orm.MultiRef} message MultiRef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiRef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.refs = [];
            if (message.refs && message.refs.length) {
                object.refs = [];
                for (var j = 0; j < message.refs.length; ++j)
                    object.refs[j] = options.bytes === String ? $util.base64.encode(message.refs[j], 0, message.refs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.refs[j]) : message.refs[j];
            }
            return object;
        };

        /**
         * Converts this MultiRef to JSON.
         * @function toJSON
         * @memberof orm.MultiRef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiRef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MultiRef;
    })();

    orm.Counter = (function() {

        /**
         * Properties of a Counter.
         * @memberof orm
         * @interface ICounter
         * @property {number|Long|null} [count] Counter count
         */

        /**
         * Constructs a new Counter.
         * @memberof orm
         * @classdesc Counter could be used for sequence, but mainly just for test
         * @implements ICounter
         * @constructor
         * @param {orm.ICounter=} [properties] Properties to set
         */
        function Counter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Counter count.
         * @member {number|Long} count
         * @memberof orm.Counter
         * @instance
         */
        Counter.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Counter instance using the specified properties.
         * @function create
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter=} [properties] Properties to set
         * @returns {orm.Counter} Counter instance
         */
        Counter.create = function create(properties) {
            return new Counter(properties);
        };

        /**
         * Encodes the specified Counter message. Does not implicitly {@link orm.Counter.verify|verify} messages.
         * @function encode
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter} message Counter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Counter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.count);
            return writer;
        };

        /**
         * Encodes the specified Counter message, length delimited. Does not implicitly {@link orm.Counter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter} message Counter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Counter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Counter message from the specified reader or buffer.
         * @function decode
         * @memberof orm.Counter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.Counter} Counter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Counter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.Counter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Counter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.Counter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.Counter} Counter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Counter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Counter message.
         * @function verify
         * @memberof orm.Counter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Counter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
            return null;
        };

        /**
         * Creates a Counter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.Counter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.Counter} Counter
         */
        Counter.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.Counter)
                return object;
            var message = new $root.orm.Counter();
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Counter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.Counter
         * @static
         * @param {orm.Counter} message Counter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Counter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            return object;
        };

        /**
         * Converts this Counter to JSON.
         * @function toJSON
         * @memberof orm.Counter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Counter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Counter;
    })();

    orm.VersionedIDRef = (function() {

        /**
         * Properties of a VersionedIDRef.
         * @memberof orm
         * @interface IVersionedIDRef
         * @property {Uint8Array|null} [id] Unique identifier
         * @property {number|null} [version] Document version, starting with 1.
         */

        /**
         * Constructs a new VersionedIDRef.
         * @memberof orm
         * @classdesc VersionedID is the combination of document ID and version number.
         * @implements IVersionedIDRef
         * @constructor
         * @param {orm.IVersionedIDRef=} [properties] Properties to set
         */
        function VersionedIDRef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unique identifier
         * @member {Uint8Array} id
         * @memberof orm.VersionedIDRef
         * @instance
         */
        VersionedIDRef.prototype.id = $util.newBuffer([]);

        /**
         * Document version, starting with 1.
         * @member {number} version
         * @memberof orm.VersionedIDRef
         * @instance
         */
        VersionedIDRef.prototype.version = 0;

        /**
         * Creates a new VersionedIDRef instance using the specified properties.
         * @function create
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef=} [properties] Properties to set
         * @returns {orm.VersionedIDRef} VersionedIDRef instance
         */
        VersionedIDRef.create = function create(properties) {
            return new VersionedIDRef(properties);
        };

        /**
         * Encodes the specified VersionedIDRef message. Does not implicitly {@link orm.VersionedIDRef.verify|verify} messages.
         * @function encode
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef} message VersionedIDRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedIDRef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.id);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified VersionedIDRef message, length delimited. Does not implicitly {@link orm.VersionedIDRef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef} message VersionedIDRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedIDRef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionedIDRef message from the specified reader or buffer.
         * @function decode
         * @memberof orm.VersionedIDRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.VersionedIDRef} VersionedIDRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedIDRef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.VersionedIDRef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.id = reader.bytes();
                    break;
                case 5:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionedIDRef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.VersionedIDRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.VersionedIDRef} VersionedIDRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedIDRef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionedIDRef message.
         * @function verify
         * @memberof orm.VersionedIDRef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionedIDRef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a VersionedIDRef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.VersionedIDRef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.VersionedIDRef} VersionedIDRef
         */
        VersionedIDRef.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.VersionedIDRef)
                return object;
            var message = new $root.orm.VersionedIDRef();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a VersionedIDRef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.VersionedIDRef} message VersionedIDRef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionedIDRef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.version = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this VersionedIDRef to JSON.
         * @function toJSON
         * @memberof orm.VersionedIDRef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionedIDRef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionedIDRef;
    })();

    return orm;
})();

$root.aswap = (function() {

    /**
     * Namespace aswap.
     * @exports aswap
     * @namespace
     */
    var aswap = {};

    aswap.Swap = (function() {

        /**
         * Properties of a Swap.
         * @memberof aswap
         * @interface ISwap
         * @property {weave.IMetadata|null} [metadata] metadata is used for schema versioning support
         * @property {Uint8Array|null} [preimageHash] sha256 hash of preimage, 32 bytes long
         * @property {Uint8Array|null} [source] source is a sender address
         * @property {Uint8Array|null} [destination] destination is an address of destination
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] max length 128 characters
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new Swap.
         * @memberof aswap
         * @classdesc Swap is designed to hold some coins for atomic swap, locked by preimage_hash
         * @implements ISwap
         * @constructor
         * @param {aswap.ISwap=} [properties] Properties to set
         */
        function Swap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * metadata is used for schema versioning support
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.metadata = null;

        /**
         * sha256 hash of preimage, 32 bytes long
         * @member {Uint8Array} preimageHash
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.preimageHash = $util.newBuffer([]);

        /**
         * source is a sender address
         * @member {Uint8Array} source
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.source = $util.newBuffer([]);

        /**
         * destination is an address of destination
         * @member {Uint8Array} destination
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.destination = $util.newBuffer([]);

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 characters
         * @member {string} memo
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.memo = "";

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new Swap instance using the specified properties.
         * @function create
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap=} [properties] Properties to set
         * @returns {aswap.Swap} Swap instance
         */
        Swap.create = function create(properties) {
            return new Swap(properties);
        };

        /**
         * Encodes the specified Swap message. Does not implicitly {@link aswap.Swap.verify|verify} messages.
         * @function encode
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap} message Swap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Swap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.preimageHash);
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.source);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.destination);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified Swap message, length delimited. Does not implicitly {@link aswap.Swap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap} message Swap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Swap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Swap message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.Swap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.Swap} Swap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Swap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.Swap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preimageHash = reader.bytes();
                    break;
                case 3:
                    message.source = reader.bytes();
                    break;
                case 5:
                    message.destination = reader.bytes();
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                case 8:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Swap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.Swap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.Swap} Swap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Swap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Swap message.
         * @function verify
         * @memberof aswap.Swap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Swap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                if (!(message.preimageHash && typeof message.preimageHash.length === "number" || $util.isString(message.preimageHash)))
                    return "preimageHash: buffer expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates a Swap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.Swap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.Swap} Swap
         */
        Swap.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.Swap)
                return object;
            var message = new $root.aswap.Swap();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.Swap.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.preimageHash != null)
                if (typeof object.preimageHash === "string")
                    $util.base64.decode(object.preimageHash, message.preimageHash = $util.newBuffer($util.base64.length(object.preimageHash)), 0);
                else if (object.preimageHash.length)
                    message.preimageHash = object.preimageHash;
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from a Swap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.Swap
         * @static
         * @param {aswap.Swap} message Swap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Swap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.preimageHash = "";
                else {
                    object.preimageHash = [];
                    if (options.bytes !== Array)
                        object.preimageHash = $util.newBuffer(object.preimageHash);
                }
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                object.preimageHash = options.bytes === String ? $util.base64.encode(message.preimageHash, 0, message.preimageHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimageHash) : message.preimageHash;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this Swap to JSON.
         * @function toJSON
         * @memberof aswap.Swap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Swap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Swap;
    })();

    aswap.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof aswap
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {Uint8Array|null} [source] CreateMsg source
         * @property {Uint8Array|null} [preimageHash] sha256 hash of preimage, 32 bytes long
         * @property {Uint8Array|null} [destination] CreateMsg destination
         * @property {Array.<coin.ICoin>|null} [amount] amount may contain multiple token types
         * @property {number|Long|null} [timeout] Timeout represents wall clock time.
         * @property {string|null} [memo] max length 128 character
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof aswap
         * @classdesc CreateMsg creates a Swap with some coins.
         * @implements ICreateMsg
         * @constructor
         * @param {aswap.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * CreateMsg source.
         * @member {Uint8Array} source
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.source = $util.newBuffer([]);

        /**
         * sha256 hash of preimage, 32 bytes long
         * @member {Uint8Array} preimageHash
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.preimageHash = $util.newBuffer([]);

        /**
         * CreateMsg destination.
         * @member {Uint8Array} destination
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.destination = $util.newBuffer([]);

        /**
         * amount may contain multiple token types
         * @member {Array.<coin.ICoin>} amount
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.amount = $util.emptyArray;

        /**
         * Timeout represents wall clock time.
         * @member {number|Long} timeout
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof aswap.CreateMsg
         * @instance
         */
        CreateMsg.prototype.memo = "";

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof aswap.CreateMsg
         * @static
         * @param {aswap.ICreateMsg=} [properties] Properties to set
         * @returns {aswap.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link aswap.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.CreateMsg
         * @static
         * @param {aswap.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preimageHash);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.destination);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link aswap.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.CreateMsg
         * @static
         * @param {aswap.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.preimageHash = reader.bytes();
                    break;
                case 4:
                    message.destination = reader.bytes();
                    break;
                case 5:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof aswap.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                if (!(message.preimageHash && typeof message.preimageHash.length === "number" || $util.isString(message.preimageHash)))
                    return "preimageHash: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.CreateMsg)
                return object;
            var message = new $root.aswap.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.preimageHash != null)
                if (typeof object.preimageHash === "string")
                    $util.base64.decode(object.preimageHash, message.preimageHash = $util.newBuffer($util.base64.length(object.preimageHash)), 0);
                else if (object.preimageHash.length)
                    message.preimageHash = object.preimageHash;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".aswap.CreateMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".aswap.CreateMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.CreateMsg
         * @static
         * @param {aswap.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.preimageHash = "";
                else {
                    object.preimageHash = [];
                    if (options.bytes !== Array)
                        object.preimageHash = $util.newBuffer(object.preimageHash);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                object.preimageHash = options.bytes === String ? $util.base64.encode(message.preimageHash, 0, message.preimageHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimageHash) : message.preimageHash;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof aswap.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    aswap.ReleaseMsg = (function() {

        /**
         * Properties of a ReleaseMsg.
         * @memberof aswap
         * @interface IReleaseMsg
         * @property {weave.IMetadata|null} [metadata] ReleaseMsg metadata
         * @property {Uint8Array|null} [swapId] swap_id to release
         * @property {Uint8Array|null} [preimage] must be exactly 32 bytes long
         */

        /**
         * Constructs a new ReleaseMsg.
         * @memberof aswap
         * @classdesc This operation is authorized by preimage, which is sent raw and then hashed on the backend.
         * @implements IReleaseMsg
         * @constructor
         * @param {aswap.IReleaseMsg=} [properties] Properties to set
         */
        function ReleaseMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReleaseMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.metadata = null;

        /**
         * swap_id to release
         * @member {Uint8Array} swapId
         * @memberof aswap.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.swapId = $util.newBuffer([]);

        /**
         * must be exactly 32 bytes long
         * @member {Uint8Array} preimage
         * @memberof aswap.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.preimage = $util.newBuffer([]);

        /**
         * Creates a new ReleaseMsg instance using the specified properties.
         * @function create
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {aswap.IReleaseMsg=} [properties] Properties to set
         * @returns {aswap.ReleaseMsg} ReleaseMsg instance
         */
        ReleaseMsg.create = function create(properties) {
            return new ReleaseMsg(properties);
        };

        /**
         * Encodes the specified ReleaseMsg message. Does not implicitly {@link aswap.ReleaseMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {aswap.IReleaseMsg} message ReleaseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preimage);
            return writer;
        };

        /**
         * Encodes the specified ReleaseMsg message, length delimited. Does not implicitly {@link aswap.ReleaseMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {aswap.IReleaseMsg} message ReleaseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.ReleaseMsg} ReleaseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.ReleaseMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.swapId = reader.bytes();
                    break;
                case 3:
                    message.preimage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.ReleaseMsg} ReleaseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseMsg message.
         * @function verify
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                if (!(message.preimage && typeof message.preimage.length === "number" || $util.isString(message.preimage)))
                    return "preimage: buffer expected";
            return null;
        };

        /**
         * Creates a ReleaseMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.ReleaseMsg} ReleaseMsg
         */
        ReleaseMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.ReleaseMsg)
                return object;
            var message = new $root.aswap.ReleaseMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.ReleaseMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length)
                    message.swapId = object.swapId;
            if (object.preimage != null)
                if (typeof object.preimage === "string")
                    $util.base64.decode(object.preimage, message.preimage = $util.newBuffer($util.base64.length(object.preimage)), 0);
                else if (object.preimage.length)
                    message.preimage = object.preimage;
            return message;
        };

        /**
         * Creates a plain object from a ReleaseMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.ReleaseMsg
         * @static
         * @param {aswap.ReleaseMsg} message ReleaseMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
                if (options.bytes === String)
                    object.preimage = "";
                else {
                    object.preimage = [];
                    if (options.bytes !== Array)
                        object.preimage = $util.newBuffer(object.preimage);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                object.preimage = options.bytes === String ? $util.base64.encode(message.preimage, 0, message.preimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimage) : message.preimage;
            return object;
        };

        /**
         * Converts this ReleaseMsg to JSON.
         * @function toJSON
         * @memberof aswap.ReleaseMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseMsg;
    })();

    aswap.ReturnMsg = (function() {

        /**
         * Properties of a ReturnMsg.
         * @memberof aswap
         * @interface IReturnMsg
         * @property {weave.IMetadata|null} [metadata] ReturnMsg metadata
         * @property {Uint8Array|null} [swapId] swap_id to return
         */

        /**
         * Constructs a new ReturnMsg.
         * @memberof aswap
         * @classdesc This operation only works if the Swap is expired.
         * @implements IReturnMsg
         * @constructor
         * @param {aswap.IReturnMsg=} [properties] Properties to set
         */
        function ReturnMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReturnMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.ReturnMsg
         * @instance
         */
        ReturnMsg.prototype.metadata = null;

        /**
         * swap_id to return
         * @member {Uint8Array} swapId
         * @memberof aswap.ReturnMsg
         * @instance
         */
        ReturnMsg.prototype.swapId = $util.newBuffer([]);

        /**
         * Creates a new ReturnMsg instance using the specified properties.
         * @function create
         * @memberof aswap.ReturnMsg
         * @static
         * @param {aswap.IReturnMsg=} [properties] Properties to set
         * @returns {aswap.ReturnMsg} ReturnMsg instance
         */
        ReturnMsg.create = function create(properties) {
            return new ReturnMsg(properties);
        };

        /**
         * Encodes the specified ReturnMsg message. Does not implicitly {@link aswap.ReturnMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.ReturnMsg
         * @static
         * @param {aswap.IReturnMsg} message ReturnMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
            return writer;
        };

        /**
         * Encodes the specified ReturnMsg message, length delimited. Does not implicitly {@link aswap.ReturnMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.ReturnMsg
         * @static
         * @param {aswap.IReturnMsg} message ReturnMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReturnMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.ReturnMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.ReturnMsg} ReturnMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.ReturnMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.swapId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReturnMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.ReturnMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.ReturnMsg} ReturnMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReturnMsg message.
         * @function verify
         * @memberof aswap.ReturnMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReturnMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            return null;
        };

        /**
         * Creates a ReturnMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.ReturnMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.ReturnMsg} ReturnMsg
         */
        ReturnMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.ReturnMsg)
                return object;
            var message = new $root.aswap.ReturnMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.ReturnMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length)
                    message.swapId = object.swapId;
            return message;
        };

        /**
         * Creates a plain object from a ReturnMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.ReturnMsg
         * @static
         * @param {aswap.ReturnMsg} message ReturnMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReturnMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            return object;
        };

        /**
         * Converts this ReturnMsg to JSON.
         * @function toJSON
         * @memberof aswap.ReturnMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReturnMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReturnMsg;
    })();

    return aswap;
})();

$root.batch = (function() {

    /**
     * Namespace batch.
     * @exports batch
     * @namespace
     */
    var batch = {};

    batch.ByteArrayList = (function() {

        /**
         * Properties of a ByteArrayList.
         * @memberof batch
         * @interface IByteArrayList
         * @property {Array.<Uint8Array>|null} [elements] ByteArrayList elements
         */

        /**
         * Constructs a new ByteArrayList.
         * @memberof batch
         * @classdesc Represents a ByteArrayList.
         * @implements IByteArrayList
         * @constructor
         * @param {batch.IByteArrayList=} [properties] Properties to set
         */
        function ByteArrayList(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ByteArrayList elements.
         * @member {Array.<Uint8Array>} elements
         * @memberof batch.ByteArrayList
         * @instance
         */
        ByteArrayList.prototype.elements = $util.emptyArray;

        /**
         * Creates a new ByteArrayList instance using the specified properties.
         * @function create
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList=} [properties] Properties to set
         * @returns {batch.ByteArrayList} ByteArrayList instance
         */
        ByteArrayList.create = function create(properties) {
            return new ByteArrayList(properties);
        };

        /**
         * Encodes the specified ByteArrayList message. Does not implicitly {@link batch.ByteArrayList.verify|verify} messages.
         * @function encode
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList} message ByteArrayList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByteArrayList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.elements[i]);
            return writer;
        };

        /**
         * Encodes the specified ByteArrayList message, length delimited. Does not implicitly {@link batch.ByteArrayList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList} message ByteArrayList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByteArrayList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ByteArrayList message from the specified reader or buffer.
         * @function decode
         * @memberof batch.ByteArrayList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {batch.ByteArrayList} ByteArrayList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByteArrayList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.batch.ByteArrayList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ByteArrayList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof batch.ByteArrayList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {batch.ByteArrayList} ByteArrayList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByteArrayList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ByteArrayList message.
         * @function verify
         * @memberof batch.ByteArrayList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ByteArrayList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i)
                    if (!(message.elements[i] && typeof message.elements[i].length === "number" || $util.isString(message.elements[i])))
                        return "elements: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ByteArrayList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof batch.ByteArrayList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {batch.ByteArrayList} ByteArrayList
         */
        ByteArrayList.fromObject = function fromObject(object) {
            if (object instanceof $root.batch.ByteArrayList)
                return object;
            var message = new $root.batch.ByteArrayList();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".batch.ByteArrayList.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i)
                    if (typeof object.elements[i] === "string")
                        $util.base64.decode(object.elements[i], message.elements[i] = $util.newBuffer($util.base64.length(object.elements[i])), 0);
                    else if (object.elements[i].length)
                        message.elements[i] = object.elements[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ByteArrayList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.ByteArrayList} message ByteArrayList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ByteArrayList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = options.bytes === String ? $util.base64.encode(message.elements[j], 0, message.elements[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.elements[j]) : message.elements[j];
            }
            return object;
        };

        /**
         * Converts this ByteArrayList to JSON.
         * @function toJSON
         * @memberof batch.ByteArrayList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ByteArrayList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ByteArrayList;
    })();

    return batch;
})();

$root.cash = (function() {

    /**
     * Namespace cash.
     * @exports cash
     * @namespace
     */
    var cash = {};

    cash.Set = (function() {

        /**
         * Properties of a Set.
         * @memberof cash
         * @interface ISet
         * @property {weave.IMetadata|null} [metadata] Set metadata
         * @property {Array.<coin.ICoin>|null} [coins] Set coins
         */

        /**
         * Constructs a new Set.
         * @memberof cash
         * @classdesc It handles adding and subtracting sets of currencies.
         * @implements ISet
         * @constructor
         * @param {cash.ISet=} [properties] Properties to set
         */
        function Set(properties) {
            this.coins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Set metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.Set
         * @instance
         */
        Set.prototype.metadata = null;

        /**
         * Set coins.
         * @member {Array.<coin.ICoin>} coins
         * @memberof cash.Set
         * @instance
         */
        Set.prototype.coins = $util.emptyArray;

        /**
         * Creates a new Set instance using the specified properties.
         * @function create
         * @memberof cash.Set
         * @static
         * @param {cash.ISet=} [properties] Properties to set
         * @returns {cash.Set} Set instance
         */
        Set.create = function create(properties) {
            return new Set(properties);
        };

        /**
         * Encodes the specified Set message. Does not implicitly {@link cash.Set.verify|verify} messages.
         * @function encode
         * @memberof cash.Set
         * @static
         * @param {cash.ISet} message Set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Set.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.coins != null && message.coins.length)
                for (var i = 0; i < message.coins.length; ++i)
                    $root.coin.Coin.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Set message, length delimited. Does not implicitly {@link cash.Set.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.Set
         * @static
         * @param {cash.ISet} message Set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Set.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Set message from the specified reader or buffer.
         * @function decode
         * @memberof cash.Set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.Set} Set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Set.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.Set();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.coins && message.coins.length))
                        message.coins = [];
                    message.coins.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Set message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.Set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.Set} Set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Set.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Set message.
         * @function verify
         * @memberof cash.Set
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Set.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.coins != null && message.hasOwnProperty("coins")) {
                if (!Array.isArray(message.coins))
                    return "coins: array expected";
                for (var i = 0; i < message.coins.length; ++i) {
                    var error = $root.coin.Coin.verify(message.coins[i]);
                    if (error)
                        return "coins." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Set message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.Set
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.Set} Set
         */
        Set.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.Set)
                return object;
            var message = new $root.cash.Set();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.Set.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.coins) {
                if (!Array.isArray(object.coins))
                    throw TypeError(".cash.Set.coins: array expected");
                message.coins = [];
                for (var i = 0; i < object.coins.length; ++i) {
                    if (typeof object.coins[i] !== "object")
                        throw TypeError(".cash.Set.coins: object expected");
                    message.coins[i] = $root.coin.Coin.fromObject(object.coins[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Set message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.Set
         * @static
         * @param {cash.Set} message Set
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Set.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.coins = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.coins && message.coins.length) {
                object.coins = [];
                for (var j = 0; j < message.coins.length; ++j)
                    object.coins[j] = $root.coin.Coin.toObject(message.coins[j], options);
            }
            return object;
        };

        /**
         * Converts this Set to JSON.
         * @function toJSON
         * @memberof cash.Set
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Set.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Set;
    })();

    cash.SendMsg = (function() {

        /**
         * Properties of a SendMsg.
         * @memberof cash
         * @interface ISendMsg
         * @property {weave.IMetadata|null} [metadata] SendMsg metadata
         * @property {Uint8Array|null} [source] SendMsg source
         * @property {Uint8Array|null} [destination] SendMsg destination
         * @property {coin.ICoin|null} [amount] SendMsg amount
         * @property {string|null} [memo] max length 128 character
         * @property {Uint8Array|null} [ref] max length 64 bytes
         */

        /**
         * Constructs a new SendMsg.
         * @memberof cash
         * @classdesc eg. tx hash
         * @implements ISendMsg
         * @constructor
         * @param {cash.ISendMsg=} [properties] Properties to set
         */
        function SendMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.metadata = null;

        /**
         * SendMsg source.
         * @member {Uint8Array} source
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.source = $util.newBuffer([]);

        /**
         * SendMsg destination.
         * @member {Uint8Array} destination
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.destination = $util.newBuffer([]);

        /**
         * SendMsg amount.
         * @member {coin.ICoin|null|undefined} amount
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.amount = null;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.memo = "";

        /**
         * max length 64 bytes
         * @member {Uint8Array} ref
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.ref = $util.newBuffer([]);

        /**
         * Creates a new SendMsg instance using the specified properties.
         * @function create
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg=} [properties] Properties to set
         * @returns {cash.SendMsg} SendMsg instance
         */
        SendMsg.create = function create(properties) {
            return new SendMsg(properties);
        };

        /**
         * Encodes the specified SendMsg message. Does not implicitly {@link cash.SendMsg.verify|verify} messages.
         * @function encode
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg} message SendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.destination);
            if (message.amount != null && message.hasOwnProperty("amount"))
                $root.coin.Coin.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
            if (message.ref != null && message.hasOwnProperty("ref"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.ref);
            return writer;
        };

        /**
         * Encodes the specified SendMsg message, length delimited. Does not implicitly {@link cash.SendMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg} message SendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendMsg message from the specified reader or buffer.
         * @function decode
         * @memberof cash.SendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.SendMsg} SendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.SendMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.destination = reader.bytes();
                    break;
                case 4:
                    message.amount = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.memo = reader.string();
                    break;
                case 6:
                    message.ref = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.SendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.SendMsg} SendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendMsg message.
         * @function verify
         * @memberof cash.SendMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                var error = $root.coin.Coin.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.ref != null && message.hasOwnProperty("ref"))
                if (!(message.ref && typeof message.ref.length === "number" || $util.isString(message.ref)))
                    return "ref: buffer expected";
            return null;
        };

        /**
         * Creates a SendMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.SendMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.SendMsg} SendMsg
         */
        SendMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.SendMsg)
                return object;
            var message = new $root.cash.SendMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.SendMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".cash.SendMsg.amount: object expected");
                message.amount = $root.coin.Coin.fromObject(object.amount);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.ref != null)
                if (typeof object.ref === "string")
                    $util.base64.decode(object.ref, message.ref = $util.newBuffer($util.base64.length(object.ref)), 0);
                else if (object.ref.length)
                    message.ref = object.ref;
            return message;
        };

        /**
         * Creates a plain object from a SendMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.SendMsg
         * @static
         * @param {cash.SendMsg} message SendMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                object.amount = null;
                object.memo = "";
                if (options.bytes === String)
                    object.ref = "";
                else {
                    object.ref = [];
                    if (options.bytes !== Array)
                        object.ref = $util.newBuffer(object.ref);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.coin.Coin.toObject(message.amount, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.ref != null && message.hasOwnProperty("ref"))
                object.ref = options.bytes === String ? $util.base64.encode(message.ref, 0, message.ref.length) : options.bytes === Array ? Array.prototype.slice.call(message.ref) : message.ref;
            return object;
        };

        /**
         * Converts this SendMsg to JSON.
         * @function toJSON
         * @memberof cash.SendMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendMsg;
    })();

    cash.FeeInfo = (function() {

        /**
         * Properties of a FeeInfo.
         * @memberof cash
         * @interface IFeeInfo
         * @property {Uint8Array|null} [payer] FeeInfo payer
         * @property {coin.ICoin|null} [fees] FeeInfo fees
         */

        /**
         * Constructs a new FeeInfo.
         * @memberof cash
         * @classdesc message processed
         * @implements IFeeInfo
         * @constructor
         * @param {cash.IFeeInfo=} [properties] Properties to set
         */
        function FeeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeInfo payer.
         * @member {Uint8Array} payer
         * @memberof cash.FeeInfo
         * @instance
         */
        FeeInfo.prototype.payer = $util.newBuffer([]);

        /**
         * FeeInfo fees.
         * @member {coin.ICoin|null|undefined} fees
         * @memberof cash.FeeInfo
         * @instance
         */
        FeeInfo.prototype.fees = null;

        /**
         * Creates a new FeeInfo instance using the specified properties.
         * @function create
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo=} [properties] Properties to set
         * @returns {cash.FeeInfo} FeeInfo instance
         */
        FeeInfo.create = function create(properties) {
            return new FeeInfo(properties);
        };

        /**
         * Encodes the specified FeeInfo message. Does not implicitly {@link cash.FeeInfo.verify|verify} messages.
         * @function encode
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo} message FeeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payer != null && message.hasOwnProperty("payer"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payer);
            if (message.fees != null && message.hasOwnProperty("fees"))
                $root.coin.Coin.encode(message.fees, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeInfo message, length delimited. Does not implicitly {@link cash.FeeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo} message FeeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof cash.FeeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.FeeInfo} FeeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.FeeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.payer = reader.bytes();
                    break;
                case 3:
                    message.fees = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.FeeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.FeeInfo} FeeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeInfo message.
         * @function verify
         * @memberof cash.FeeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payer != null && message.hasOwnProperty("payer"))
                if (!(message.payer && typeof message.payer.length === "number" || $util.isString(message.payer)))
                    return "payer: buffer expected";
            if (message.fees != null && message.hasOwnProperty("fees")) {
                var error = $root.coin.Coin.verify(message.fees);
                if (error)
                    return "fees." + error;
            }
            return null;
        };

        /**
         * Creates a FeeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.FeeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.FeeInfo} FeeInfo
         */
        FeeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.FeeInfo)
                return object;
            var message = new $root.cash.FeeInfo();
            if (object.payer != null)
                if (typeof object.payer === "string")
                    $util.base64.decode(object.payer, message.payer = $util.newBuffer($util.base64.length(object.payer)), 0);
                else if (object.payer.length)
                    message.payer = object.payer;
            if (object.fees != null) {
                if (typeof object.fees !== "object")
                    throw TypeError(".cash.FeeInfo.fees: object expected");
                message.fees = $root.coin.Coin.fromObject(object.fees);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.FeeInfo} message FeeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.payer = "";
                else {
                    object.payer = [];
                    if (options.bytes !== Array)
                        object.payer = $util.newBuffer(object.payer);
                }
                object.fees = null;
            }
            if (message.payer != null && message.hasOwnProperty("payer"))
                object.payer = options.bytes === String ? $util.base64.encode(message.payer, 0, message.payer.length) : options.bytes === Array ? Array.prototype.slice.call(message.payer) : message.payer;
            if (message.fees != null && message.hasOwnProperty("fees"))
                object.fees = $root.coin.Coin.toObject(message.fees, options);
            return object;
        };

        /**
         * Converts this FeeInfo to JSON.
         * @function toJSON
         * @memberof cash.FeeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeInfo;
    })();

    cash.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof cash
         * @interface IConfiguration
         * @property {weave.IMetadata|null} [metadata] Configuration metadata
         * @property {Uint8Array|null} [owner] needed to make use of gconf.NewUpdateConfigurationHandler
         * @property {Uint8Array|null} [collectorAddress] Configuration collectorAddress
         * @property {coin.ICoin|null} [minimalFee] Configuration minimalFee
         */

        /**
         * Constructs a new Configuration.
         * @memberof cash
         * @classdesc Represents a Configuration.
         * @implements IConfiguration
         * @constructor
         * @param {cash.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Configuration metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.metadata = null;

        /**
         * needed to make use of gconf.NewUpdateConfigurationHandler
         * @member {Uint8Array} owner
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.owner = $util.newBuffer([]);

        /**
         * Configuration collectorAddress.
         * @member {Uint8Array} collectorAddress
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.collectorAddress = $util.newBuffer([]);

        /**
         * Configuration minimalFee.
         * @member {coin.ICoin|null|undefined} minimalFee
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.minimalFee = null;

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration=} [properties] Properties to set
         * @returns {cash.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link cash.Configuration.verify|verify} messages.
         * @function encode
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.collectorAddress);
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee"))
                $root.coin.Coin.encode(message.minimalFee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link cash.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof cash.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = reader.bytes();
                    break;
                case 3:
                    message.collectorAddress = reader.bytes();
                    break;
                case 4:
                    message.minimalFee = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof cash.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                if (!(message.collectorAddress && typeof message.collectorAddress.length === "number" || $util.isString(message.collectorAddress)))
                    return "collectorAddress: buffer expected";
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee")) {
                var error = $root.coin.Coin.verify(message.minimalFee);
                if (error)
                    return "minimalFee." + error;
            }
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.Configuration)
                return object;
            var message = new $root.cash.Configuration();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.Configuration.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.collectorAddress != null)
                if (typeof object.collectorAddress === "string")
                    $util.base64.decode(object.collectorAddress, message.collectorAddress = $util.newBuffer($util.base64.length(object.collectorAddress)), 0);
                else if (object.collectorAddress.length)
                    message.collectorAddress = object.collectorAddress;
            if (object.minimalFee != null) {
                if (typeof object.minimalFee !== "object")
                    throw TypeError(".cash.Configuration.minimalFee: object expected");
                message.minimalFee = $root.coin.Coin.fromObject(object.minimalFee);
            }
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.Configuration
         * @static
         * @param {cash.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                if (options.bytes === String)
                    object.collectorAddress = "";
                else {
                    object.collectorAddress = [];
                    if (options.bytes !== Array)
                        object.collectorAddress = $util.newBuffer(object.collectorAddress);
                }
                object.minimalFee = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                object.collectorAddress = options.bytes === String ? $util.base64.encode(message.collectorAddress, 0, message.collectorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.collectorAddress) : message.collectorAddress;
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee"))
                object.minimalFee = $root.coin.Coin.toObject(message.minimalFee, options);
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof cash.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    cash.UpdateConfigurationMsg = (function() {

        /**
         * Properties of an UpdateConfigurationMsg.
         * @memberof cash
         * @interface IUpdateConfigurationMsg
         * @property {weave.IMetadata|null} [metadata] UpdateConfigurationMsg metadata
         * @property {cash.IConfiguration|null} [patch] UpdateConfigurationMsg patch
         */

        /**
         * Constructs a new UpdateConfigurationMsg.
         * @memberof cash
         * @classdesc Represents an UpdateConfigurationMsg.
         * @implements IUpdateConfigurationMsg
         * @constructor
         * @param {cash.IUpdateConfigurationMsg=} [properties] Properties to set
         */
        function UpdateConfigurationMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConfigurationMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.metadata = null;

        /**
         * UpdateConfigurationMsg patch.
         * @member {cash.IConfiguration|null|undefined} patch
         * @memberof cash.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.patch = null;

        /**
         * Creates a new UpdateConfigurationMsg instance using the specified properties.
         * @function create
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {cash.IUpdateConfigurationMsg=} [properties] Properties to set
         * @returns {cash.UpdateConfigurationMsg} UpdateConfigurationMsg instance
         */
        UpdateConfigurationMsg.create = function create(properties) {
            return new UpdateConfigurationMsg(properties);
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message. Does not implicitly {@link cash.UpdateConfigurationMsg.verify|verify} messages.
         * @function encode
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {cash.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.patch != null && message.hasOwnProperty("patch"))
                $root.cash.Configuration.encode(message.patch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message, length delimited. Does not implicitly {@link cash.UpdateConfigurationMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {cash.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer.
         * @function decode
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.UpdateConfigurationMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.patch = $root.cash.Configuration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConfigurationMsg message.
         * @function verify
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConfigurationMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.patch != null && message.hasOwnProperty("patch")) {
                var error = $root.cash.Configuration.verify(message.patch);
                if (error)
                    return "patch." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConfigurationMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.UpdateConfigurationMsg} UpdateConfigurationMsg
         */
        UpdateConfigurationMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.UpdateConfigurationMsg)
                return object;
            var message = new $root.cash.UpdateConfigurationMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.UpdateConfigurationMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.patch != null) {
                if (typeof object.patch !== "object")
                    throw TypeError(".cash.UpdateConfigurationMsg.patch: object expected");
                message.patch = $root.cash.Configuration.fromObject(object.patch);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConfigurationMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.UpdateConfigurationMsg
         * @static
         * @param {cash.UpdateConfigurationMsg} message UpdateConfigurationMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConfigurationMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.patch = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = $root.cash.Configuration.toObject(message.patch, options);
            return object;
        };

        /**
         * Converts this UpdateConfigurationMsg to JSON.
         * @function toJSON
         * @memberof cash.UpdateConfigurationMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConfigurationMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConfigurationMsg;
    })();

    return cash;
})();

$root.cron = (function() {

    /**
     * Namespace cron.
     * @exports cron
     * @namespace
     */
    var cron = {};

    cron.TaskResult = (function() {

        /**
         * Properties of a TaskResult.
         * @memberof cron
         * @interface ITaskResult
         * @property {weave.IMetadata|null} [metadata] TaskResult metadata
         * @property {boolean|null} [successful] Successful is set to true if the task was successfully executed.
         * @property {string|null} [info] about the task execution.
         * @property {number|Long|null} [execTime] Exec time hold the information of when the task was executed.
         * @property {number|Long|null} [execHeight] Exec height holds the block height value at the time the task was executed.
         */

        /**
         * Constructs a new TaskResult.
         * @memberof cron
         * @classdesc https://github.com/tendermint/tendermint/issues/3665
         * @implements ITaskResult
         * @constructor
         * @param {cron.ITaskResult=} [properties] Properties to set
         */
        function TaskResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskResult metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cron.TaskResult
         * @instance
         */
        TaskResult.prototype.metadata = null;

        /**
         * Successful is set to true if the task was successfully executed.
         * @member {boolean} successful
         * @memberof cron.TaskResult
         * @instance
         */
        TaskResult.prototype.successful = false;

        /**
         * about the task execution.
         * @member {string} info
         * @memberof cron.TaskResult
         * @instance
         */
        TaskResult.prototype.info = "";

        /**
         * Exec time hold the information of when the task was executed.
         * @member {number|Long} execTime
         * @memberof cron.TaskResult
         * @instance
         */
        TaskResult.prototype.execTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exec height holds the block height value at the time the task was executed.
         * @member {number|Long} execHeight
         * @memberof cron.TaskResult
         * @instance
         */
        TaskResult.prototype.execHeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TaskResult instance using the specified properties.
         * @function create
         * @memberof cron.TaskResult
         * @static
         * @param {cron.ITaskResult=} [properties] Properties to set
         * @returns {cron.TaskResult} TaskResult instance
         */
        TaskResult.create = function create(properties) {
            return new TaskResult(properties);
        };

        /**
         * Encodes the specified TaskResult message. Does not implicitly {@link cron.TaskResult.verify|verify} messages.
         * @function encode
         * @memberof cron.TaskResult
         * @static
         * @param {cron.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.successful != null && message.hasOwnProperty("successful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.successful);
            if (message.info != null && message.hasOwnProperty("info"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.info);
            if (message.execTime != null && message.hasOwnProperty("execTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.execTime);
            if (message.execHeight != null && message.hasOwnProperty("execHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.execHeight);
            return writer;
        };

        /**
         * Encodes the specified TaskResult message, length delimited. Does not implicitly {@link cron.TaskResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cron.TaskResult
         * @static
         * @param {cron.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer.
         * @function decode
         * @memberof cron.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cron.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cron.TaskResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.successful = reader.bool();
                    break;
                case 3:
                    message.info = reader.string();
                    break;
                case 4:
                    message.execTime = reader.int64();
                    break;
                case 5:
                    message.execHeight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cron.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cron.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskResult message.
         * @function verify
         * @memberof cron.TaskResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.successful != null && message.hasOwnProperty("successful"))
                if (typeof message.successful !== "boolean")
                    return "successful: boolean expected";
            if (message.info != null && message.hasOwnProperty("info"))
                if (!$util.isString(message.info))
                    return "info: string expected";
            if (message.execTime != null && message.hasOwnProperty("execTime"))
                if (!$util.isInteger(message.execTime) && !(message.execTime && $util.isInteger(message.execTime.low) && $util.isInteger(message.execTime.high)))
                    return "execTime: integer|Long expected";
            if (message.execHeight != null && message.hasOwnProperty("execHeight"))
                if (!$util.isInteger(message.execHeight) && !(message.execHeight && $util.isInteger(message.execHeight.low) && $util.isInteger(message.execHeight.high)))
                    return "execHeight: integer|Long expected";
            return null;
        };

        /**
         * Creates a TaskResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cron.TaskResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cron.TaskResult} TaskResult
         */
        TaskResult.fromObject = function fromObject(object) {
            if (object instanceof $root.cron.TaskResult)
                return object;
            var message = new $root.cron.TaskResult();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cron.TaskResult.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.successful != null)
                message.successful = Boolean(object.successful);
            if (object.info != null)
                message.info = String(object.info);
            if (object.execTime != null)
                if ($util.Long)
                    (message.execTime = $util.Long.fromValue(object.execTime)).unsigned = false;
                else if (typeof object.execTime === "string")
                    message.execTime = parseInt(object.execTime, 10);
                else if (typeof object.execTime === "number")
                    message.execTime = object.execTime;
                else if (typeof object.execTime === "object")
                    message.execTime = new $util.LongBits(object.execTime.low >>> 0, object.execTime.high >>> 0).toNumber();
            if (object.execHeight != null)
                if ($util.Long)
                    (message.execHeight = $util.Long.fromValue(object.execHeight)).unsigned = false;
                else if (typeof object.execHeight === "string")
                    message.execHeight = parseInt(object.execHeight, 10);
                else if (typeof object.execHeight === "number")
                    message.execHeight = object.execHeight;
                else if (typeof object.execHeight === "object")
                    message.execHeight = new $util.LongBits(object.execHeight.low >>> 0, object.execHeight.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TaskResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cron.TaskResult
         * @static
         * @param {cron.TaskResult} message TaskResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.successful = false;
                object.info = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.execTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.execTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.execHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.execHeight = options.longs === String ? "0" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.successful != null && message.hasOwnProperty("successful"))
                object.successful = message.successful;
            if (message.info != null && message.hasOwnProperty("info"))
                object.info = message.info;
            if (message.execTime != null && message.hasOwnProperty("execTime"))
                if (typeof message.execTime === "number")
                    object.execTime = options.longs === String ? String(message.execTime) : message.execTime;
                else
                    object.execTime = options.longs === String ? $util.Long.prototype.toString.call(message.execTime) : options.longs === Number ? new $util.LongBits(message.execTime.low >>> 0, message.execTime.high >>> 0).toNumber() : message.execTime;
            if (message.execHeight != null && message.hasOwnProperty("execHeight"))
                if (typeof message.execHeight === "number")
                    object.execHeight = options.longs === String ? String(message.execHeight) : message.execHeight;
                else
                    object.execHeight = options.longs === String ? $util.Long.prototype.toString.call(message.execHeight) : options.longs === Number ? new $util.LongBits(message.execHeight.low >>> 0, message.execHeight.high >>> 0).toNumber() : message.execHeight;
            return object;
        };

        /**
         * Converts this TaskResult to JSON.
         * @function toJSON
         * @memberof cron.TaskResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TaskResult;
    })();

    return cron;
})();

$root.currency = (function() {

    /**
     * Namespace currency.
     * @exports currency
     * @namespace
     */
    var currency = {};

    currency.TokenInfo = (function() {

        /**
         * Properties of a TokenInfo.
         * @memberof currency
         * @interface ITokenInfo
         * @property {weave.IMetadata|null} [metadata] TokenInfo metadata
         * @property {string|null} [name] TokenInfo name
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof currency
         * @classdesc alternative solution to hardcoding supported currencies information.
         * @implements ITokenInfo
         * @constructor
         * @param {currency.ITokenInfo=} [properties] Properties to set
         */
        function TokenInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenInfo metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof currency.TokenInfo
         * @instance
         */
        TokenInfo.prototype.metadata = null;

        /**
         * TokenInfo name.
         * @member {string} name
         * @memberof currency.TokenInfo
         * @instance
         */
        TokenInfo.prototype.name = "";

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo=} [properties] Properties to set
         * @returns {currency.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link currency.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified TokenInfo message, length delimited. Does not implicitly {@link currency.TokenInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof currency.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {currency.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.currency.TokenInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof currency.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {currency.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenInfo message.
         * @function verify
         * @memberof currency.TokenInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a TokenInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof currency.TokenInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {currency.TokenInfo} TokenInfo
         */
        TokenInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.currency.TokenInfo)
                return object;
            var message = new $root.currency.TokenInfo();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".currency.TokenInfo.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a TokenInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.TokenInfo} message TokenInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this TokenInfo to JSON.
         * @function toJSON
         * @memberof currency.TokenInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenInfo;
    })();

    currency.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof currency
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {string|null} [ticker] CreateMsg ticker
         * @property {string|null} [name] CreateMsg name
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof currency
         * @classdesc be registered only once.
         * @implements ICreateMsg
         * @constructor
         * @param {currency.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof currency.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * CreateMsg ticker.
         * @member {string} ticker
         * @memberof currency.CreateMsg
         * @instance
         */
        CreateMsg.prototype.ticker = "";

        /**
         * CreateMsg name.
         * @member {string} name
         * @memberof currency.CreateMsg
         * @instance
         */
        CreateMsg.prototype.name = "";

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof currency.CreateMsg
         * @static
         * @param {currency.ICreateMsg=} [properties] Properties to set
         * @returns {currency.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link currency.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof currency.CreateMsg
         * @static
         * @param {currency.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticker);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link currency.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof currency.CreateMsg
         * @static
         * @param {currency.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof currency.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {currency.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.currency.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ticker = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof currency.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {currency.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof currency.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof currency.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {currency.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.currency.CreateMsg)
                return object;
            var message = new $root.currency.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".currency.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof currency.CreateMsg
         * @static
         * @param {currency.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.ticker = "";
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof currency.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    return currency;
})();

$root.distribution = (function() {

    /**
     * Namespace distribution.
     * @exports distribution
     * @namespace
     */
    var distribution = {};

    distribution.Revenue = (function() {

        /**
         * Properties of a Revenue.
         * @memberof distribution
         * @interface IRevenue
         * @property {weave.IMetadata|null} [metadata] Revenue metadata
         * @property {Uint8Array|null} [admin] While not enforced it is best to use a multisig contract here.
         * @property {Array.<distribution.IDestination>|null} [destinations] distributed to. Must be at least one.
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new Revenue.
         * @memberof distribution
         * @classdesc the owners.
         * @implements IRevenue
         * @constructor
         * @param {distribution.IRevenue=} [properties] Properties to set
         */
        function Revenue(properties) {
            this.destinations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Revenue metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.metadata = null;

        /**
         * While not enforced it is best to use a multisig contract here.
         * @member {Uint8Array} admin
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.admin = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IDestination>} destinations
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.destinations = $util.emptyArray;

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new Revenue instance using the specified properties.
         * @function create
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue=} [properties] Properties to set
         * @returns {distribution.Revenue} Revenue instance
         */
        Revenue.create = function create(properties) {
            return new Revenue(properties);
        };

        /**
         * Encodes the specified Revenue message. Does not implicitly {@link distribution.Revenue.verify|verify} messages.
         * @function encode
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue} message Revenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Revenue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            if (message.destinations != null && message.destinations.length)
                for (var i = 0; i < message.destinations.length; ++i)
                    $root.distribution.Destination.encode(message.destinations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified Revenue message, length delimited. Does not implicitly {@link distribution.Revenue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue} message Revenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Revenue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Revenue message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.Revenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.Revenue} Revenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Revenue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.Revenue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.admin = reader.bytes();
                    break;
                case 3:
                    if (!(message.destinations && message.destinations.length))
                        message.destinations = [];
                    message.destinations.push($root.distribution.Destination.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Revenue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.Revenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.Revenue} Revenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Revenue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Revenue message.
         * @function verify
         * @memberof distribution.Revenue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Revenue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.destinations != null && message.hasOwnProperty("destinations")) {
                if (!Array.isArray(message.destinations))
                    return "destinations: array expected";
                for (var i = 0; i < message.destinations.length; ++i) {
                    var error = $root.distribution.Destination.verify(message.destinations[i]);
                    if (error)
                        return "destinations." + error;
                }
            }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates a Revenue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.Revenue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.Revenue} Revenue
         */
        Revenue.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.Revenue)
                return object;
            var message = new $root.distribution.Revenue();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.Revenue.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.destinations) {
                if (!Array.isArray(object.destinations))
                    throw TypeError(".distribution.Revenue.destinations: array expected");
                message.destinations = [];
                for (var i = 0; i < object.destinations.length; ++i) {
                    if (typeof object.destinations[i] !== "object")
                        throw TypeError(".distribution.Revenue.destinations: object expected");
                    message.destinations[i] = $root.distribution.Destination.fromObject(object.destinations[i]);
                }
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from a Revenue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.Revenue} message Revenue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Revenue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.destinations = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.destinations && message.destinations.length) {
                object.destinations = [];
                for (var j = 0; j < message.destinations.length; ++j)
                    object.destinations[j] = $root.distribution.Destination.toObject(message.destinations[j], options);
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this Revenue to JSON.
         * @function toJSON
         * @memberof distribution.Revenue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Revenue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Revenue;
    })();

    distribution.Destination = (function() {

        /**
         * Properties of a Destination.
         * @memberof distribution
         * @interface IDestination
         * @property {Uint8Array|null} [address] of the validators.
         * @property {number|null} [weight] second one.
         */

        /**
         * Constructs a new Destination.
         * @memberof distribution
         * @classdesc Represents a Destination.
         * @implements IDestination
         * @constructor
         * @param {distribution.IDestination=} [properties] Properties to set
         */
        function Destination(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * of the validators.
         * @member {Uint8Array} address
         * @memberof distribution.Destination
         * @instance
         */
        Destination.prototype.address = $util.newBuffer([]);

        /**
         * second one.
         * @member {number} weight
         * @memberof distribution.Destination
         * @instance
         */
        Destination.prototype.weight = 0;

        /**
         * Creates a new Destination instance using the specified properties.
         * @function create
         * @memberof distribution.Destination
         * @static
         * @param {distribution.IDestination=} [properties] Properties to set
         * @returns {distribution.Destination} Destination instance
         */
        Destination.create = function create(properties) {
            return new Destination(properties);
        };

        /**
         * Encodes the specified Destination message. Does not implicitly {@link distribution.Destination.verify|verify} messages.
         * @function encode
         * @memberof distribution.Destination
         * @static
         * @param {distribution.IDestination} message Destination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Destination.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Destination message, length delimited. Does not implicitly {@link distribution.Destination.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.Destination
         * @static
         * @param {distribution.IDestination} message Destination message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Destination.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Destination message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.Destination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.Destination} Destination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Destination.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.Destination();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Destination message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.Destination
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.Destination} Destination
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Destination.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Destination message.
         * @function verify
         * @memberof distribution.Destination
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Destination.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates a Destination message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.Destination
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.Destination} Destination
         */
        Destination.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.Destination)
                return object;
            var message = new $root.distribution.Destination();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                message.weight = object.weight | 0;
            return message;
        };

        /**
         * Creates a plain object from a Destination message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.Destination
         * @static
         * @param {distribution.Destination} message Destination
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Destination.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.weight = 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Destination to JSON.
         * @function toJSON
         * @memberof distribution.Destination
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Destination.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Destination;
    })();

    distribution.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof distribution
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {Uint8Array|null} [admin] While not enforced it is best to use a multisig contract here.
         * @property {Array.<distribution.IDestination>|null} [destinations] distributed to. Must be at least one.
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof distribution
         * @classdesc CreateMsg is issuing the creation of a new revenue stream instance.
         * @implements ICreateMsg
         * @constructor
         * @param {distribution.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            this.destinations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * While not enforced it is best to use a multisig contract here.
         * @member {Uint8Array} admin
         * @memberof distribution.CreateMsg
         * @instance
         */
        CreateMsg.prototype.admin = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IDestination>} destinations
         * @memberof distribution.CreateMsg
         * @instance
         */
        CreateMsg.prototype.destinations = $util.emptyArray;

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof distribution.CreateMsg
         * @static
         * @param {distribution.ICreateMsg=} [properties] Properties to set
         * @returns {distribution.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link distribution.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.CreateMsg
         * @static
         * @param {distribution.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            if (message.destinations != null && message.destinations.length)
                for (var i = 0; i < message.destinations.length; ++i)
                    $root.distribution.Destination.encode(message.destinations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link distribution.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.CreateMsg
         * @static
         * @param {distribution.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.admin = reader.bytes();
                    break;
                case 3:
                    if (!(message.destinations && message.destinations.length))
                        message.destinations = [];
                    message.destinations.push($root.distribution.Destination.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof distribution.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.destinations != null && message.hasOwnProperty("destinations")) {
                if (!Array.isArray(message.destinations))
                    return "destinations: array expected";
                for (var i = 0; i < message.destinations.length; ++i) {
                    var error = $root.distribution.Destination.verify(message.destinations[i]);
                    if (error)
                        return "destinations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.CreateMsg)
                return object;
            var message = new $root.distribution.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.destinations) {
                if (!Array.isArray(object.destinations))
                    throw TypeError(".distribution.CreateMsg.destinations: array expected");
                message.destinations = [];
                for (var i = 0; i < object.destinations.length; ++i) {
                    if (typeof object.destinations[i] !== "object")
                        throw TypeError(".distribution.CreateMsg.destinations: object expected");
                    message.destinations[i] = $root.distribution.Destination.fromObject(object.destinations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.CreateMsg
         * @static
         * @param {distribution.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.destinations = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.destinations && message.destinations.length) {
                object.destinations = [];
                for (var j = 0; j < message.destinations.length; ++j)
                    object.destinations[j] = $root.distribution.Destination.toObject(message.destinations[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof distribution.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    distribution.DistributeMsg = (function() {

        /**
         * Properties of a DistributeMsg.
         * @memberof distribution
         * @interface IDistributeMsg
         * @property {weave.IMetadata|null} [metadata] DistributeMsg metadata
         * @property {Uint8Array|null} [revenueId] should be distributed between destinations.
         */

        /**
         * Constructs a new DistributeMsg.
         * @memberof distribution
         * @classdesc signed using admin key.
         * @implements IDistributeMsg
         * @constructor
         * @param {distribution.IDistributeMsg=} [properties] Properties to set
         */
        function DistributeMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DistributeMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.DistributeMsg
         * @instance
         */
        DistributeMsg.prototype.metadata = null;

        /**
         * should be distributed between destinations.
         * @member {Uint8Array} revenueId
         * @memberof distribution.DistributeMsg
         * @instance
         */
        DistributeMsg.prototype.revenueId = $util.newBuffer([]);

        /**
         * Creates a new DistributeMsg instance using the specified properties.
         * @function create
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg=} [properties] Properties to set
         * @returns {distribution.DistributeMsg} DistributeMsg instance
         */
        DistributeMsg.create = function create(properties) {
            return new DistributeMsg(properties);
        };

        /**
         * Encodes the specified DistributeMsg message. Does not implicitly {@link distribution.DistributeMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg} message DistributeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DistributeMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.revenueId);
            return writer;
        };

        /**
         * Encodes the specified DistributeMsg message, length delimited. Does not implicitly {@link distribution.DistributeMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg} message DistributeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DistributeMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DistributeMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.DistributeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.DistributeMsg} DistributeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DistributeMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.DistributeMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.revenueId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DistributeMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.DistributeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.DistributeMsg} DistributeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DistributeMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DistributeMsg message.
         * @function verify
         * @memberof distribution.DistributeMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DistributeMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                if (!(message.revenueId && typeof message.revenueId.length === "number" || $util.isString(message.revenueId)))
                    return "revenueId: buffer expected";
            return null;
        };

        /**
         * Creates a DistributeMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.DistributeMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.DistributeMsg} DistributeMsg
         */
        DistributeMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.DistributeMsg)
                return object;
            var message = new $root.distribution.DistributeMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.DistributeMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.revenueId != null)
                if (typeof object.revenueId === "string")
                    $util.base64.decode(object.revenueId, message.revenueId = $util.newBuffer($util.base64.length(object.revenueId)), 0);
                else if (object.revenueId.length)
                    message.revenueId = object.revenueId;
            return message;
        };

        /**
         * Creates a plain object from a DistributeMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.DistributeMsg} message DistributeMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DistributeMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.revenueId = "";
                else {
                    object.revenueId = [];
                    if (options.bytes !== Array)
                        object.revenueId = $util.newBuffer(object.revenueId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                object.revenueId = options.bytes === String ? $util.base64.encode(message.revenueId, 0, message.revenueId.length) : options.bytes === Array ? Array.prototype.slice.call(message.revenueId) : message.revenueId;
            return object;
        };

        /**
         * Converts this DistributeMsg to JSON.
         * @function toJSON
         * @memberof distribution.DistributeMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DistributeMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DistributeMsg;
    })();

    distribution.ResetMsg = (function() {

        /**
         * Properties of a ResetMsg.
         * @memberof distribution
         * @interface IResetMsg
         * @property {weave.IMetadata|null} [metadata] ResetMsg metadata
         * @property {Uint8Array|null} [revenueId] Revenue ID reference an ID of a revenue instance that is updated.
         * @property {Array.<distribution.IDestination>|null} [destinations] distributed to. Must be at least one.
         */

        /**
         * Constructs a new ResetMsg.
         * @memberof distribution
         * @classdesc collected revenue amount is equal to zero the change is applied.
         * @implements IResetMsg
         * @constructor
         * @param {distribution.IResetMsg=} [properties] Properties to set
         */
        function ResetMsg(properties) {
            this.destinations = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResetMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.ResetMsg
         * @instance
         */
        ResetMsg.prototype.metadata = null;

        /**
         * Revenue ID reference an ID of a revenue instance that is updated.
         * @member {Uint8Array} revenueId
         * @memberof distribution.ResetMsg
         * @instance
         */
        ResetMsg.prototype.revenueId = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IDestination>} destinations
         * @memberof distribution.ResetMsg
         * @instance
         */
        ResetMsg.prototype.destinations = $util.emptyArray;

        /**
         * Creates a new ResetMsg instance using the specified properties.
         * @function create
         * @memberof distribution.ResetMsg
         * @static
         * @param {distribution.IResetMsg=} [properties] Properties to set
         * @returns {distribution.ResetMsg} ResetMsg instance
         */
        ResetMsg.create = function create(properties) {
            return new ResetMsg(properties);
        };

        /**
         * Encodes the specified ResetMsg message. Does not implicitly {@link distribution.ResetMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.ResetMsg
         * @static
         * @param {distribution.IResetMsg} message ResetMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.revenueId);
            if (message.destinations != null && message.destinations.length)
                for (var i = 0; i < message.destinations.length; ++i)
                    $root.distribution.Destination.encode(message.destinations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResetMsg message, length delimited. Does not implicitly {@link distribution.ResetMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.ResetMsg
         * @static
         * @param {distribution.IResetMsg} message ResetMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResetMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.ResetMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.ResetMsg} ResetMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.ResetMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.revenueId = reader.bytes();
                    break;
                case 3:
                    if (!(message.destinations && message.destinations.length))
                        message.destinations = [];
                    message.destinations.push($root.distribution.Destination.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResetMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.ResetMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.ResetMsg} ResetMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResetMsg message.
         * @function verify
         * @memberof distribution.ResetMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                if (!(message.revenueId && typeof message.revenueId.length === "number" || $util.isString(message.revenueId)))
                    return "revenueId: buffer expected";
            if (message.destinations != null && message.hasOwnProperty("destinations")) {
                if (!Array.isArray(message.destinations))
                    return "destinations: array expected";
                for (var i = 0; i < message.destinations.length; ++i) {
                    var error = $root.distribution.Destination.verify(message.destinations[i]);
                    if (error)
                        return "destinations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResetMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.ResetMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.ResetMsg} ResetMsg
         */
        ResetMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.ResetMsg)
                return object;
            var message = new $root.distribution.ResetMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.ResetMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.revenueId != null)
                if (typeof object.revenueId === "string")
                    $util.base64.decode(object.revenueId, message.revenueId = $util.newBuffer($util.base64.length(object.revenueId)), 0);
                else if (object.revenueId.length)
                    message.revenueId = object.revenueId;
            if (object.destinations) {
                if (!Array.isArray(object.destinations))
                    throw TypeError(".distribution.ResetMsg.destinations: array expected");
                message.destinations = [];
                for (var i = 0; i < object.destinations.length; ++i) {
                    if (typeof object.destinations[i] !== "object")
                        throw TypeError(".distribution.ResetMsg.destinations: object expected");
                    message.destinations[i] = $root.distribution.Destination.fromObject(object.destinations[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResetMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.ResetMsg
         * @static
         * @param {distribution.ResetMsg} message ResetMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.destinations = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.revenueId = "";
                else {
                    object.revenueId = [];
                    if (options.bytes !== Array)
                        object.revenueId = $util.newBuffer(object.revenueId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                object.revenueId = options.bytes === String ? $util.base64.encode(message.revenueId, 0, message.revenueId.length) : options.bytes === Array ? Array.prototype.slice.call(message.revenueId) : message.revenueId;
            if (message.destinations && message.destinations.length) {
                object.destinations = [];
                for (var j = 0; j < message.destinations.length; ++j)
                    object.destinations[j] = $root.distribution.Destination.toObject(message.destinations[j], options);
            }
            return object;
        };

        /**
         * Converts this ResetMsg to JSON.
         * @function toJSON
         * @memberof distribution.ResetMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResetMsg;
    })();

    return distribution;
})();

$root.escrow = (function() {

    /**
     * Namespace escrow.
     * @exports escrow
     * @namespace
     */
    var escrow = {};

    escrow.Escrow = (function() {

        /**
         * Properties of an Escrow.
         * @memberof escrow
         * @interface IEscrow
         * @property {weave.IMetadata|null} [metadata] Escrow metadata
         * @property {Uint8Array|null} [source] Escrow source
         * @property {Uint8Array|null} [arbiter] Escrow arbiter
         * @property {Uint8Array|null} [destination] Escrow destination
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] max length 128 character
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new Escrow.
         * @memberof escrow
         * @classdesc Upon timeout, they will be returned to the source.
         * @implements IEscrow
         * @constructor
         * @param {escrow.IEscrow=} [properties] Properties to set
         */
        function Escrow(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Escrow metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.metadata = null;

        /**
         * Escrow source.
         * @member {Uint8Array} source
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.source = $util.newBuffer([]);

        /**
         * Escrow arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.arbiter = $util.newBuffer([]);

        /**
         * Escrow destination.
         * @member {Uint8Array} destination
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.destination = $util.newBuffer([]);

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.memo = "";

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new Escrow instance using the specified properties.
         * @function create
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow=} [properties] Properties to set
         * @returns {escrow.Escrow} Escrow instance
         */
        Escrow.create = function create(properties) {
            return new Escrow(properties);
        };

        /**
         * Encodes the specified Escrow message. Does not implicitly {@link escrow.Escrow.verify|verify} messages.
         * @function encode
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow} message Escrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Escrow.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.arbiter);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.destination);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified Escrow message, length delimited. Does not implicitly {@link escrow.Escrow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow} message Escrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Escrow.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Escrow message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.Escrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.Escrow} Escrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Escrow.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.Escrow();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.arbiter = reader.bytes();
                    break;
                case 4:
                    message.destination = reader.bytes();
                    break;
                case 5:
                    message.timeout = reader.int64();
                    break;
                case 6:
                    message.memo = reader.string();
                    break;
                case 7:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Escrow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.Escrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.Escrow} Escrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Escrow.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Escrow message.
         * @function verify
         * @memberof escrow.Escrow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Escrow.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates an Escrow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.Escrow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.Escrow} Escrow
         */
        Escrow.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.Escrow)
                return object;
            var message = new $root.escrow.Escrow();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.Escrow.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from an Escrow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.Escrow} message Escrow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Escrow.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this Escrow to JSON.
         * @function toJSON
         * @memberof escrow.Escrow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Escrow.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Escrow;
    })();

    escrow.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof escrow
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {Uint8Array|null} [source] CreateMsg source
         * @property {Uint8Array|null} [arbiter] CreateMsg arbiter
         * @property {Uint8Array|null} [destination] CreateMsg destination
         * @property {Array.<coin.ICoin>|null} [amount] amount may contain multiple token types
         * @property {number|Long|null} [timeout] Timeout represents wall clock time.
         * @property {string|null} [memo] max length 128 character
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof escrow
         * @classdesc The rest must be defined
         * @implements ICreateMsg
         * @constructor
         * @param {escrow.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * CreateMsg source.
         * @member {Uint8Array} source
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.source = $util.newBuffer([]);

        /**
         * CreateMsg arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.arbiter = $util.newBuffer([]);

        /**
         * CreateMsg destination.
         * @member {Uint8Array} destination
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.destination = $util.newBuffer([]);

        /**
         * amount may contain multiple token types
         * @member {Array.<coin.ICoin>} amount
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.amount = $util.emptyArray;

        /**
         * Timeout represents wall clock time.
         * @member {number|Long} timeout
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof escrow.CreateMsg
         * @instance
         */
        CreateMsg.prototype.memo = "";

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof escrow.CreateMsg
         * @static
         * @param {escrow.ICreateMsg=} [properties] Properties to set
         * @returns {escrow.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link escrow.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.CreateMsg
         * @static
         * @param {escrow.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.arbiter);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.destination);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link escrow.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.CreateMsg
         * @static
         * @param {escrow.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.arbiter = reader.bytes();
                    break;
                case 4:
                    message.destination = reader.bytes();
                    break;
                case 5:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof escrow.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.CreateMsg)
                return object;
            var message = new $root.escrow.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".escrow.CreateMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".escrow.CreateMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.CreateMsg
         * @static
         * @param {escrow.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof escrow.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    escrow.ReleaseMsg = (function() {

        /**
         * Properties of a ReleaseMsg.
         * @memberof escrow
         * @interface IReleaseMsg
         * @property {weave.IMetadata|null} [metadata] ReleaseMsg metadata
         * @property {Uint8Array|null} [escrowId] ReleaseMsg escrowId
         * @property {Array.<coin.ICoin>|null} [amount] ReleaseMsg amount
         */

        /**
         * Constructs a new ReleaseMsg.
         * @memberof escrow
         * @classdesc May be a subset of the current balance.
         * @implements IReleaseMsg
         * @constructor
         * @param {escrow.IReleaseMsg=} [properties] Properties to set
         */
        function ReleaseMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReleaseMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.metadata = null;

        /**
         * ReleaseMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * ReleaseMsg amount.
         * @member {Array.<coin.ICoin>} amount
         * @memberof escrow.ReleaseMsg
         * @instance
         */
        ReleaseMsg.prototype.amount = $util.emptyArray;

        /**
         * Creates a new ReleaseMsg instance using the specified properties.
         * @function create
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {escrow.IReleaseMsg=} [properties] Properties to set
         * @returns {escrow.ReleaseMsg} ReleaseMsg instance
         */
        ReleaseMsg.create = function create(properties) {
            return new ReleaseMsg(properties);
        };

        /**
         * Encodes the specified ReleaseMsg message. Does not implicitly {@link escrow.ReleaseMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {escrow.IReleaseMsg} message ReleaseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReleaseMsg message, length delimited. Does not implicitly {@link escrow.ReleaseMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {escrow.IReleaseMsg} message ReleaseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.ReleaseMsg} ReleaseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.ReleaseMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                case 3:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.ReleaseMsg} ReleaseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseMsg message.
         * @function verify
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ReleaseMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.ReleaseMsg} ReleaseMsg
         */
        ReleaseMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.ReleaseMsg)
                return object;
            var message = new $root.escrow.ReleaseMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.ReleaseMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".escrow.ReleaseMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".escrow.ReleaseMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ReleaseMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.ReleaseMsg
         * @static
         * @param {escrow.ReleaseMsg} message ReleaseMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            return object;
        };

        /**
         * Converts this ReleaseMsg to JSON.
         * @function toJSON
         * @memberof escrow.ReleaseMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseMsg;
    })();

    escrow.ReturnMsg = (function() {

        /**
         * Properties of a ReturnMsg.
         * @memberof escrow
         * @interface IReturnMsg
         * @property {weave.IMetadata|null} [metadata] ReturnMsg metadata
         * @property {Uint8Array|null} [escrowId] ReturnMsg escrowId
         */

        /**
         * Constructs a new ReturnMsg.
         * @memberof escrow
         * @classdesc Must be authorized by the source or an expired timeout
         * @implements IReturnMsg
         * @constructor
         * @param {escrow.IReturnMsg=} [properties] Properties to set
         */
        function ReturnMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReturnMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.ReturnMsg
         * @instance
         */
        ReturnMsg.prototype.metadata = null;

        /**
         * ReturnMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.ReturnMsg
         * @instance
         */
        ReturnMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * Creates a new ReturnMsg instance using the specified properties.
         * @function create
         * @memberof escrow.ReturnMsg
         * @static
         * @param {escrow.IReturnMsg=} [properties] Properties to set
         * @returns {escrow.ReturnMsg} ReturnMsg instance
         */
        ReturnMsg.create = function create(properties) {
            return new ReturnMsg(properties);
        };

        /**
         * Encodes the specified ReturnMsg message. Does not implicitly {@link escrow.ReturnMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.ReturnMsg
         * @static
         * @param {escrow.IReturnMsg} message ReturnMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            return writer;
        };

        /**
         * Encodes the specified ReturnMsg message, length delimited. Does not implicitly {@link escrow.ReturnMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.ReturnMsg
         * @static
         * @param {escrow.IReturnMsg} message ReturnMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReturnMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.ReturnMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.ReturnMsg} ReturnMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.ReturnMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReturnMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.ReturnMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.ReturnMsg} ReturnMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReturnMsg message.
         * @function verify
         * @memberof escrow.ReturnMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReturnMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            return null;
        };

        /**
         * Creates a ReturnMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.ReturnMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.ReturnMsg} ReturnMsg
         */
        ReturnMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.ReturnMsg)
                return object;
            var message = new $root.escrow.ReturnMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.ReturnMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            return message;
        };

        /**
         * Creates a plain object from a ReturnMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.ReturnMsg
         * @static
         * @param {escrow.ReturnMsg} message ReturnMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReturnMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            return object;
        };

        /**
         * Converts this ReturnMsg to JSON.
         * @function toJSON
         * @memberof escrow.ReturnMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReturnMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReturnMsg;
    })();

    escrow.UpdatePartiesMsg = (function() {

        /**
         * Properties of an UpdatePartiesMsg.
         * @memberof escrow
         * @interface IUpdatePartiesMsg
         * @property {weave.IMetadata|null} [metadata] UpdatePartiesMsg metadata
         * @property {Uint8Array|null} [escrowId] UpdatePartiesMsg escrowId
         * @property {Uint8Array|null} [source] UpdatePartiesMsg source
         * @property {Uint8Array|null} [arbiter] UpdatePartiesMsg arbiter
         * @property {Uint8Array|null} [destination] UpdatePartiesMsg destination
         */

        /**
         * Constructs a new UpdatePartiesMsg.
         * @memberof escrow
         * @classdesc Represents delegating responsibility
         * @implements IUpdatePartiesMsg
         * @constructor
         * @param {escrow.IUpdatePartiesMsg=} [properties] Properties to set
         */
        function UpdatePartiesMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePartiesMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         */
        UpdatePartiesMsg.prototype.metadata = null;

        /**
         * UpdatePartiesMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         */
        UpdatePartiesMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * UpdatePartiesMsg source.
         * @member {Uint8Array} source
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         */
        UpdatePartiesMsg.prototype.source = $util.newBuffer([]);

        /**
         * UpdatePartiesMsg arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         */
        UpdatePartiesMsg.prototype.arbiter = $util.newBuffer([]);

        /**
         * UpdatePartiesMsg destination.
         * @member {Uint8Array} destination
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         */
        UpdatePartiesMsg.prototype.destination = $util.newBuffer([]);

        /**
         * Creates a new UpdatePartiesMsg instance using the specified properties.
         * @function create
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {escrow.IUpdatePartiesMsg=} [properties] Properties to set
         * @returns {escrow.UpdatePartiesMsg} UpdatePartiesMsg instance
         */
        UpdatePartiesMsg.create = function create(properties) {
            return new UpdatePartiesMsg(properties);
        };

        /**
         * Encodes the specified UpdatePartiesMsg message. Does not implicitly {@link escrow.UpdatePartiesMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {escrow.IUpdatePartiesMsg} message UpdatePartiesMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePartiesMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.source);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.arbiter);
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.destination);
            return writer;
        };

        /**
         * Encodes the specified UpdatePartiesMsg message, length delimited. Does not implicitly {@link escrow.UpdatePartiesMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {escrow.IUpdatePartiesMsg} message UpdatePartiesMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePartiesMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePartiesMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.UpdatePartiesMsg} UpdatePartiesMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePartiesMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.UpdatePartiesMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                case 3:
                    message.source = reader.bytes();
                    break;
                case 4:
                    message.arbiter = reader.bytes();
                    break;
                case 5:
                    message.destination = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePartiesMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.UpdatePartiesMsg} UpdatePartiesMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePartiesMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePartiesMsg message.
         * @function verify
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePartiesMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            return null;
        };

        /**
         * Creates an UpdatePartiesMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.UpdatePartiesMsg} UpdatePartiesMsg
         */
        UpdatePartiesMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.UpdatePartiesMsg)
                return object;
            var message = new $root.escrow.UpdatePartiesMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.UpdatePartiesMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            return message;
        };

        /**
         * Creates a plain object from an UpdatePartiesMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.UpdatePartiesMsg
         * @static
         * @param {escrow.UpdatePartiesMsg} message UpdatePartiesMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdatePartiesMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            return object;
        };

        /**
         * Converts this UpdatePartiesMsg to JSON.
         * @function toJSON
         * @memberof escrow.UpdatePartiesMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdatePartiesMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdatePartiesMsg;
    })();

    return escrow;
})();

$root.gov = (function() {

    /**
     * Namespace gov.
     * @exports gov
     * @namespace
     */
    var gov = {};

    gov.Electorate = (function() {

        /**
         * Properties of an Electorate.
         * @memberof gov
         * @interface IElectorate
         * @property {weave.IMetadata|null} [metadata] Electorate metadata
         * @property {number|null} [version] Document version
         * @property {Uint8Array|null} [admin] Admin is the address that is allowed ot modify an existing electorate.
         * @property {string|null} [title] Human readable title.
         * @property {Array.<gov.IElector>|null} [electors] Elector defines a list of all signatures that are allowed to participate in a vote
         * @property {number|Long|null} [totalElectorateWeight] TotalElectorateWeight is the sum of all electors weights.
         */

        /**
         * Constructs a new Electorate.
         * @memberof gov
         * @classdesc and is stored for re-use
         * @implements IElectorate
         * @constructor
         * @param {gov.IElectorate=} [properties] Properties to set
         */
        function Electorate(properties) {
            this.electors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Electorate metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.metadata = null;

        /**
         * Document version
         * @member {number} version
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.version = 0;

        /**
         * Admin is the address that is allowed ot modify an existing electorate.
         * @member {Uint8Array} admin
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.admin = $util.newBuffer([]);

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.title = "";

        /**
         * Elector defines a list of all signatures that are allowed to participate in a vote
         * @member {Array.<gov.IElector>} electors
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.electors = $util.emptyArray;

        /**
         * TotalElectorateWeight is the sum of all electors weights.
         * @member {number|Long} totalElectorateWeight
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.totalElectorateWeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Electorate instance using the specified properties.
         * @function create
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate=} [properties] Properties to set
         * @returns {gov.Electorate} Electorate instance
         */
        Electorate.create = function create(properties) {
            return new Electorate(properties);
        };

        /**
         * Encodes the specified Electorate message. Does not implicitly {@link gov.Electorate.verify|verify} messages.
         * @function encode
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate} message Electorate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Electorate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.admin);
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
            if (message.electors != null && message.electors.length)
                for (var i = 0; i < message.electors.length; ++i)
                    $root.gov.Elector.encode(message.electors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.totalElectorateWeight);
            return writer;
        };

        /**
         * Encodes the specified Electorate message, length delimited. Does not implicitly {@link gov.Electorate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate} message Electorate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Electorate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Electorate message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Electorate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Electorate} Electorate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Electorate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Electorate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.admin = reader.bytes();
                    break;
                case 4:
                    message.title = reader.string();
                    break;
                case 5:
                    if (!(message.electors && message.electors.length))
                        message.electors = [];
                    message.electors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.totalElectorateWeight = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Electorate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Electorate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Electorate} Electorate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Electorate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Electorate message.
         * @function verify
         * @memberof gov.Electorate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Electorate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.electors != null && message.hasOwnProperty("electors")) {
                if (!Array.isArray(message.electors))
                    return "electors: array expected";
                for (var i = 0; i < message.electors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.electors[i]);
                    if (error)
                        return "electors." + error;
                }
            }
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (!$util.isInteger(message.totalElectorateWeight) && !(message.totalElectorateWeight && $util.isInteger(message.totalElectorateWeight.low) && $util.isInteger(message.totalElectorateWeight.high)))
                    return "totalElectorateWeight: integer|Long expected";
            return null;
        };

        /**
         * Creates an Electorate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Electorate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Electorate} Electorate
         */
        Electorate.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Electorate)
                return object;
            var message = new $root.gov.Electorate();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Electorate.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.title != null)
                message.title = String(object.title);
            if (object.electors) {
                if (!Array.isArray(object.electors))
                    throw TypeError(".gov.Electorate.electors: array expected");
                message.electors = [];
                for (var i = 0; i < object.electors.length; ++i) {
                    if (typeof object.electors[i] !== "object")
                        throw TypeError(".gov.Electorate.electors: object expected");
                    message.electors[i] = $root.gov.Elector.fromObject(object.electors[i]);
                }
            }
            if (object.totalElectorateWeight != null)
                if ($util.Long)
                    (message.totalElectorateWeight = $util.Long.fromValue(object.totalElectorateWeight)).unsigned = true;
                else if (typeof object.totalElectorateWeight === "string")
                    message.totalElectorateWeight = parseInt(object.totalElectorateWeight, 10);
                else if (typeof object.totalElectorateWeight === "number")
                    message.totalElectorateWeight = object.totalElectorateWeight;
                else if (typeof object.totalElectorateWeight === "object")
                    message.totalElectorateWeight = new $util.LongBits(object.totalElectorateWeight.low >>> 0, object.totalElectorateWeight.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Electorate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Electorate
         * @static
         * @param {gov.Electorate} message Electorate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Electorate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.electors = [];
            if (options.defaults) {
                object.metadata = null;
                object.version = 0;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
                object.title = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalElectorateWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalElectorateWeight = options.longs === String ? "0" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.electors && message.electors.length) {
                object.electors = [];
                for (var j = 0; j < message.electors.length; ++j)
                    object.electors[j] = $root.gov.Elector.toObject(message.electors[j], options);
            }
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (typeof message.totalElectorateWeight === "number")
                    object.totalElectorateWeight = options.longs === String ? String(message.totalElectorateWeight) : message.totalElectorateWeight;
                else
                    object.totalElectorateWeight = options.longs === String ? $util.Long.prototype.toString.call(message.totalElectorateWeight) : options.longs === Number ? new $util.LongBits(message.totalElectorateWeight.low >>> 0, message.totalElectorateWeight.high >>> 0).toNumber(true) : message.totalElectorateWeight;
            return object;
        };

        /**
         * Converts this Electorate to JSON.
         * @function toJSON
         * @memberof gov.Electorate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Electorate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Electorate;
    })();

    gov.Elector = (function() {

        /**
         * Properties of an Elector.
         * @memberof gov
         * @interface IElector
         * @property {Uint8Array|null} [address] The address of the voter.
         * @property {number|null} [weight] Weight defines the power of the participants vote. max value is 65535 (2^16-1).
         */

        /**
         * Constructs a new Elector.
         * @memberof gov
         * @classdesc the greater the power of a participant.
         * @implements IElector
         * @constructor
         * @param {gov.IElector=} [properties] Properties to set
         */
        function Elector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address of the voter.
         * @member {Uint8Array} address
         * @memberof gov.Elector
         * @instance
         */
        Elector.prototype.address = $util.newBuffer([]);

        /**
         * Weight defines the power of the participants vote. max value is 65535 (2^16-1).
         * @member {number} weight
         * @memberof gov.Elector
         * @instance
         */
        Elector.prototype.weight = 0;

        /**
         * Creates a new Elector instance using the specified properties.
         * @function create
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector=} [properties] Properties to set
         * @returns {gov.Elector} Elector instance
         */
        Elector.create = function create(properties) {
            return new Elector(properties);
        };

        /**
         * Encodes the specified Elector message. Does not implicitly {@link gov.Elector.verify|verify} messages.
         * @function encode
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector} message Elector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Elector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Elector message, length delimited. Does not implicitly {@link gov.Elector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector} message Elector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Elector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Elector message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Elector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Elector} Elector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Elector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Elector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Elector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Elector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Elector} Elector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Elector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Elector message.
         * @function verify
         * @memberof gov.Elector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Elector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates an Elector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Elector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Elector} Elector
         */
        Elector.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Elector)
                return object;
            var message = new $root.gov.Elector();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                message.weight = object.weight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Elector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Elector
         * @static
         * @param {gov.Elector} message Elector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Elector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.weight = 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Elector to JSON.
         * @function toJSON
         * @memberof gov.Elector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Elector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Elector;
    })();

    gov.ElectionRule = (function() {

        /**
         * Properties of an ElectionRule.
         * @memberof gov
         * @interface IElectionRule
         * @property {weave.IMetadata|null} [metadata] ElectionRule metadata
         * @property {number|null} [version] Document version.
         * @property {Uint8Array|null} [admin] Admin is the address that is allowed to modify an existing election rule.
         * @property {Uint8Array|null} [electorateId] ElectorateID references the electorate using this rule (without version, as changing electorate changes the rule).
         * @property {string|null} [title] Human readable title.
         * @property {number|null} [votingPeriod] Duration in seconds of how long the voting period will take place.
         * @property {gov.IFraction|null} [threshold] of the eligible voters.
         * @property {gov.IFraction|null} [quorum] of the eligible voters.
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new ElectionRule.
         * @memberof gov
         * @classdesc Election Rule defines how an election is run. A proposal must be voted upon via a pre-defined ruleset.
         * @implements IElectionRule
         * @constructor
         * @param {gov.IElectionRule=} [properties] Properties to set
         */
        function ElectionRule(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ElectionRule metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.metadata = null;

        /**
         * Document version.
         * @member {number} version
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.version = 0;

        /**
         * Admin is the address that is allowed to modify an existing election rule.
         * @member {Uint8Array} admin
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.admin = $util.newBuffer([]);

        /**
         * ElectorateID references the electorate using this rule (without version, as changing electorate changes the rule).
         * @member {Uint8Array} electorateId
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.electorateId = $util.newBuffer([]);

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.title = "";

        /**
         * Duration in seconds of how long the voting period will take place.
         * @member {number} votingPeriod
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.votingPeriod = 0;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.threshold = null;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} quorum
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.quorum = null;

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new ElectionRule instance using the specified properties.
         * @function create
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule=} [properties] Properties to set
         * @returns {gov.ElectionRule} ElectionRule instance
         */
        ElectionRule.create = function create(properties) {
            return new ElectionRule(properties);
        };

        /**
         * Encodes the specified ElectionRule message. Does not implicitly {@link gov.ElectionRule.verify|verify} messages.
         * @function encode
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule} message ElectionRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectionRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.admin);
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.electorateId);
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.title);
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.votingPeriod);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                $root.gov.Fraction.encode(message.quorum, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified ElectionRule message, length delimited. Does not implicitly {@link gov.ElectionRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule} message ElectionRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectionRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ElectionRule message from the specified reader or buffer.
         * @function decode
         * @memberof gov.ElectionRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.ElectionRule} ElectionRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectionRule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.ElectionRule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.admin = reader.bytes();
                    break;
                case 4:
                    message.electorateId = reader.bytes();
                    break;
                case 5:
                    message.title = reader.string();
                    break;
                case 6:
                    message.votingPeriod = reader.uint32();
                    break;
                case 7:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.quorum = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ElectionRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.ElectionRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.ElectionRule} ElectionRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectionRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ElectionRule message.
         * @function verify
         * @memberof gov.ElectionRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ElectionRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                if (!(message.electorateId && typeof message.electorateId.length === "number" || $util.isString(message.electorateId)))
                    return "electorateId: buffer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                if (!$util.isInteger(message.votingPeriod))
                    return "votingPeriod: integer expected";
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            if (message.quorum != null && message.hasOwnProperty("quorum")) {
                var error = $root.gov.Fraction.verify(message.quorum);
                if (error)
                    return "quorum." + error;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates an ElectionRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.ElectionRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.ElectionRule} ElectionRule
         */
        ElectionRule.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.ElectionRule)
                return object;
            var message = new $root.gov.ElectionRule();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.ElectionRule.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.electorateId != null)
                if (typeof object.electorateId === "string")
                    $util.base64.decode(object.electorateId, message.electorateId = $util.newBuffer($util.base64.length(object.electorateId)), 0);
                else if (object.electorateId.length)
                    message.electorateId = object.electorateId;
            if (object.title != null)
                message.title = String(object.title);
            if (object.votingPeriod != null)
                message.votingPeriod = object.votingPeriod >>> 0;
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.ElectionRule.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            if (object.quorum != null) {
                if (typeof object.quorum !== "object")
                    throw TypeError(".gov.ElectionRule.quorum: object expected");
                message.quorum = $root.gov.Fraction.fromObject(object.quorum);
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from an ElectionRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.ElectionRule} message ElectionRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ElectionRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.version = 0;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
                if (options.bytes === String)
                    object.electorateId = "";
                else {
                    object.electorateId = [];
                    if (options.bytes !== Array)
                        object.electorateId = $util.newBuffer(object.electorateId);
                }
                object.title = "";
                object.votingPeriod = 0;
                object.threshold = null;
                object.quorum = null;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                object.electorateId = options.bytes === String ? $util.base64.encode(message.electorateId, 0, message.electorateId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electorateId) : message.electorateId;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                object.votingPeriod = message.votingPeriod;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                object.quorum = $root.gov.Fraction.toObject(message.quorum, options);
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this ElectionRule to JSON.
         * @function toJSON
         * @memberof gov.ElectionRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ElectionRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ElectionRule;
    })();

    gov.Fraction = (function() {

        /**
         * Properties of a Fraction.
         * @memberof gov
         * @interface IFraction
         * @property {number|null} [numerator] The top number in a fraction.
         * @property {number|null} [denominator] The bottom number
         */

        /**
         * Constructs a new Fraction.
         * @memberof gov
         * @classdesc Valid range of the fraction is 0.5 to 1.
         * @implements IFraction
         * @constructor
         * @param {gov.IFraction=} [properties] Properties to set
         */
        function Fraction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The top number in a fraction.
         * @member {number} numerator
         * @memberof gov.Fraction
         * @instance
         */
        Fraction.prototype.numerator = 0;

        /**
         * The bottom number
         * @member {number} denominator
         * @memberof gov.Fraction
         * @instance
         */
        Fraction.prototype.denominator = 0;

        /**
         * Creates a new Fraction instance using the specified properties.
         * @function create
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction=} [properties] Properties to set
         * @returns {gov.Fraction} Fraction instance
         */
        Fraction.create = function create(properties) {
            return new Fraction(properties);
        };

        /**
         * Encodes the specified Fraction message. Does not implicitly {@link gov.Fraction.verify|verify} messages.
         * @function encode
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction} message Fraction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numerator);
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.denominator);
            return writer;
        };

        /**
         * Encodes the specified Fraction message, length delimited. Does not implicitly {@link gov.Fraction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction} message Fraction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Fraction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.numerator = reader.uint32();
                    break;
                case 2:
                    message.denominator = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fraction message.
         * @function verify
         * @memberof gov.Fraction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fraction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                if (!$util.isInteger(message.numerator))
                    return "numerator: integer expected";
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                if (!$util.isInteger(message.denominator))
                    return "denominator: integer expected";
            return null;
        };

        /**
         * Creates a Fraction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Fraction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Fraction} Fraction
         */
        Fraction.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Fraction)
                return object;
            var message = new $root.gov.Fraction();
            if (object.numerator != null)
                message.numerator = object.numerator >>> 0;
            if (object.denominator != null)
                message.denominator = object.denominator >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Fraction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Fraction
         * @static
         * @param {gov.Fraction} message Fraction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fraction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numerator = 0;
                object.denominator = 0;
            }
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                object.numerator = message.numerator;
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                object.denominator = message.denominator;
            return object;
        };

        /**
         * Converts this Fraction to JSON.
         * @function toJSON
         * @memberof gov.Fraction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fraction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fraction;
    })();

    gov.Proposal = (function() {

        /**
         * Properties of a Proposal.
         * @memberof gov
         * @interface IProposal
         * @property {weave.IMetadata|null} [metadata] Proposal metadata
         * @property {string|null} [title] Human readable title.
         * @property {Uint8Array|null} [rawOption] Content of the proposal. Protobuf encoded, app-specific decoded must be passed in constructor
         * @property {string|null} [description] Description of the proposal in text form.
         * @property {orm.IVersionedIDRef|null} [electionRuleRef] ElectionRuleRef is a reference to the election rule
         * @property {orm.IVersionedIDRef|null} [electorateRef] Reference to the electorate to define the group of possible voters.
         * @property {number|Long|null} [votingStartTime] to this start time.
         * @property {number|Long|null} [votingEndTime] to be included in the election.
         * @property {number|Long|null} [submissionTime] Unix timestamp of the block where the proposal was added to the chain.
         * @property {Uint8Array|null} [author] Address of the author who created the proposal. If not set explicit on creation it will default to the main signer.
         * @property {gov.ITallyResult|null} [voteState] Result of the election. Contains intermediate tally results while voting period is open.
         * @property {gov.Proposal.Status|null} [status] Status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
         * @property {gov.Proposal.Result|null} [result] Result is the final result based on the votes and election rule. Initial value is Undefined.
         * @property {gov.Proposal.ExecutorResult|null} [executorResult] Result is the final result based on the votes and election rule. Initial value is NotRun.
         * @property {Uint8Array|null} [tallyTaskId] create the tally once the voting period is over.
         */

        /**
         * Constructs a new Proposal.
         * @memberof gov
         * @classdesc (what is being voted on)
         * @implements IProposal
         * @constructor
         * @param {gov.IProposal=} [properties] Properties to set
         */
        function Proposal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proposal metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.metadata = null;

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.title = "";

        /**
         * Content of the proposal. Protobuf encoded, app-specific decoded must be passed in constructor
         * @member {Uint8Array} rawOption
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.rawOption = $util.newBuffer([]);

        /**
         * Description of the proposal in text form.
         * @member {string} description
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.description = "";

        /**
         * ElectionRuleRef is a reference to the election rule
         * @member {orm.IVersionedIDRef|null|undefined} electionRuleRef
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.electionRuleRef = null;

        /**
         * Reference to the electorate to define the group of possible voters.
         * @member {orm.IVersionedIDRef|null|undefined} electorateRef
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.electorateRef = null;

        /**
         * to this start time.
         * @member {number|Long} votingStartTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.votingStartTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * to be included in the election.
         * @member {number|Long} votingEndTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.votingEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Unix timestamp of the block where the proposal was added to the chain.
         * @member {number|Long} submissionTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.submissionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Address of the author who created the proposal. If not set explicit on creation it will default to the main signer.
         * @member {Uint8Array} author
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.author = $util.newBuffer([]);

        /**
         * Result of the election. Contains intermediate tally results while voting period is open.
         * @member {gov.ITallyResult|null|undefined} voteState
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.voteState = null;

        /**
         * Status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
         * @member {gov.Proposal.Status} status
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.status = 0;

        /**
         * Result is the final result based on the votes and election rule. Initial value is Undefined.
         * @member {gov.Proposal.Result} result
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.result = 0;

        /**
         * Result is the final result based on the votes and election rule. Initial value is NotRun.
         * @member {gov.Proposal.ExecutorResult} executorResult
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.executorResult = 0;

        /**
         * create the tally once the voting period is over.
         * @member {Uint8Array} tallyTaskId
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.tallyTaskId = $util.newBuffer([]);

        /**
         * Creates a new Proposal instance using the specified properties.
         * @function create
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal=} [properties] Properties to set
         * @returns {gov.Proposal} Proposal instance
         */
        Proposal.create = function create(properties) {
            return new Proposal(properties);
        };

        /**
         * Encodes the specified Proposal message. Does not implicitly {@link gov.Proposal.verify|verify} messages.
         * @function encode
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rawOption);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef"))
                $root.orm.VersionedIDRef.encode(message.electionRuleRef, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                $root.orm.VersionedIDRef.encode(message.electorateRef, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.votingStartTime);
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.votingEndTime);
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.submissionTime);
            if (message.author != null && message.hasOwnProperty("author"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.author);
            if (message.voteState != null && message.hasOwnProperty("voteState"))
                $root.gov.TallyResult.encode(message.voteState, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.status);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.result);
            if (message.executorResult != null && message.hasOwnProperty("executorResult"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.executorResult);
            if (message.tallyTaskId != null && message.hasOwnProperty("tallyTaskId"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.tallyTaskId);
            return writer;
        };

        /**
         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link gov.Proposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Proposal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.rawOption = reader.bytes();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.electionRuleRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.electorateRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.votingStartTime = reader.int64();
                    break;
                case 8:
                    message.votingEndTime = reader.int64();
                    break;
                case 9:
                    message.submissionTime = reader.int64();
                    break;
                case 10:
                    message.author = reader.bytes();
                    break;
                case 11:
                    message.voteState = $root.gov.TallyResult.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.status = reader.int32();
                    break;
                case 13:
                    message.result = reader.int32();
                    break;
                case 14:
                    message.executorResult = reader.int32();
                    break;
                case 15:
                    message.tallyTaskId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proposal message.
         * @function verify
         * @memberof gov.Proposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                if (!(message.rawOption && typeof message.rawOption.length === "number" || $util.isString(message.rawOption)))
                    return "rawOption: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.electionRuleRef);
                if (error)
                    return "electionRuleRef." + error;
            }
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.electorateRef);
                if (error)
                    return "electorateRef." + error;
            }
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                if (!$util.isInteger(message.votingStartTime) && !(message.votingStartTime && $util.isInteger(message.votingStartTime.low) && $util.isInteger(message.votingStartTime.high)))
                    return "votingStartTime: integer|Long expected";
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                if (!$util.isInteger(message.votingEndTime) && !(message.votingEndTime && $util.isInteger(message.votingEndTime.low) && $util.isInteger(message.votingEndTime.high)))
                    return "votingEndTime: integer|Long expected";
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                if (!$util.isInteger(message.submissionTime) && !(message.submissionTime && $util.isInteger(message.submissionTime.low) && $util.isInteger(message.submissionTime.high)))
                    return "submissionTime: integer|Long expected";
            if (message.author != null && message.hasOwnProperty("author"))
                if (!(message.author && typeof message.author.length === "number" || $util.isString(message.author)))
                    return "author: buffer expected";
            if (message.voteState != null && message.hasOwnProperty("voteState")) {
                var error = $root.gov.TallyResult.verify(message.voteState);
                if (error)
                    return "voteState." + error;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.executorResult != null && message.hasOwnProperty("executorResult"))
                switch (message.executorResult) {
                default:
                    return "executorResult: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.tallyTaskId != null && message.hasOwnProperty("tallyTaskId"))
                if (!(message.tallyTaskId && typeof message.tallyTaskId.length === "number" || $util.isString(message.tallyTaskId)))
                    return "tallyTaskId: buffer expected";
            return null;
        };

        /**
         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Proposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Proposal} Proposal
         */
        Proposal.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Proposal)
                return object;
            var message = new $root.gov.Proposal();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Proposal.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.rawOption != null)
                if (typeof object.rawOption === "string")
                    $util.base64.decode(object.rawOption, message.rawOption = $util.newBuffer($util.base64.length(object.rawOption)), 0);
                else if (object.rawOption.length)
                    message.rawOption = object.rawOption;
            if (object.description != null)
                message.description = String(object.description);
            if (object.electionRuleRef != null) {
                if (typeof object.electionRuleRef !== "object")
                    throw TypeError(".gov.Proposal.electionRuleRef: object expected");
                message.electionRuleRef = $root.orm.VersionedIDRef.fromObject(object.electionRuleRef);
            }
            if (object.electorateRef != null) {
                if (typeof object.electorateRef !== "object")
                    throw TypeError(".gov.Proposal.electorateRef: object expected");
                message.electorateRef = $root.orm.VersionedIDRef.fromObject(object.electorateRef);
            }
            if (object.votingStartTime != null)
                if ($util.Long)
                    (message.votingStartTime = $util.Long.fromValue(object.votingStartTime)).unsigned = false;
                else if (typeof object.votingStartTime === "string")
                    message.votingStartTime = parseInt(object.votingStartTime, 10);
                else if (typeof object.votingStartTime === "number")
                    message.votingStartTime = object.votingStartTime;
                else if (typeof object.votingStartTime === "object")
                    message.votingStartTime = new $util.LongBits(object.votingStartTime.low >>> 0, object.votingStartTime.high >>> 0).toNumber();
            if (object.votingEndTime != null)
                if ($util.Long)
                    (message.votingEndTime = $util.Long.fromValue(object.votingEndTime)).unsigned = false;
                else if (typeof object.votingEndTime === "string")
                    message.votingEndTime = parseInt(object.votingEndTime, 10);
                else if (typeof object.votingEndTime === "number")
                    message.votingEndTime = object.votingEndTime;
                else if (typeof object.votingEndTime === "object")
                    message.votingEndTime = new $util.LongBits(object.votingEndTime.low >>> 0, object.votingEndTime.high >>> 0).toNumber();
            if (object.submissionTime != null)
                if ($util.Long)
                    (message.submissionTime = $util.Long.fromValue(object.submissionTime)).unsigned = false;
                else if (typeof object.submissionTime === "string")
                    message.submissionTime = parseInt(object.submissionTime, 10);
                else if (typeof object.submissionTime === "number")
                    message.submissionTime = object.submissionTime;
                else if (typeof object.submissionTime === "object")
                    message.submissionTime = new $util.LongBits(object.submissionTime.low >>> 0, object.submissionTime.high >>> 0).toNumber();
            if (object.author != null)
                if (typeof object.author === "string")
                    $util.base64.decode(object.author, message.author = $util.newBuffer($util.base64.length(object.author)), 0);
                else if (object.author.length)
                    message.author = object.author;
            if (object.voteState != null) {
                if (typeof object.voteState !== "object")
                    throw TypeError(".gov.Proposal.voteState: object expected");
                message.voteState = $root.gov.TallyResult.fromObject(object.voteState);
            }
            switch (object.status) {
            case "PROPOSAL_STATUS_INVALID":
            case 0:
                message.status = 0;
                break;
            case "PROPOSAL_STATUS_SUBMITTED":
            case 1:
                message.status = 1;
                break;
            case "PROPOSAL_STATUS_CLOSED":
            case 2:
                message.status = 2;
                break;
            case "PROPOSAL_STATUS_WITHDRAWN":
            case 3:
                message.status = 3;
                break;
            }
            switch (object.result) {
            case "PROPOSAL_RESULT_INVALID":
            case 0:
                message.result = 0;
                break;
            case "PROPOSAL_RESULT_UNDEFINED":
            case 1:
                message.result = 1;
                break;
            case "PROPOSAL_RESULT_ACCEPTED":
            case 2:
                message.result = 2;
                break;
            case "PROPOSAL_RESULT_REJECTED":
            case 3:
                message.result = 3;
                break;
            }
            switch (object.executorResult) {
            case "PROPOSAL_EXECUTOR_RESULT_INVALID":
            case 0:
                message.executorResult = 0;
                break;
            case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
            case 1:
                message.executorResult = 1;
                break;
            case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
            case 2:
                message.executorResult = 2;
                break;
            case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
            case 3:
                message.executorResult = 3;
                break;
            }
            if (object.tallyTaskId != null)
                if (typeof object.tallyTaskId === "string")
                    $util.base64.decode(object.tallyTaskId, message.tallyTaskId = $util.newBuffer($util.base64.length(object.tallyTaskId)), 0);
                else if (object.tallyTaskId.length)
                    message.tallyTaskId = object.tallyTaskId;
            return message;
        };

        /**
         * Creates a plain object from a Proposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Proposal
         * @static
         * @param {gov.Proposal} message Proposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.title = "";
                if (options.bytes === String)
                    object.rawOption = "";
                else {
                    object.rawOption = [];
                    if (options.bytes !== Array)
                        object.rawOption = $util.newBuffer(object.rawOption);
                }
                object.description = "";
                object.electionRuleRef = null;
                object.electorateRef = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.votingStartTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.votingStartTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.votingEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.votingEndTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.submissionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.submissionTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.author = "";
                else {
                    object.author = [];
                    if (options.bytes !== Array)
                        object.author = $util.newBuffer(object.author);
                }
                object.voteState = null;
                object.status = options.enums === String ? "PROPOSAL_STATUS_INVALID" : 0;
                object.result = options.enums === String ? "PROPOSAL_RESULT_INVALID" : 0;
                object.executorResult = options.enums === String ? "PROPOSAL_EXECUTOR_RESULT_INVALID" : 0;
                if (options.bytes === String)
                    object.tallyTaskId = "";
                else {
                    object.tallyTaskId = [];
                    if (options.bytes !== Array)
                        object.tallyTaskId = $util.newBuffer(object.tallyTaskId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                object.rawOption = options.bytes === String ? $util.base64.encode(message.rawOption, 0, message.rawOption.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawOption) : message.rawOption;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef"))
                object.electionRuleRef = $root.orm.VersionedIDRef.toObject(message.electionRuleRef, options);
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                object.electorateRef = $root.orm.VersionedIDRef.toObject(message.electorateRef, options);
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                if (typeof message.votingStartTime === "number")
                    object.votingStartTime = options.longs === String ? String(message.votingStartTime) : message.votingStartTime;
                else
                    object.votingStartTime = options.longs === String ? $util.Long.prototype.toString.call(message.votingStartTime) : options.longs === Number ? new $util.LongBits(message.votingStartTime.low >>> 0, message.votingStartTime.high >>> 0).toNumber() : message.votingStartTime;
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                if (typeof message.votingEndTime === "number")
                    object.votingEndTime = options.longs === String ? String(message.votingEndTime) : message.votingEndTime;
                else
                    object.votingEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.votingEndTime) : options.longs === Number ? new $util.LongBits(message.votingEndTime.low >>> 0, message.votingEndTime.high >>> 0).toNumber() : message.votingEndTime;
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                if (typeof message.submissionTime === "number")
                    object.submissionTime = options.longs === String ? String(message.submissionTime) : message.submissionTime;
                else
                    object.submissionTime = options.longs === String ? $util.Long.prototype.toString.call(message.submissionTime) : options.longs === Number ? new $util.LongBits(message.submissionTime.low >>> 0, message.submissionTime.high >>> 0).toNumber() : message.submissionTime;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = options.bytes === String ? $util.base64.encode(message.author, 0, message.author.length) : options.bytes === Array ? Array.prototype.slice.call(message.author) : message.author;
            if (message.voteState != null && message.hasOwnProperty("voteState"))
                object.voteState = $root.gov.TallyResult.toObject(message.voteState, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.gov.Proposal.Status[message.status] : message.status;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.gov.Proposal.Result[message.result] : message.result;
            if (message.executorResult != null && message.hasOwnProperty("executorResult"))
                object.executorResult = options.enums === String ? $root.gov.Proposal.ExecutorResult[message.executorResult] : message.executorResult;
            if (message.tallyTaskId != null && message.hasOwnProperty("tallyTaskId"))
                object.tallyTaskId = options.bytes === String ? $util.base64.encode(message.tallyTaskId, 0, message.tallyTaskId.length) : options.bytes === Array ? Array.prototype.slice.call(message.tallyTaskId) : message.tallyTaskId;
            return object;
        };

        /**
         * Converts this Proposal to JSON.
         * @function toJSON
         * @memberof gov.Proposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name gov.Proposal.Status
         * @enum {string}
         * @property {number} PROPOSAL_STATUS_INVALID=0 An empty value is invalid and not allowed
         * @property {number} PROPOSAL_STATUS_SUBMITTED=1 Initial status of a proposal when persisted.
         * @property {number} PROPOSAL_STATUS_CLOSED=2 Final status of a proposal when the tally was executed
         * @property {number} PROPOSAL_STATUS_WITHDRAWN=3 is Withdrawn.
         */
        Proposal.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_STATUS_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_STATUS_SUBMITTED"] = 1;
            values[valuesById[2] = "PROPOSAL_STATUS_CLOSED"] = 2;
            values[valuesById[3] = "PROPOSAL_STATUS_WITHDRAWN"] = 3;
            return values;
        })();

        /**
         * Result enum.
         * @name gov.Proposal.Result
         * @enum {string}
         * @property {number} PROPOSAL_RESULT_INVALID=0 An empty value is invalid and not allowed
         * @property {number} PROPOSAL_RESULT_UNDEFINED=1 Until a final tally has happened the status is undefined
         * @property {number} PROPOSAL_RESULT_ACCEPTED=2 Final result of the tally
         * @property {number} PROPOSAL_RESULT_REJECTED=3 Final result of the tally
         */
        Proposal.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_RESULT_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_RESULT_UNDEFINED"] = 1;
            values[valuesById[2] = "PROPOSAL_RESULT_ACCEPTED"] = 2;
            values[valuesById[3] = "PROPOSAL_RESULT_REJECTED"] = 3;
            return values;
        })();

        /**
         * ExecutorResult enum.
         * @name gov.Proposal.ExecutorResult
         * @enum {string}
         * @property {number} PROPOSAL_EXECUTOR_RESULT_INVALID=0 An empty value is not allowed
         * @property {number} PROPOSAL_EXECUTOR_RESULT_NOT_RUN=1 We have not yet run the executor
         * @property {number} PROPOSAL_EXECUTOR_RESULT_SUCCESS=2 The executor was successful and proposed action updated state
         * @property {number} PROPOSAL_EXECUTOR_RESULT_FAILURE=3 The executor returned an error and proposed action didn't update state
         */
        Proposal.ExecutorResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_EXECUTOR_RESULT_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1;
            values[valuesById[2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2;
            values[valuesById[3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3;
            return values;
        })();

        return Proposal;
    })();

    gov.Resolution = (function() {

        /**
         * Properties of a Resolution.
         * @memberof gov
         * @interface IResolution
         * @property {weave.IMetadata|null} [metadata] Resolution metadata
         * @property {Uint8Array|null} [proposalId] Resolution proposalId
         * @property {orm.IVersionedIDRef|null} [electorateRef] Resolution electorateRef
         * @property {string|null} [resolution] Resolution resolution
         */

        /**
         * Constructs a new Resolution.
         * @memberof gov
         * @classdesc Resolution contains TextResolution and an electorate reference.
         * @implements IResolution
         * @constructor
         * @param {gov.IResolution=} [properties] Properties to set
         */
        function Resolution(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resolution metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Resolution
         * @instance
         */
        Resolution.prototype.metadata = null;

        /**
         * Resolution proposalId.
         * @member {Uint8Array} proposalId
         * @memberof gov.Resolution
         * @instance
         */
        Resolution.prototype.proposalId = $util.newBuffer([]);

        /**
         * Resolution electorateRef.
         * @member {orm.IVersionedIDRef|null|undefined} electorateRef
         * @memberof gov.Resolution
         * @instance
         */
        Resolution.prototype.electorateRef = null;

        /**
         * Resolution resolution.
         * @member {string} resolution
         * @memberof gov.Resolution
         * @instance
         */
        Resolution.prototype.resolution = "";

        /**
         * Creates a new Resolution instance using the specified properties.
         * @function create
         * @memberof gov.Resolution
         * @static
         * @param {gov.IResolution=} [properties] Properties to set
         * @returns {gov.Resolution} Resolution instance
         */
        Resolution.create = function create(properties) {
            return new Resolution(properties);
        };

        /**
         * Encodes the specified Resolution message. Does not implicitly {@link gov.Resolution.verify|verify} messages.
         * @function encode
         * @memberof gov.Resolution
         * @static
         * @param {gov.IResolution} message Resolution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resolution.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                $root.orm.VersionedIDRef.encode(message.electorateRef, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.resolution);
            return writer;
        };

        /**
         * Encodes the specified Resolution message, length delimited. Does not implicitly {@link gov.Resolution.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Resolution
         * @static
         * @param {gov.IResolution} message Resolution message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resolution.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resolution message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Resolution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Resolution} Resolution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resolution.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Resolution();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                case 3:
                    message.electorateRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.resolution = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resolution message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Resolution
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Resolution} Resolution
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resolution.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resolution message.
         * @function verify
         * @memberof gov.Resolution
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resolution.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.electorateRef);
                if (error)
                    return "electorateRef." + error;
            }
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                if (!$util.isString(message.resolution))
                    return "resolution: string expected";
            return null;
        };

        /**
         * Creates a Resolution message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Resolution
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Resolution} Resolution
         */
        Resolution.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Resolution)
                return object;
            var message = new $root.gov.Resolution();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Resolution.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            if (object.electorateRef != null) {
                if (typeof object.electorateRef !== "object")
                    throw TypeError(".gov.Resolution.electorateRef: object expected");
                message.electorateRef = $root.orm.VersionedIDRef.fromObject(object.electorateRef);
            }
            if (object.resolution != null)
                message.resolution = String(object.resolution);
            return message;
        };

        /**
         * Creates a plain object from a Resolution message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Resolution
         * @static
         * @param {gov.Resolution} message Resolution
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Resolution.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
                object.electorateRef = null;
                object.resolution = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                object.electorateRef = $root.orm.VersionedIDRef.toObject(message.electorateRef, options);
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                object.resolution = message.resolution;
            return object;
        };

        /**
         * Converts this Resolution to JSON.
         * @function toJSON
         * @memberof gov.Resolution
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Resolution.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Resolution;
    })();

    gov.TallyResult = (function() {

        /**
         * Properties of a TallyResult.
         * @memberof gov
         * @interface ITallyResult
         * @property {number|Long|null} [totalYes] TotalYes is the sum of weights of all the voters that approved the proposal
         * @property {number|Long|null} [totalNo] TotalNo is the sum of weights of all the voters that rejected the proposal
         * @property {number|Long|null} [totalAbstain] TotalAbstain is the sum of weights of all the voters that voted abstain
         * @property {number|Long|null} [totalElectorateWeight] TotalElectorateWeight is the sum of all weights in the electorate.
         * @property {gov.IFraction|null} [quorum] Quorum when set is the fraction of the total electorate weight that must be exceeded by total votes weight.
         * @property {gov.IFraction|null} [threshold] The base value is either the total electorate weight or the sum of Yes/No weights when a quorum is defined.
         */

        /**
         * Constructs a new TallyResult.
         * @memberof gov
         * @classdesc TallyResult contains sums of the votes and all data for the final result.
         * @implements ITallyResult
         * @constructor
         * @param {gov.ITallyResult=} [properties] Properties to set
         */
        function TallyResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TotalYes is the sum of weights of all the voters that approved the proposal
         * @member {number|Long} totalYes
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalYes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalNo is the sum of weights of all the voters that rejected the proposal
         * @member {number|Long} totalNo
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalNo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalAbstain is the sum of weights of all the voters that voted abstain
         * @member {number|Long} totalAbstain
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalAbstain = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalElectorateWeight is the sum of all weights in the electorate.
         * @member {number|Long} totalElectorateWeight
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalElectorateWeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Quorum when set is the fraction of the total electorate weight that must be exceeded by total votes weight.
         * @member {gov.IFraction|null|undefined} quorum
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.quorum = null;

        /**
         * The base value is either the total electorate weight or the sum of Yes/No weights when a quorum is defined.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.threshold = null;

        /**
         * Creates a new TallyResult instance using the specified properties.
         * @function create
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult=} [properties] Properties to set
         * @returns {gov.TallyResult} TallyResult instance
         */
        TallyResult.create = function create(properties) {
            return new TallyResult(properties);
        };

        /**
         * Encodes the specified TallyResult message. Does not implicitly {@link gov.TallyResult.verify|verify} messages.
         * @function encode
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult} message TallyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.totalYes);
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.totalNo);
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.totalAbstain);
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.totalElectorateWeight);
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                $root.gov.Fraction.encode(message.quorum, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TallyResult message, length delimited. Does not implicitly {@link gov.TallyResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult} message TallyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TallyResult message from the specified reader or buffer.
         * @function decode
         * @memberof gov.TallyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.TallyResult} TallyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.TallyResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalYes = reader.uint64();
                    break;
                case 2:
                    message.totalNo = reader.uint64();
                    break;
                case 3:
                    message.totalAbstain = reader.uint64();
                    break;
                case 4:
                    message.totalElectorateWeight = reader.uint64();
                    break;
                case 5:
                    message.quorum = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TallyResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.TallyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.TallyResult} TallyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TallyResult message.
         * @function verify
         * @memberof gov.TallyResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TallyResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                if (!$util.isInteger(message.totalYes) && !(message.totalYes && $util.isInteger(message.totalYes.low) && $util.isInteger(message.totalYes.high)))
                    return "totalYes: integer|Long expected";
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                if (!$util.isInteger(message.totalNo) && !(message.totalNo && $util.isInteger(message.totalNo.low) && $util.isInteger(message.totalNo.high)))
                    return "totalNo: integer|Long expected";
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                if (!$util.isInteger(message.totalAbstain) && !(message.totalAbstain && $util.isInteger(message.totalAbstain.low) && $util.isInteger(message.totalAbstain.high)))
                    return "totalAbstain: integer|Long expected";
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (!$util.isInteger(message.totalElectorateWeight) && !(message.totalElectorateWeight && $util.isInteger(message.totalElectorateWeight.low) && $util.isInteger(message.totalElectorateWeight.high)))
                    return "totalElectorateWeight: integer|Long expected";
            if (message.quorum != null && message.hasOwnProperty("quorum")) {
                var error = $root.gov.Fraction.verify(message.quorum);
                if (error)
                    return "quorum." + error;
            }
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            return null;
        };

        /**
         * Creates a TallyResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.TallyResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.TallyResult} TallyResult
         */
        TallyResult.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.TallyResult)
                return object;
            var message = new $root.gov.TallyResult();
            if (object.totalYes != null)
                if ($util.Long)
                    (message.totalYes = $util.Long.fromValue(object.totalYes)).unsigned = true;
                else if (typeof object.totalYes === "string")
                    message.totalYes = parseInt(object.totalYes, 10);
                else if (typeof object.totalYes === "number")
                    message.totalYes = object.totalYes;
                else if (typeof object.totalYes === "object")
                    message.totalYes = new $util.LongBits(object.totalYes.low >>> 0, object.totalYes.high >>> 0).toNumber(true);
            if (object.totalNo != null)
                if ($util.Long)
                    (message.totalNo = $util.Long.fromValue(object.totalNo)).unsigned = true;
                else if (typeof object.totalNo === "string")
                    message.totalNo = parseInt(object.totalNo, 10);
                else if (typeof object.totalNo === "number")
                    message.totalNo = object.totalNo;
                else if (typeof object.totalNo === "object")
                    message.totalNo = new $util.LongBits(object.totalNo.low >>> 0, object.totalNo.high >>> 0).toNumber(true);
            if (object.totalAbstain != null)
                if ($util.Long)
                    (message.totalAbstain = $util.Long.fromValue(object.totalAbstain)).unsigned = true;
                else if (typeof object.totalAbstain === "string")
                    message.totalAbstain = parseInt(object.totalAbstain, 10);
                else if (typeof object.totalAbstain === "number")
                    message.totalAbstain = object.totalAbstain;
                else if (typeof object.totalAbstain === "object")
                    message.totalAbstain = new $util.LongBits(object.totalAbstain.low >>> 0, object.totalAbstain.high >>> 0).toNumber(true);
            if (object.totalElectorateWeight != null)
                if ($util.Long)
                    (message.totalElectorateWeight = $util.Long.fromValue(object.totalElectorateWeight)).unsigned = true;
                else if (typeof object.totalElectorateWeight === "string")
                    message.totalElectorateWeight = parseInt(object.totalElectorateWeight, 10);
                else if (typeof object.totalElectorateWeight === "number")
                    message.totalElectorateWeight = object.totalElectorateWeight;
                else if (typeof object.totalElectorateWeight === "object")
                    message.totalElectorateWeight = new $util.LongBits(object.totalElectorateWeight.low >>> 0, object.totalElectorateWeight.high >>> 0).toNumber(true);
            if (object.quorum != null) {
                if (typeof object.quorum !== "object")
                    throw TypeError(".gov.TallyResult.quorum: object expected");
                message.quorum = $root.gov.Fraction.fromObject(object.quorum);
            }
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.TallyResult.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            return message;
        };

        /**
         * Creates a plain object from a TallyResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.TallyResult
         * @static
         * @param {gov.TallyResult} message TallyResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TallyResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalYes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalYes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNo = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalAbstain = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAbstain = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalElectorateWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalElectorateWeight = options.longs === String ? "0" : 0;
                object.quorum = null;
                object.threshold = null;
            }
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                if (typeof message.totalYes === "number")
                    object.totalYes = options.longs === String ? String(message.totalYes) : message.totalYes;
                else
                    object.totalYes = options.longs === String ? $util.Long.prototype.toString.call(message.totalYes) : options.longs === Number ? new $util.LongBits(message.totalYes.low >>> 0, message.totalYes.high >>> 0).toNumber(true) : message.totalYes;
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                if (typeof message.totalNo === "number")
                    object.totalNo = options.longs === String ? String(message.totalNo) : message.totalNo;
                else
                    object.totalNo = options.longs === String ? $util.Long.prototype.toString.call(message.totalNo) : options.longs === Number ? new $util.LongBits(message.totalNo.low >>> 0, message.totalNo.high >>> 0).toNumber(true) : message.totalNo;
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                if (typeof message.totalAbstain === "number")
                    object.totalAbstain = options.longs === String ? String(message.totalAbstain) : message.totalAbstain;
                else
                    object.totalAbstain = options.longs === String ? $util.Long.prototype.toString.call(message.totalAbstain) : options.longs === Number ? new $util.LongBits(message.totalAbstain.low >>> 0, message.totalAbstain.high >>> 0).toNumber(true) : message.totalAbstain;
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (typeof message.totalElectorateWeight === "number")
                    object.totalElectorateWeight = options.longs === String ? String(message.totalElectorateWeight) : message.totalElectorateWeight;
                else
                    object.totalElectorateWeight = options.longs === String ? $util.Long.prototype.toString.call(message.totalElectorateWeight) : options.longs === Number ? new $util.LongBits(message.totalElectorateWeight.low >>> 0, message.totalElectorateWeight.high >>> 0).toNumber(true) : message.totalElectorateWeight;
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                object.quorum = $root.gov.Fraction.toObject(message.quorum, options);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            return object;
        };

        /**
         * Converts this TallyResult to JSON.
         * @function toJSON
         * @memberof gov.TallyResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TallyResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TallyResult;
    })();

    gov.Vote = (function() {

        /**
         * Properties of a Vote.
         * @memberof gov
         * @interface IVote
         * @property {weave.IMetadata|null} [metadata] Vote metadata
         * @property {gov.IElector|null} [elector] Elector is who voted
         * @property {gov.VoteOption|null} [voted] VoteOption is what they voted
         */

        /**
         * Constructs a new Vote.
         * @memberof gov
         * @classdesc The proposalID and address is stored within the key.
         * @implements IVote
         * @constructor
         * @param {gov.IVote=} [properties] Properties to set
         */
        function Vote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vote metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.metadata = null;

        /**
         * Elector is who voted
         * @member {gov.IElector|null|undefined} elector
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.elector = null;

        /**
         * VoteOption is what they voted
         * @member {gov.VoteOption} voted
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.voted = 0;

        /**
         * Creates a new Vote instance using the specified properties.
         * @function create
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote=} [properties] Properties to set
         * @returns {gov.Vote} Vote instance
         */
        Vote.create = function create(properties) {
            return new Vote(properties);
        };

        /**
         * Encodes the specified Vote message. Does not implicitly {@link gov.Vote.verify|verify} messages.
         * @function encode
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.elector != null && message.hasOwnProperty("elector"))
                $root.gov.Elector.encode(message.elector, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.voted != null && message.hasOwnProperty("voted"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.voted);
            return writer;
        };

        /**
         * Encodes the specified Vote message, length delimited. Does not implicitly {@link gov.Vote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vote message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Vote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.elector = $root.gov.Elector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.voted = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vote message.
         * @function verify
         * @memberof gov.Vote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.elector != null && message.hasOwnProperty("elector")) {
                var error = $root.gov.Elector.verify(message.elector);
                if (error)
                    return "elector." + error;
            }
            if (message.voted != null && message.hasOwnProperty("voted"))
                switch (message.voted) {
                default:
                    return "voted: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Vote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Vote} Vote
         */
        Vote.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Vote)
                return object;
            var message = new $root.gov.Vote();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Vote.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.elector != null) {
                if (typeof object.elector !== "object")
                    throw TypeError(".gov.Vote.elector: object expected");
                message.elector = $root.gov.Elector.fromObject(object.elector);
            }
            switch (object.voted) {
            case "VOTE_OPTION_INVALID":
            case 0:
                message.voted = 0;
                break;
            case "VOTE_OPTION_YES":
            case 1:
                message.voted = 1;
                break;
            case "VOTE_OPTION_NO":
            case 2:
                message.voted = 2;
                break;
            case "VOTE_OPTION_ABSTAIN":
            case 3:
                message.voted = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Vote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Vote
         * @static
         * @param {gov.Vote} message Vote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.elector = null;
                object.voted = options.enums === String ? "VOTE_OPTION_INVALID" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.elector != null && message.hasOwnProperty("elector"))
                object.elector = $root.gov.Elector.toObject(message.elector, options);
            if (message.voted != null && message.hasOwnProperty("voted"))
                object.voted = options.enums === String ? $root.gov.VoteOption[message.voted] : message.voted;
            return object;
        };

        /**
         * Converts this Vote to JSON.
         * @function toJSON
         * @memberof gov.Vote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vote;
    })();

    gov.CreateProposalMsg = (function() {

        /**
         * Properties of a CreateProposalMsg.
         * @memberof gov
         * @interface ICreateProposalMsg
         * @property {weave.IMetadata|null} [metadata] CreateProposalMsg metadata
         * @property {string|null} [title] Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @property {Uint8Array|null} [rawOption] Content of the proposal. Protobuf encoded, app-specific decoded must be passed in handler constructor
         * @property {string|null} [description] Human readable description with 3 to 5000 chars.
         * @property {Uint8Array|null} [electionRuleId] ElectionRuleID is a reference to the election rule
         * @property {number|Long|null} [startTime] Unix timestamp when the proposal starts. Must be in the future.
         * @property {Uint8Array|null} [author] When not set it will default to the main signer.
         */

        /**
         * Constructs a new CreateProposalMsg.
         * @memberof gov
         * @classdesc (what is being voted on)
         * @implements ICreateProposalMsg
         * @constructor
         * @param {gov.ICreateProposalMsg=} [properties] Properties to set
         */
        function CreateProposalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateProposalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.metadata = null;

        /**
         * Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @member {string} title
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.title = "";

        /**
         * Content of the proposal. Protobuf encoded, app-specific decoded must be passed in handler constructor
         * @member {Uint8Array} rawOption
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.rawOption = $util.newBuffer([]);

        /**
         * Human readable description with 3 to 5000 chars.
         * @member {string} description
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.description = "";

        /**
         * ElectionRuleID is a reference to the election rule
         * @member {Uint8Array} electionRuleId
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.electionRuleId = $util.newBuffer([]);

        /**
         * Unix timestamp when the proposal starts. Must be in the future.
         * @member {number|Long} startTime
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * When not set it will default to the main signer.
         * @member {Uint8Array} author
         * @memberof gov.CreateProposalMsg
         * @instance
         */
        CreateProposalMsg.prototype.author = $util.newBuffer([]);

        /**
         * Creates a new CreateProposalMsg instance using the specified properties.
         * @function create
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {gov.ICreateProposalMsg=} [properties] Properties to set
         * @returns {gov.CreateProposalMsg} CreateProposalMsg instance
         */
        CreateProposalMsg.create = function create(properties) {
            return new CreateProposalMsg(properties);
        };

        /**
         * Encodes the specified CreateProposalMsg message. Does not implicitly {@link gov.CreateProposalMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {gov.ICreateProposalMsg} message CreateProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateProposalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rawOption);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.electionRuleId);
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.startTime);
            if (message.author != null && message.hasOwnProperty("author"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.author);
            return writer;
        };

        /**
         * Encodes the specified CreateProposalMsg message, length delimited. Does not implicitly {@link gov.CreateProposalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {gov.ICreateProposalMsg} message CreateProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateProposalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateProposalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.CreateProposalMsg} CreateProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateProposalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.CreateProposalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.rawOption = reader.bytes();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.electionRuleId = reader.bytes();
                    break;
                case 6:
                    message.startTime = reader.int64();
                    break;
                case 7:
                    message.author = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateProposalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.CreateProposalMsg} CreateProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateProposalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateProposalMsg message.
         * @function verify
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateProposalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                if (!(message.rawOption && typeof message.rawOption.length === "number" || $util.isString(message.rawOption)))
                    return "rawOption: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                if (!(message.electionRuleId && typeof message.electionRuleId.length === "number" || $util.isString(message.electionRuleId)))
                    return "electionRuleId: buffer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.author != null && message.hasOwnProperty("author"))
                if (!(message.author && typeof message.author.length === "number" || $util.isString(message.author)))
                    return "author: buffer expected";
            return null;
        };

        /**
         * Creates a CreateProposalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.CreateProposalMsg} CreateProposalMsg
         */
        CreateProposalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.CreateProposalMsg)
                return object;
            var message = new $root.gov.CreateProposalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.CreateProposalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.rawOption != null)
                if (typeof object.rawOption === "string")
                    $util.base64.decode(object.rawOption, message.rawOption = $util.newBuffer($util.base64.length(object.rawOption)), 0);
                else if (object.rawOption.length)
                    message.rawOption = object.rawOption;
            if (object.description != null)
                message.description = String(object.description);
            if (object.electionRuleId != null)
                if (typeof object.electionRuleId === "string")
                    $util.base64.decode(object.electionRuleId, message.electionRuleId = $util.newBuffer($util.base64.length(object.electionRuleId)), 0);
                else if (object.electionRuleId.length)
                    message.electionRuleId = object.electionRuleId;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.author != null)
                if (typeof object.author === "string")
                    $util.base64.decode(object.author, message.author = $util.newBuffer($util.base64.length(object.author)), 0);
                else if (object.author.length)
                    message.author = object.author;
            return message;
        };

        /**
         * Creates a plain object from a CreateProposalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.CreateProposalMsg
         * @static
         * @param {gov.CreateProposalMsg} message CreateProposalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateProposalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.title = "";
                if (options.bytes === String)
                    object.rawOption = "";
                else {
                    object.rawOption = [];
                    if (options.bytes !== Array)
                        object.rawOption = $util.newBuffer(object.rawOption);
                }
                object.description = "";
                if (options.bytes === String)
                    object.electionRuleId = "";
                else {
                    object.electionRuleId = [];
                    if (options.bytes !== Array)
                        object.electionRuleId = $util.newBuffer(object.electionRuleId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.author = "";
                else {
                    object.author = [];
                    if (options.bytes !== Array)
                        object.author = $util.newBuffer(object.author);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.rawOption != null && message.hasOwnProperty("rawOption"))
                object.rawOption = options.bytes === String ? $util.base64.encode(message.rawOption, 0, message.rawOption.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawOption) : message.rawOption;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                object.electionRuleId = options.bytes === String ? $util.base64.encode(message.electionRuleId, 0, message.electionRuleId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electionRuleId) : message.electionRuleId;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = options.bytes === String ? $util.base64.encode(message.author, 0, message.author.length) : options.bytes === Array ? Array.prototype.slice.call(message.author) : message.author;
            return object;
        };

        /**
         * Converts this CreateProposalMsg to JSON.
         * @function toJSON
         * @memberof gov.CreateProposalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateProposalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateProposalMsg;
    })();

    gov.DeleteProposalMsg = (function() {

        /**
         * Properties of a DeleteProposalMsg.
         * @memberof gov
         * @interface IDeleteProposalMsg
         * @property {weave.IMetadata|null} [metadata] DeleteProposalMsg metadata
         * @property {Uint8Array|null} [proposalId] ProposalID is the unique identifier of the proposal to delete
         */

        /**
         * Constructs a new DeleteProposalMsg.
         * @memberof gov
         * @classdesc DeleteProposalMsg deletes a governance proposal.
         * @implements IDeleteProposalMsg
         * @constructor
         * @param {gov.IDeleteProposalMsg=} [properties] Properties to set
         */
        function DeleteProposalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteProposalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.DeleteProposalMsg
         * @instance
         */
        DeleteProposalMsg.prototype.metadata = null;

        /**
         * ProposalID is the unique identifier of the proposal to delete
         * @member {Uint8Array} proposalId
         * @memberof gov.DeleteProposalMsg
         * @instance
         */
        DeleteProposalMsg.prototype.proposalId = $util.newBuffer([]);

        /**
         * Creates a new DeleteProposalMsg instance using the specified properties.
         * @function create
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg=} [properties] Properties to set
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg instance
         */
        DeleteProposalMsg.create = function create(properties) {
            return new DeleteProposalMsg(properties);
        };

        /**
         * Encodes the specified DeleteProposalMsg message. Does not implicitly {@link gov.DeleteProposalMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg} message DeleteProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteProposalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            return writer;
        };

        /**
         * Encodes the specified DeleteProposalMsg message, length delimited. Does not implicitly {@link gov.DeleteProposalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg} message DeleteProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteProposalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteProposalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteProposalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.DeleteProposalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteProposalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteProposalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteProposalMsg message.
         * @function verify
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteProposalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            return null;
        };

        /**
         * Creates a DeleteProposalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         */
        DeleteProposalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.DeleteProposalMsg)
                return object;
            var message = new $root.gov.DeleteProposalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.DeleteProposalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            return message;
        };

        /**
         * Creates a plain object from a DeleteProposalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.DeleteProposalMsg} message DeleteProposalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteProposalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            return object;
        };

        /**
         * Converts this DeleteProposalMsg to JSON.
         * @function toJSON
         * @memberof gov.DeleteProposalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteProposalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteProposalMsg;
    })();

    /**
     * VoteOptions define possible values for a vote including the INVALID default.
     * @name gov.VoteOption
     * @enum {string}
     * @property {number} VOTE_OPTION_INVALID=0 VOTE_OPTION_INVALID value
     * @property {number} VOTE_OPTION_YES=1 VOTE_OPTION_YES value
     * @property {number} VOTE_OPTION_NO=2 VOTE_OPTION_NO value
     * @property {number} VOTE_OPTION_ABSTAIN=3 VOTE_OPTION_ABSTAIN value
     */
    gov.VoteOption = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VOTE_OPTION_INVALID"] = 0;
        values[valuesById[1] = "VOTE_OPTION_YES"] = 1;
        values[valuesById[2] = "VOTE_OPTION_NO"] = 2;
        values[valuesById[3] = "VOTE_OPTION_ABSTAIN"] = 3;
        return values;
    })();

    gov.VoteMsg = (function() {

        /**
         * Properties of a VoteMsg.
         * @memberof gov
         * @interface IVoteMsg
         * @property {weave.IMetadata|null} [metadata] VoteMsg metadata
         * @property {Uint8Array|null} [proposalId] The unique id of the proposal.
         * @property {Uint8Array|null} [voter] must be included in the electorate for a valid vote.
         * @property {gov.VoteOption|null} [selected] Option for the vote. Must be Yes, No or Abstain for a valid vote.
         */

        /**
         * Constructs a new VoteMsg.
         * @memberof gov
         * @classdesc VoteMsg is the way to express a voice and participate in an election of a proposal on chain.
         * @implements IVoteMsg
         * @constructor
         * @param {gov.IVoteMsg=} [properties] Properties to set
         */
        function VoteMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.metadata = null;

        /**
         * The unique id of the proposal.
         * @member {Uint8Array} proposalId
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.proposalId = $util.newBuffer([]);

        /**
         * must be included in the electorate for a valid vote.
         * @member {Uint8Array} voter
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.voter = $util.newBuffer([]);

        /**
         * Option for the vote. Must be Yes, No or Abstain for a valid vote.
         * @member {gov.VoteOption} selected
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.selected = 0;

        /**
         * Creates a new VoteMsg instance using the specified properties.
         * @function create
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg=} [properties] Properties to set
         * @returns {gov.VoteMsg} VoteMsg instance
         */
        VoteMsg.create = function create(properties) {
            return new VoteMsg(properties);
        };

        /**
         * Encodes the specified VoteMsg message. Does not implicitly {@link gov.VoteMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg} message VoteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            if (message.voter != null && message.hasOwnProperty("voter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.voter);
            if (message.selected != null && message.hasOwnProperty("selected"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.selected);
            return writer;
        };

        /**
         * Encodes the specified VoteMsg message, length delimited. Does not implicitly {@link gov.VoteMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg} message VoteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.VoteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.VoteMsg} VoteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.VoteMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                case 3:
                    message.voter = reader.bytes();
                    break;
                case 4:
                    message.selected = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.VoteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.VoteMsg} VoteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteMsg message.
         * @function verify
         * @memberof gov.VoteMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            if (message.voter != null && message.hasOwnProperty("voter"))
                if (!(message.voter && typeof message.voter.length === "number" || $util.isString(message.voter)))
                    return "voter: buffer expected";
            if (message.selected != null && message.hasOwnProperty("selected"))
                switch (message.selected) {
                default:
                    return "selected: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a VoteMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.VoteMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.VoteMsg} VoteMsg
         */
        VoteMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.VoteMsg)
                return object;
            var message = new $root.gov.VoteMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.VoteMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            if (object.voter != null)
                if (typeof object.voter === "string")
                    $util.base64.decode(object.voter, message.voter = $util.newBuffer($util.base64.length(object.voter)), 0);
                else if (object.voter.length)
                    message.voter = object.voter;
            switch (object.selected) {
            case "VOTE_OPTION_INVALID":
            case 0:
                message.selected = 0;
                break;
            case "VOTE_OPTION_YES":
            case 1:
                message.selected = 1;
                break;
            case "VOTE_OPTION_NO":
            case 2:
                message.selected = 2;
                break;
            case "VOTE_OPTION_ABSTAIN":
            case 3:
                message.selected = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a VoteMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.VoteMsg} message VoteMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
                if (options.bytes === String)
                    object.voter = "";
                else {
                    object.voter = [];
                    if (options.bytes !== Array)
                        object.voter = $util.newBuffer(object.voter);
                }
                object.selected = options.enums === String ? "VOTE_OPTION_INVALID" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            if (message.voter != null && message.hasOwnProperty("voter"))
                object.voter = options.bytes === String ? $util.base64.encode(message.voter, 0, message.voter.length) : options.bytes === Array ? Array.prototype.slice.call(message.voter) : message.voter;
            if (message.selected != null && message.hasOwnProperty("selected"))
                object.selected = options.enums === String ? $root.gov.VoteOption[message.selected] : message.selected;
            return object;
        };

        /**
         * Converts this VoteMsg to JSON.
         * @function toJSON
         * @memberof gov.VoteMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VoteMsg;
    })();

    gov.TallyMsg = (function() {

        /**
         * Properties of a TallyMsg.
         * @memberof gov
         * @interface ITallyMsg
         * @property {weave.IMetadata|null} [metadata] TallyMsg metadata
         * @property {Uint8Array|null} [proposalId] ProposalID is UUID of the proposal to close.
         */

        /**
         * Constructs a new TallyMsg.
         * @memberof gov
         * @classdesc A final tally can be execute only once. A second submission will fail with an invalid state error.
         * @implements ITallyMsg
         * @constructor
         * @param {gov.ITallyMsg=} [properties] Properties to set
         */
        function TallyMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TallyMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.TallyMsg
         * @instance
         */
        TallyMsg.prototype.metadata = null;

        /**
         * ProposalID is UUID of the proposal to close.
         * @member {Uint8Array} proposalId
         * @memberof gov.TallyMsg
         * @instance
         */
        TallyMsg.prototype.proposalId = $util.newBuffer([]);

        /**
         * Creates a new TallyMsg instance using the specified properties.
         * @function create
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg=} [properties] Properties to set
         * @returns {gov.TallyMsg} TallyMsg instance
         */
        TallyMsg.create = function create(properties) {
            return new TallyMsg(properties);
        };

        /**
         * Encodes the specified TallyMsg message. Does not implicitly {@link gov.TallyMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg} message TallyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            return writer;
        };

        /**
         * Encodes the specified TallyMsg message, length delimited. Does not implicitly {@link gov.TallyMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg} message TallyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TallyMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.TallyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.TallyMsg} TallyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.TallyMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TallyMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.TallyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.TallyMsg} TallyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TallyMsg message.
         * @function verify
         * @memberof gov.TallyMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TallyMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            return null;
        };

        /**
         * Creates a TallyMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.TallyMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.TallyMsg} TallyMsg
         */
        TallyMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.TallyMsg)
                return object;
            var message = new $root.gov.TallyMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.TallyMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            return message;
        };

        /**
         * Creates a plain object from a TallyMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.TallyMsg} message TallyMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TallyMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            return object;
        };

        /**
         * Converts this TallyMsg to JSON.
         * @function toJSON
         * @memberof gov.TallyMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TallyMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TallyMsg;
    })();

    gov.CreateTextResolutionMsg = (function() {

        /**
         * Properties of a CreateTextResolutionMsg.
         * @memberof gov
         * @interface ICreateTextResolutionMsg
         * @property {weave.IMetadata|null} [metadata] CreateTextResolutionMsg metadata
         * @property {string|null} [resolution] CreateTextResolutionMsg resolution
         */

        /**
         * Constructs a new CreateTextResolutionMsg.
         * @memberof gov
         * @classdesc with a reference to the electorate that approved it
         * @implements ICreateTextResolutionMsg
         * @constructor
         * @param {gov.ICreateTextResolutionMsg=} [properties] Properties to set
         */
        function CreateTextResolutionMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTextResolutionMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.CreateTextResolutionMsg
         * @instance
         */
        CreateTextResolutionMsg.prototype.metadata = null;

        /**
         * CreateTextResolutionMsg resolution.
         * @member {string} resolution
         * @memberof gov.CreateTextResolutionMsg
         * @instance
         */
        CreateTextResolutionMsg.prototype.resolution = "";

        /**
         * Creates a new CreateTextResolutionMsg instance using the specified properties.
         * @function create
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {gov.ICreateTextResolutionMsg=} [properties] Properties to set
         * @returns {gov.CreateTextResolutionMsg} CreateTextResolutionMsg instance
         */
        CreateTextResolutionMsg.create = function create(properties) {
            return new CreateTextResolutionMsg(properties);
        };

        /**
         * Encodes the specified CreateTextResolutionMsg message. Does not implicitly {@link gov.CreateTextResolutionMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {gov.ICreateTextResolutionMsg} message CreateTextResolutionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTextResolutionMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.resolution);
            return writer;
        };

        /**
         * Encodes the specified CreateTextResolutionMsg message, length delimited. Does not implicitly {@link gov.CreateTextResolutionMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {gov.ICreateTextResolutionMsg} message CreateTextResolutionMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTextResolutionMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTextResolutionMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.CreateTextResolutionMsg} CreateTextResolutionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTextResolutionMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.CreateTextResolutionMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.resolution = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTextResolutionMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.CreateTextResolutionMsg} CreateTextResolutionMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTextResolutionMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTextResolutionMsg message.
         * @function verify
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTextResolutionMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                if (!$util.isString(message.resolution))
                    return "resolution: string expected";
            return null;
        };

        /**
         * Creates a CreateTextResolutionMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.CreateTextResolutionMsg} CreateTextResolutionMsg
         */
        CreateTextResolutionMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.CreateTextResolutionMsg)
                return object;
            var message = new $root.gov.CreateTextResolutionMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.CreateTextResolutionMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.resolution != null)
                message.resolution = String(object.resolution);
            return message;
        };

        /**
         * Creates a plain object from a CreateTextResolutionMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.CreateTextResolutionMsg
         * @static
         * @param {gov.CreateTextResolutionMsg} message CreateTextResolutionMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTextResolutionMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.resolution = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.resolution != null && message.hasOwnProperty("resolution"))
                object.resolution = message.resolution;
            return object;
        };

        /**
         * Converts this CreateTextResolutionMsg to JSON.
         * @function toJSON
         * @memberof gov.CreateTextResolutionMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTextResolutionMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTextResolutionMsg;
    })();

    gov.UpdateElectorateMsg = (function() {

        /**
         * Properties of an UpdateElectorateMsg.
         * @memberof gov
         * @interface IUpdateElectorateMsg
         * @property {weave.IMetadata|null} [metadata] UpdateElectorateMsg metadata
         * @property {Uint8Array|null} [electorateId] ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @property {Array.<gov.IElector>|null} [diffElectors] with weight=0.
         */

        /**
         * Constructs a new UpdateElectorateMsg.
         * @memberof gov
         * @classdesc Represents an UpdateElectorateMsg.
         * @implements IUpdateElectorateMsg
         * @constructor
         * @param {gov.IUpdateElectorateMsg=} [properties] Properties to set
         */
        function UpdateElectorateMsg(properties) {
            this.diffElectors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateElectorateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.metadata = null;

        /**
         * ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @member {Uint8Array} electorateId
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.electorateId = $util.newBuffer([]);

        /**
         * with weight=0.
         * @member {Array.<gov.IElector>} diffElectors
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.diffElectors = $util.emptyArray;

        /**
         * Creates a new UpdateElectorateMsg instance using the specified properties.
         * @function create
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg=} [properties] Properties to set
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg instance
         */
        UpdateElectorateMsg.create = function create(properties) {
            return new UpdateElectorateMsg(properties);
        };

        /**
         * Encodes the specified UpdateElectorateMsg message. Does not implicitly {@link gov.UpdateElectorateMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg} message UpdateElectorateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectorateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.electorateId);
            if (message.diffElectors != null && message.diffElectors.length)
                for (var i = 0; i < message.diffElectors.length; ++i)
                    $root.gov.Elector.encode(message.diffElectors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateElectorateMsg message, length delimited. Does not implicitly {@link gov.UpdateElectorateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg} message UpdateElectorateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectorateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateElectorateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectorateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.UpdateElectorateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.electorateId = reader.bytes();
                    break;
                case 3:
                    if (!(message.diffElectors && message.diffElectors.length))
                        message.diffElectors = [];
                    message.diffElectors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateElectorateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectorateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateElectorateMsg message.
         * @function verify
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateElectorateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                if (!(message.electorateId && typeof message.electorateId.length === "number" || $util.isString(message.electorateId)))
                    return "electorateId: buffer expected";
            if (message.diffElectors != null && message.hasOwnProperty("diffElectors")) {
                if (!Array.isArray(message.diffElectors))
                    return "diffElectors: array expected";
                for (var i = 0; i < message.diffElectors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.diffElectors[i]);
                    if (error)
                        return "diffElectors." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UpdateElectorateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         */
        UpdateElectorateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.UpdateElectorateMsg)
                return object;
            var message = new $root.gov.UpdateElectorateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.UpdateElectorateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.electorateId != null)
                if (typeof object.electorateId === "string")
                    $util.base64.decode(object.electorateId, message.electorateId = $util.newBuffer($util.base64.length(object.electorateId)), 0);
                else if (object.electorateId.length)
                    message.electorateId = object.electorateId;
            if (object.diffElectors) {
                if (!Array.isArray(object.diffElectors))
                    throw TypeError(".gov.UpdateElectorateMsg.diffElectors: array expected");
                message.diffElectors = [];
                for (var i = 0; i < object.diffElectors.length; ++i) {
                    if (typeof object.diffElectors[i] !== "object")
                        throw TypeError(".gov.UpdateElectorateMsg.diffElectors: object expected");
                    message.diffElectors[i] = $root.gov.Elector.fromObject(object.diffElectors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateElectorateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.UpdateElectorateMsg} message UpdateElectorateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateElectorateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diffElectors = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.electorateId = "";
                else {
                    object.electorateId = [];
                    if (options.bytes !== Array)
                        object.electorateId = $util.newBuffer(object.electorateId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                object.electorateId = options.bytes === String ? $util.base64.encode(message.electorateId, 0, message.electorateId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electorateId) : message.electorateId;
            if (message.diffElectors && message.diffElectors.length) {
                object.diffElectors = [];
                for (var j = 0; j < message.diffElectors.length; ++j)
                    object.diffElectors[j] = $root.gov.Elector.toObject(message.diffElectors[j], options);
            }
            return object;
        };

        /**
         * Converts this UpdateElectorateMsg to JSON.
         * @function toJSON
         * @memberof gov.UpdateElectorateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateElectorateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateElectorateMsg;
    })();

    gov.UpdateElectionRuleMsg = (function() {

        /**
         * Properties of an UpdateElectionRuleMsg.
         * @memberof gov
         * @interface IUpdateElectionRuleMsg
         * @property {weave.IMetadata|null} [metadata] UpdateElectionRuleMsg metadata
         * @property {Uint8Array|null} [electionRuleId] ElectionRuleID is a reference to the election rule
         * @property {number|null} [votingPeriod] Duration in seconds of how long the voting period will take place.
         * @property {gov.IFraction|null} [threshold] of the eligible voters.
         * @property {gov.IFraction|null} [quorum] allows any value between half and all of the eligible voters.
         */

        /**
         * Constructs a new UpdateElectionRuleMsg.
         * @memberof gov
         * @classdesc Represents an UpdateElectionRuleMsg.
         * @implements IUpdateElectionRuleMsg
         * @constructor
         * @param {gov.IUpdateElectionRuleMsg=} [properties] Properties to set
         */
        function UpdateElectionRuleMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateElectionRuleMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.metadata = null;

        /**
         * ElectionRuleID is a reference to the election rule
         * @member {Uint8Array} electionRuleId
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.electionRuleId = $util.newBuffer([]);

        /**
         * Duration in seconds of how long the voting period will take place.
         * @member {number} votingPeriod
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.votingPeriod = 0;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.threshold = null;

        /**
         * allows any value between half and all of the eligible voters.
         * @member {gov.IFraction|null|undefined} quorum
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.quorum = null;

        /**
         * Creates a new UpdateElectionRuleMsg instance using the specified properties.
         * @function create
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg=} [properties] Properties to set
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg instance
         */
        UpdateElectionRuleMsg.create = function create(properties) {
            return new UpdateElectionRuleMsg(properties);
        };

        /**
         * Encodes the specified UpdateElectionRuleMsg message. Does not implicitly {@link gov.UpdateElectionRuleMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg} message UpdateElectionRuleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectionRuleMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.electionRuleId);
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.votingPeriod);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                $root.gov.Fraction.encode(message.quorum, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateElectionRuleMsg message, length delimited. Does not implicitly {@link gov.UpdateElectionRuleMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg} message UpdateElectionRuleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectionRuleMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateElectionRuleMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectionRuleMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.UpdateElectionRuleMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.electionRuleId = reader.bytes();
                    break;
                case 3:
                    message.votingPeriod = reader.uint32();
                    break;
                case 4:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.quorum = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateElectionRuleMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectionRuleMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateElectionRuleMsg message.
         * @function verify
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateElectionRuleMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                if (!(message.electionRuleId && typeof message.electionRuleId.length === "number" || $util.isString(message.electionRuleId)))
                    return "electionRuleId: buffer expected";
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                if (!$util.isInteger(message.votingPeriod))
                    return "votingPeriod: integer expected";
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            if (message.quorum != null && message.hasOwnProperty("quorum")) {
                var error = $root.gov.Fraction.verify(message.quorum);
                if (error)
                    return "quorum." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateElectionRuleMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         */
        UpdateElectionRuleMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.UpdateElectionRuleMsg)
                return object;
            var message = new $root.gov.UpdateElectionRuleMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.UpdateElectionRuleMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.electionRuleId != null)
                if (typeof object.electionRuleId === "string")
                    $util.base64.decode(object.electionRuleId, message.electionRuleId = $util.newBuffer($util.base64.length(object.electionRuleId)), 0);
                else if (object.electionRuleId.length)
                    message.electionRuleId = object.electionRuleId;
            if (object.votingPeriod != null)
                message.votingPeriod = object.votingPeriod >>> 0;
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.UpdateElectionRuleMsg.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            if (object.quorum != null) {
                if (typeof object.quorum !== "object")
                    throw TypeError(".gov.UpdateElectionRuleMsg.quorum: object expected");
                message.quorum = $root.gov.Fraction.fromObject(object.quorum);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateElectionRuleMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.UpdateElectionRuleMsg} message UpdateElectionRuleMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateElectionRuleMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.electionRuleId = "";
                else {
                    object.electionRuleId = [];
                    if (options.bytes !== Array)
                        object.electionRuleId = $util.newBuffer(object.electionRuleId);
                }
                object.votingPeriod = 0;
                object.threshold = null;
                object.quorum = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                object.electionRuleId = options.bytes === String ? $util.base64.encode(message.electionRuleId, 0, message.electionRuleId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electionRuleId) : message.electionRuleId;
            if (message.votingPeriod != null && message.hasOwnProperty("votingPeriod"))
                object.votingPeriod = message.votingPeriod;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                object.quorum = $root.gov.Fraction.toObject(message.quorum, options);
            return object;
        };

        /**
         * Converts this UpdateElectionRuleMsg to JSON.
         * @function toJSON
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateElectionRuleMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateElectionRuleMsg;
    })();

    gov.ProposalOptions = (function() {

        /**
         * Properties of a ProposalOptions.
         * @memberof gov
         * @interface IProposalOptions
         * @property {gov.ICreateTextResolutionMsg|null} [text] ProposalOptions text
         * @property {gov.IUpdateElectorateMsg|null} [electorate] ProposalOptions electorate
         * @property {gov.IUpdateElectionRuleMsg|null} [rule] ProposalOptions rule
         */

        /**
         * Constructs a new ProposalOptions.
         * @memberof gov
         * @classdesc and handlers, but an application can reference messages from any package.
         * @implements IProposalOptions
         * @constructor
         * @param {gov.IProposalOptions=} [properties] Properties to set
         */
        function ProposalOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalOptions text.
         * @member {gov.ICreateTextResolutionMsg|null|undefined} text
         * @memberof gov.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.text = null;

        /**
         * ProposalOptions electorate.
         * @member {gov.IUpdateElectorateMsg|null|undefined} electorate
         * @memberof gov.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.electorate = null;

        /**
         * ProposalOptions rule.
         * @member {gov.IUpdateElectionRuleMsg|null|undefined} rule
         * @memberof gov.ProposalOptions
         * @instance
         */
        ProposalOptions.prototype.rule = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ProposalOptions option.
         * @member {"text"|"electorate"|"rule"|undefined} option
         * @memberof gov.ProposalOptions
         * @instance
         */
        Object.defineProperty(ProposalOptions.prototype, "option", {
            get: $util.oneOfGetter($oneOfFields = ["text", "electorate", "rule"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ProposalOptions instance using the specified properties.
         * @function create
         * @memberof gov.ProposalOptions
         * @static
         * @param {gov.IProposalOptions=} [properties] Properties to set
         * @returns {gov.ProposalOptions} ProposalOptions instance
         */
        ProposalOptions.create = function create(properties) {
            return new ProposalOptions(properties);
        };

        /**
         * Encodes the specified ProposalOptions message. Does not implicitly {@link gov.ProposalOptions.verify|verify} messages.
         * @function encode
         * @memberof gov.ProposalOptions
         * @static
         * @param {gov.IProposalOptions} message ProposalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && message.hasOwnProperty("text"))
                $root.gov.CreateTextResolutionMsg.encode(message.text, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.electorate != null && message.hasOwnProperty("electorate"))
                $root.gov.UpdateElectorateMsg.encode(message.electorate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.rule != null && message.hasOwnProperty("rule"))
                $root.gov.UpdateElectionRuleMsg.encode(message.rule, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProposalOptions message, length delimited. Does not implicitly {@link gov.ProposalOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.ProposalOptions
         * @static
         * @param {gov.IProposalOptions} message ProposalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalOptions message from the specified reader or buffer.
         * @function decode
         * @memberof gov.ProposalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.ProposalOptions} ProposalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.ProposalOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.text = $root.gov.CreateTextResolutionMsg.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.electorate = $root.gov.UpdateElectorateMsg.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.rule = $root.gov.UpdateElectionRuleMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.ProposalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.ProposalOptions} ProposalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalOptions message.
         * @function verify
         * @memberof gov.ProposalOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.text != null && message.hasOwnProperty("text")) {
                properties.option = 1;
                {
                    var error = $root.gov.CreateTextResolutionMsg.verify(message.text);
                    if (error)
                        return "text." + error;
                }
            }
            if (message.electorate != null && message.hasOwnProperty("electorate")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.gov.UpdateElectorateMsg.verify(message.electorate);
                    if (error)
                        return "electorate." + error;
                }
            }
            if (message.rule != null && message.hasOwnProperty("rule")) {
                if (properties.option === 1)
                    return "option: multiple values";
                properties.option = 1;
                {
                    var error = $root.gov.UpdateElectionRuleMsg.verify(message.rule);
                    if (error)
                        return "rule." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ProposalOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.ProposalOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.ProposalOptions} ProposalOptions
         */
        ProposalOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.ProposalOptions)
                return object;
            var message = new $root.gov.ProposalOptions();
            if (object.text != null) {
                if (typeof object.text !== "object")
                    throw TypeError(".gov.ProposalOptions.text: object expected");
                message.text = $root.gov.CreateTextResolutionMsg.fromObject(object.text);
            }
            if (object.electorate != null) {
                if (typeof object.electorate !== "object")
                    throw TypeError(".gov.ProposalOptions.electorate: object expected");
                message.electorate = $root.gov.UpdateElectorateMsg.fromObject(object.electorate);
            }
            if (object.rule != null) {
                if (typeof object.rule !== "object")
                    throw TypeError(".gov.ProposalOptions.rule: object expected");
                message.rule = $root.gov.UpdateElectionRuleMsg.fromObject(object.rule);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProposalOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.ProposalOptions
         * @static
         * @param {gov.ProposalOptions} message ProposalOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.text != null && message.hasOwnProperty("text")) {
                object.text = $root.gov.CreateTextResolutionMsg.toObject(message.text, options);
                if (options.oneofs)
                    object.option = "text";
            }
            if (message.electorate != null && message.hasOwnProperty("electorate")) {
                object.electorate = $root.gov.UpdateElectorateMsg.toObject(message.electorate, options);
                if (options.oneofs)
                    object.option = "electorate";
            }
            if (message.rule != null && message.hasOwnProperty("rule")) {
                object.rule = $root.gov.UpdateElectionRuleMsg.toObject(message.rule, options);
                if (options.oneofs)
                    object.option = "rule";
            }
            return object;
        };

        /**
         * Converts this ProposalOptions to JSON.
         * @function toJSON
         * @memberof gov.ProposalOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalOptions;
    })();

    return gov;
})();

$root.msgfee = (function() {

    /**
     * Namespace msgfee.
     * @exports msgfee
     * @namespace
     */
    var msgfee = {};

    msgfee.MsgFee = (function() {

        /**
         * Properties of a MsgFee.
         * @memberof msgfee
         * @interface IMsgFee
         * @property {weave.IMetadata|null} [metadata] MsgFee metadata
         * @property {string|null} [msgPath] MsgFee msgPath
         * @property {coin.ICoin|null} [fee] MsgFee fee
         */

        /**
         * Constructs a new MsgFee.
         * @memberof msgfee
         * @classdesc the message to be processed.
         * @implements IMsgFee
         * @constructor
         * @param {msgfee.IMsgFee=} [properties] Properties to set
         */
        function MsgFee(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgFee metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.metadata = null;

        /**
         * MsgFee msgPath.
         * @member {string} msgPath
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.msgPath = "";

        /**
         * MsgFee fee.
         * @member {coin.ICoin|null|undefined} fee
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.fee = null;

        /**
         * Creates a new MsgFee instance using the specified properties.
         * @function create
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee=} [properties] Properties to set
         * @returns {msgfee.MsgFee} MsgFee instance
         */
        MsgFee.create = function create(properties) {
            return new MsgFee(properties);
        };

        /**
         * Encodes the specified MsgFee message. Does not implicitly {@link msgfee.MsgFee.verify|verify} messages.
         * @function encode
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee} message MsgFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFee.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msgPath);
            if (message.fee != null && message.hasOwnProperty("fee"))
                $root.coin.Coin.encode(message.fee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgFee message, length delimited. Does not implicitly {@link msgfee.MsgFee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee} message MsgFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgFee message from the specified reader or buffer.
         * @function decode
         * @memberof msgfee.MsgFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgfee.MsgFee} MsgFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgfee.MsgFee();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msgPath = reader.string();
                    break;
                case 3:
                    message.fee = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgFee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgfee.MsgFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgfee.MsgFee} MsgFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgFee message.
         * @function verify
         * @memberof msgfee.MsgFee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgFee.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                if (!$util.isString(message.msgPath))
                    return "msgPath: string expected";
            if (message.fee != null && message.hasOwnProperty("fee")) {
                var error = $root.coin.Coin.verify(message.fee);
                if (error)
                    return "fee." + error;
            }
            return null;
        };

        /**
         * Creates a MsgFee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgfee.MsgFee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgfee.MsgFee} MsgFee
         */
        MsgFee.fromObject = function fromObject(object) {
            if (object instanceof $root.msgfee.MsgFee)
                return object;
            var message = new $root.msgfee.MsgFee();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".msgfee.MsgFee.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.msgPath != null)
                message.msgPath = String(object.msgPath);
            if (object.fee != null) {
                if (typeof object.fee !== "object")
                    throw TypeError(".msgfee.MsgFee.fee: object expected");
                message.fee = $root.coin.Coin.fromObject(object.fee);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgFee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.MsgFee} message MsgFee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgFee.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.msgPath = "";
                object.fee = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                object.msgPath = message.msgPath;
            if (message.fee != null && message.hasOwnProperty("fee"))
                object.fee = $root.coin.Coin.toObject(message.fee, options);
            return object;
        };

        /**
         * Converts this MsgFee to JSON.
         * @function toJSON
         * @memberof msgfee.MsgFee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgFee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgFee;
    })();

    msgfee.SetMsgFeeMsg = (function() {

        /**
         * Properties of a SetMsgFeeMsg.
         * @memberof msgfee
         * @interface ISetMsgFeeMsg
         * @property {weave.IMetadata|null} [metadata] SetMsgFeeMsg metadata
         * @property {string|null} [msgPath] SetMsgFeeMsg msgPath
         * @property {coin.ICoin|null} [fee] SetMsgFeeMsg fee
         */

        /**
         * Constructs a new SetMsgFeeMsg.
         * @memberof msgfee
         * @classdesc zero value coin to unset a fee.
         * @implements ISetMsgFeeMsg
         * @constructor
         * @param {msgfee.ISetMsgFeeMsg=} [properties] Properties to set
         */
        function SetMsgFeeMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetMsgFeeMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof msgfee.SetMsgFeeMsg
         * @instance
         */
        SetMsgFeeMsg.prototype.metadata = null;

        /**
         * SetMsgFeeMsg msgPath.
         * @member {string} msgPath
         * @memberof msgfee.SetMsgFeeMsg
         * @instance
         */
        SetMsgFeeMsg.prototype.msgPath = "";

        /**
         * SetMsgFeeMsg fee.
         * @member {coin.ICoin|null|undefined} fee
         * @memberof msgfee.SetMsgFeeMsg
         * @instance
         */
        SetMsgFeeMsg.prototype.fee = null;

        /**
         * Creates a new SetMsgFeeMsg instance using the specified properties.
         * @function create
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {msgfee.ISetMsgFeeMsg=} [properties] Properties to set
         * @returns {msgfee.SetMsgFeeMsg} SetMsgFeeMsg instance
         */
        SetMsgFeeMsg.create = function create(properties) {
            return new SetMsgFeeMsg(properties);
        };

        /**
         * Encodes the specified SetMsgFeeMsg message. Does not implicitly {@link msgfee.SetMsgFeeMsg.verify|verify} messages.
         * @function encode
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {msgfee.ISetMsgFeeMsg} message SetMsgFeeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMsgFeeMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msgPath);
            if (message.fee != null && message.hasOwnProperty("fee"))
                $root.coin.Coin.encode(message.fee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetMsgFeeMsg message, length delimited. Does not implicitly {@link msgfee.SetMsgFeeMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {msgfee.ISetMsgFeeMsg} message SetMsgFeeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetMsgFeeMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetMsgFeeMsg message from the specified reader or buffer.
         * @function decode
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgfee.SetMsgFeeMsg} SetMsgFeeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMsgFeeMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgfee.SetMsgFeeMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msgPath = reader.string();
                    break;
                case 3:
                    message.fee = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetMsgFeeMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgfee.SetMsgFeeMsg} SetMsgFeeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetMsgFeeMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetMsgFeeMsg message.
         * @function verify
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetMsgFeeMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                if (!$util.isString(message.msgPath))
                    return "msgPath: string expected";
            if (message.fee != null && message.hasOwnProperty("fee")) {
                var error = $root.coin.Coin.verify(message.fee);
                if (error)
                    return "fee." + error;
            }
            return null;
        };

        /**
         * Creates a SetMsgFeeMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgfee.SetMsgFeeMsg} SetMsgFeeMsg
         */
        SetMsgFeeMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.msgfee.SetMsgFeeMsg)
                return object;
            var message = new $root.msgfee.SetMsgFeeMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".msgfee.SetMsgFeeMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.msgPath != null)
                message.msgPath = String(object.msgPath);
            if (object.fee != null) {
                if (typeof object.fee !== "object")
                    throw TypeError(".msgfee.SetMsgFeeMsg.fee: object expected");
                message.fee = $root.coin.Coin.fromObject(object.fee);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetMsgFeeMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgfee.SetMsgFeeMsg
         * @static
         * @param {msgfee.SetMsgFeeMsg} message SetMsgFeeMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetMsgFeeMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.msgPath = "";
                object.fee = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                object.msgPath = message.msgPath;
            if (message.fee != null && message.hasOwnProperty("fee"))
                object.fee = $root.coin.Coin.toObject(message.fee, options);
            return object;
        };

        /**
         * Converts this SetMsgFeeMsg to JSON.
         * @function toJSON
         * @memberof msgfee.SetMsgFeeMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetMsgFeeMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetMsgFeeMsg;
    })();

    msgfee.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof msgfee
         * @interface IConfiguration
         * @property {weave.IMetadata|null} [metadata] Configuration metadata
         * @property {Uint8Array|null} [owner] needed to make use of gconf.NewUpdateConfigurationHandler
         * @property {Uint8Array|null} [feeAdmin] FeeAdmin is an address that is allowed to change the fee.
         */

        /**
         * Constructs a new Configuration.
         * @memberof msgfee
         * @classdesc Represents a Configuration.
         * @implements IConfiguration
         * @constructor
         * @param {msgfee.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Configuration metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof msgfee.Configuration
         * @instance
         */
        Configuration.prototype.metadata = null;

        /**
         * needed to make use of gconf.NewUpdateConfigurationHandler
         * @member {Uint8Array} owner
         * @memberof msgfee.Configuration
         * @instance
         */
        Configuration.prototype.owner = $util.newBuffer([]);

        /**
         * FeeAdmin is an address that is allowed to change the fee.
         * @member {Uint8Array} feeAdmin
         * @memberof msgfee.Configuration
         * @instance
         */
        Configuration.prototype.feeAdmin = $util.newBuffer([]);

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof msgfee.Configuration
         * @static
         * @param {msgfee.IConfiguration=} [properties] Properties to set
         * @returns {msgfee.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link msgfee.Configuration.verify|verify} messages.
         * @function encode
         * @memberof msgfee.Configuration
         * @static
         * @param {msgfee.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
            if (message.feeAdmin != null && message.hasOwnProperty("feeAdmin"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.feeAdmin);
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link msgfee.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgfee.Configuration
         * @static
         * @param {msgfee.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof msgfee.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgfee.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgfee.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.owner = reader.bytes();
                    break;
                case 3:
                    message.feeAdmin = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgfee.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgfee.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof msgfee.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.feeAdmin != null && message.hasOwnProperty("feeAdmin"))
                if (!(message.feeAdmin && typeof message.feeAdmin.length === "number" || $util.isString(message.feeAdmin)))
                    return "feeAdmin: buffer expected";
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgfee.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgfee.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.msgfee.Configuration)
                return object;
            var message = new $root.msgfee.Configuration();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".msgfee.Configuration.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.feeAdmin != null)
                if (typeof object.feeAdmin === "string")
                    $util.base64.decode(object.feeAdmin, message.feeAdmin = $util.newBuffer($util.base64.length(object.feeAdmin)), 0);
                else if (object.feeAdmin.length)
                    message.feeAdmin = object.feeAdmin;
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgfee.Configuration
         * @static
         * @param {msgfee.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                if (options.bytes === String)
                    object.feeAdmin = "";
                else {
                    object.feeAdmin = [];
                    if (options.bytes !== Array)
                        object.feeAdmin = $util.newBuffer(object.feeAdmin);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.feeAdmin != null && message.hasOwnProperty("feeAdmin"))
                object.feeAdmin = options.bytes === String ? $util.base64.encode(message.feeAdmin, 0, message.feeAdmin.length) : options.bytes === Array ? Array.prototype.slice.call(message.feeAdmin) : message.feeAdmin;
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof msgfee.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    msgfee.UpdateConfigurationMsg = (function() {

        /**
         * Properties of an UpdateConfigurationMsg.
         * @memberof msgfee
         * @interface IUpdateConfigurationMsg
         * @property {weave.IMetadata|null} [metadata] UpdateConfigurationMsg metadata
         * @property {msgfee.IConfiguration|null} [patch] UpdateConfigurationMsg patch
         */

        /**
         * Constructs a new UpdateConfigurationMsg.
         * @memberof msgfee
         * @classdesc Represents an UpdateConfigurationMsg.
         * @implements IUpdateConfigurationMsg
         * @constructor
         * @param {msgfee.IUpdateConfigurationMsg=} [properties] Properties to set
         */
        function UpdateConfigurationMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateConfigurationMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof msgfee.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.metadata = null;

        /**
         * UpdateConfigurationMsg patch.
         * @member {msgfee.IConfiguration|null|undefined} patch
         * @memberof msgfee.UpdateConfigurationMsg
         * @instance
         */
        UpdateConfigurationMsg.prototype.patch = null;

        /**
         * Creates a new UpdateConfigurationMsg instance using the specified properties.
         * @function create
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {msgfee.IUpdateConfigurationMsg=} [properties] Properties to set
         * @returns {msgfee.UpdateConfigurationMsg} UpdateConfigurationMsg instance
         */
        UpdateConfigurationMsg.create = function create(properties) {
            return new UpdateConfigurationMsg(properties);
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message. Does not implicitly {@link msgfee.UpdateConfigurationMsg.verify|verify} messages.
         * @function encode
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {msgfee.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.patch != null && message.hasOwnProperty("patch"))
                $root.msgfee.Configuration.encode(message.patch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateConfigurationMsg message, length delimited. Does not implicitly {@link msgfee.UpdateConfigurationMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {msgfee.IUpdateConfigurationMsg} message UpdateConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateConfigurationMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer.
         * @function decode
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgfee.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgfee.UpdateConfigurationMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.patch = $root.msgfee.Configuration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateConfigurationMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgfee.UpdateConfigurationMsg} UpdateConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateConfigurationMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateConfigurationMsg message.
         * @function verify
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateConfigurationMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.patch != null && message.hasOwnProperty("patch")) {
                var error = $root.msgfee.Configuration.verify(message.patch);
                if (error)
                    return "patch." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateConfigurationMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgfee.UpdateConfigurationMsg} UpdateConfigurationMsg
         */
        UpdateConfigurationMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.msgfee.UpdateConfigurationMsg)
                return object;
            var message = new $root.msgfee.UpdateConfigurationMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".msgfee.UpdateConfigurationMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.patch != null) {
                if (typeof object.patch !== "object")
                    throw TypeError(".msgfee.UpdateConfigurationMsg.patch: object expected");
                message.patch = $root.msgfee.Configuration.fromObject(object.patch);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateConfigurationMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgfee.UpdateConfigurationMsg
         * @static
         * @param {msgfee.UpdateConfigurationMsg} message UpdateConfigurationMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateConfigurationMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.patch = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = $root.msgfee.Configuration.toObject(message.patch, options);
            return object;
        };

        /**
         * Converts this UpdateConfigurationMsg to JSON.
         * @function toJSON
         * @memberof msgfee.UpdateConfigurationMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateConfigurationMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateConfigurationMsg;
    })();

    return msgfee;
})();

$root.multisig = (function() {

    /**
     * Namespace multisig.
     * @exports multisig
     * @namespace
     */
    var multisig = {};

    multisig.Contract = (function() {

        /**
         * Properties of a Contract.
         * @memberof multisig
         * @interface IContract
         * @property {weave.IMetadata|null} [metadata] Contract metadata
         * @property {Array.<multisig.IParticipant>|null} [participants] contract.
         * @property {number|null} [activationThreshold] computed as the sum of weights of all participating signatures.
         * @property {number|null} [adminThreshold] computed as the sum of weights of all participating signatures.
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new Contract.
         * @memberof multisig
         * @classdesc Represents a Contract.
         * @implements IContract
         * @constructor
         * @param {multisig.IContract=} [properties] Properties to set
         */
        function Contract(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Contract metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.metadata = null;

        /**
         * contract.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.participants = $util.emptyArray;

        /**
         * computed as the sum of weights of all participating signatures.
         * @member {number} activationThreshold
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.activationThreshold = 0;

        /**
         * computed as the sum of weights of all participating signatures.
         * @member {number} adminThreshold
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.adminThreshold = 0;

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new Contract instance using the specified properties.
         * @function create
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract=} [properties] Properties to set
         * @returns {multisig.Contract} Contract instance
         */
        Contract.create = function create(properties) {
            return new Contract(properties);
        };

        /**
         * Encodes the specified Contract message. Does not implicitly {@link multisig.Contract.verify|verify} messages.
         * @function encode
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract} message Contract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.adminThreshold);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified Contract message, length delimited. Does not implicitly {@link multisig.Contract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract} message Contract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Contract message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.Contract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.Contract} Contract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.Contract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.activationThreshold = reader.uint32();
                    break;
                case 4:
                    message.adminThreshold = reader.uint32();
                    break;
                case 5:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Contract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.Contract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.Contract} Contract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Contract message.
         * @function verify
         * @memberof multisig.Contract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Contract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates a Contract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.Contract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.Contract} Contract
         */
        Contract.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.Contract)
                return object;
            var message = new $root.multisig.Contract();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.Contract.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.Contract.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.Contract.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from a Contract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.Contract
         * @static
         * @param {multisig.Contract} message Contract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Contract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                object.activationThreshold = 0;
                object.adminThreshold = 0;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this Contract to JSON.
         * @function toJSON
         * @memberof multisig.Contract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Contract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Contract;
    })();

    multisig.Participant = (function() {

        /**
         * Properties of a Participant.
         * @memberof multisig
         * @interface IParticipant
         * @property {Uint8Array|null} [signature] Participant signature
         * @property {number|null} [weight] Participant weight
         */

        /**
         * Constructs a new Participant.
         * @memberof multisig
         * @classdesc the greater the power of a signature.
         * @implements IParticipant
         * @constructor
         * @param {multisig.IParticipant=} [properties] Properties to set
         */
        function Participant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Participant signature.
         * @member {Uint8Array} signature
         * @memberof multisig.Participant
         * @instance
         */
        Participant.prototype.signature = $util.newBuffer([]);

        /**
         * Participant weight.
         * @member {number} weight
         * @memberof multisig.Participant
         * @instance
         */
        Participant.prototype.weight = 0;

        /**
         * Creates a new Participant instance using the specified properties.
         * @function create
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant=} [properties] Properties to set
         * @returns {multisig.Participant} Participant instance
         */
        Participant.create = function create(properties) {
            return new Participant(properties);
        };

        /**
         * Encodes the specified Participant message. Does not implicitly {@link multisig.Participant.verify|verify} messages.
         * @function encode
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant} message Participant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Participant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Participant message, length delimited. Does not implicitly {@link multisig.Participant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant} message Participant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Participant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Participant message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.Participant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.Participant} Participant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Participant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.Participant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Participant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.Participant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.Participant} Participant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Participant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Participant message.
         * @function verify
         * @memberof multisig.Participant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Participant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates a Participant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.Participant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.Participant} Participant
         */
        Participant.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.Participant)
                return object;
            var message = new $root.multisig.Participant();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.weight != null)
                message.weight = object.weight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Participant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.Participant
         * @static
         * @param {multisig.Participant} message Participant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Participant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.weight = 0;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Participant to JSON.
         * @function toJSON
         * @memberof multisig.Participant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Participant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Participant;
    })();

    multisig.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof multisig
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {Array.<multisig.IParticipant>|null} [participants] CreateMsg participants
         * @property {number|null} [activationThreshold] CreateMsg activationThreshold
         * @property {number|null} [adminThreshold] CreateMsg adminThreshold
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof multisig
         * @classdesc Represents a CreateMsg.
         * @implements ICreateMsg
         * @constructor
         * @param {multisig.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * CreateMsg participants.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.CreateMsg
         * @instance
         */
        CreateMsg.prototype.participants = $util.emptyArray;

        /**
         * CreateMsg activationThreshold.
         * @member {number} activationThreshold
         * @memberof multisig.CreateMsg
         * @instance
         */
        CreateMsg.prototype.activationThreshold = 0;

        /**
         * CreateMsg adminThreshold.
         * @member {number} adminThreshold
         * @memberof multisig.CreateMsg
         * @instance
         */
        CreateMsg.prototype.adminThreshold = 0;

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof multisig.CreateMsg
         * @static
         * @param {multisig.ICreateMsg=} [properties] Properties to set
         * @returns {multisig.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link multisig.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof multisig.CreateMsg
         * @static
         * @param {multisig.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.adminThreshold);
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link multisig.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.CreateMsg
         * @static
         * @param {multisig.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.activationThreshold = reader.uint32();
                    break;
                case 4:
                    message.adminThreshold = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof multisig.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.CreateMsg)
                return object;
            var message = new $root.multisig.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.CreateMsg.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.CreateMsg.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.CreateMsg
         * @static
         * @param {multisig.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                object.activationThreshold = 0;
                object.adminThreshold = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof multisig.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    multisig.UpdateMsg = (function() {

        /**
         * Properties of an UpdateMsg.
         * @memberof multisig
         * @interface IUpdateMsg
         * @property {weave.IMetadata|null} [metadata] UpdateMsg metadata
         * @property {Uint8Array|null} [contractId] UpdateMsg contractId
         * @property {Array.<multisig.IParticipant>|null} [participants] UpdateMsg participants
         * @property {number|null} [activationThreshold] UpdateMsg activationThreshold
         * @property {number|null} [adminThreshold] UpdateMsg adminThreshold
         */

        /**
         * Constructs a new UpdateMsg.
         * @memberof multisig
         * @classdesc Represents an UpdateMsg.
         * @implements IUpdateMsg
         * @constructor
         * @param {multisig.IUpdateMsg=} [properties] Properties to set
         */
        function UpdateMsg(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.UpdateMsg
         * @instance
         */
        UpdateMsg.prototype.metadata = null;

        /**
         * UpdateMsg contractId.
         * @member {Uint8Array} contractId
         * @memberof multisig.UpdateMsg
         * @instance
         */
        UpdateMsg.prototype.contractId = $util.newBuffer([]);

        /**
         * UpdateMsg participants.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.UpdateMsg
         * @instance
         */
        UpdateMsg.prototype.participants = $util.emptyArray;

        /**
         * UpdateMsg activationThreshold.
         * @member {number} activationThreshold
         * @memberof multisig.UpdateMsg
         * @instance
         */
        UpdateMsg.prototype.activationThreshold = 0;

        /**
         * UpdateMsg adminThreshold.
         * @member {number} adminThreshold
         * @memberof multisig.UpdateMsg
         * @instance
         */
        UpdateMsg.prototype.adminThreshold = 0;

        /**
         * Creates a new UpdateMsg instance using the specified properties.
         * @function create
         * @memberof multisig.UpdateMsg
         * @static
         * @param {multisig.IUpdateMsg=} [properties] Properties to set
         * @returns {multisig.UpdateMsg} UpdateMsg instance
         */
        UpdateMsg.create = function create(properties) {
            return new UpdateMsg(properties);
        };

        /**
         * Encodes the specified UpdateMsg message. Does not implicitly {@link multisig.UpdateMsg.verify|verify} messages.
         * @function encode
         * @memberof multisig.UpdateMsg
         * @static
         * @param {multisig.IUpdateMsg} message UpdateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractId);
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.adminThreshold);
            return writer;
        };

        /**
         * Encodes the specified UpdateMsg message, length delimited. Does not implicitly {@link multisig.UpdateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.UpdateMsg
         * @static
         * @param {multisig.IUpdateMsg} message UpdateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.UpdateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.UpdateMsg} UpdateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.UpdateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.contractId = reader.bytes();
                    break;
                case 3:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.activationThreshold = reader.uint32();
                    break;
                case 5:
                    message.adminThreshold = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.UpdateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.UpdateMsg} UpdateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMsg message.
         * @function verify
         * @memberof multisig.UpdateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                if (!(message.contractId && typeof message.contractId.length === "number" || $util.isString(message.contractId)))
                    return "contractId: buffer expected";
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            return null;
        };

        /**
         * Creates an UpdateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.UpdateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.UpdateMsg} UpdateMsg
         */
        UpdateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.UpdateMsg)
                return object;
            var message = new $root.multisig.UpdateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.UpdateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.contractId != null)
                if (typeof object.contractId === "string")
                    $util.base64.decode(object.contractId, message.contractId = $util.newBuffer($util.base64.length(object.contractId)), 0);
                else if (object.contractId.length)
                    message.contractId = object.contractId;
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.UpdateMsg.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.UpdateMsg.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an UpdateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.UpdateMsg
         * @static
         * @param {multisig.UpdateMsg} message UpdateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.contractId = "";
                else {
                    object.contractId = [];
                    if (options.bytes !== Array)
                        object.contractId = $util.newBuffer(object.contractId);
                }
                object.activationThreshold = 0;
                object.adminThreshold = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                object.contractId = options.bytes === String ? $util.base64.encode(message.contractId, 0, message.contractId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractId) : message.contractId;
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            return object;
        };

        /**
         * Converts this UpdateMsg to JSON.
         * @function toJSON
         * @memberof multisig.UpdateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateMsg;
    })();

    return multisig;
})();

$root.paychan = (function() {

    /**
     * Namespace paychan.
     * @exports paychan
     * @namespace
     */
    var paychan = {};

    paychan.PaymentChannel = (function() {

        /**
         * Properties of a PaymentChannel.
         * @memberof paychan
         * @interface IPaymentChannel
         * @property {weave.IMetadata|null} [metadata] PaymentChannel metadata
         * @property {Uint8Array|null} [source] Source is the source that the founds are allocated from.
         * @property {crypto.IPublicKey|null} [sourcePubkey] to the destination. Signature prevents from altering transfer message.
         * @property {Uint8Array|null} [destination] Destination is the party that receives payments through this channel
         * @property {coin.ICoin|null} [total] payment channel.
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] Max length 128 character.
         * @property {coin.ICoin|null} [transferred] (total) value. Transferred must never exceed total value.
         * @property {Uint8Array|null} [address] Address of this entity. Set during creation and does not change.
         */

        /**
         * Constructs a new PaymentChannel.
         * @memberof paychan
         * @classdesc PaymentChannel holds the state of a payment channel during its lifetime.
         * @implements IPaymentChannel
         * @constructor
         * @param {paychan.IPaymentChannel=} [properties] Properties to set
         */
        function PaymentChannel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentChannel metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.metadata = null;

        /**
         * Source is the source that the founds are allocated from.
         * @member {Uint8Array} source
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.source = $util.newBuffer([]);

        /**
         * to the destination. Signature prevents from altering transfer message.
         * @member {crypto.IPublicKey|null|undefined} sourcePubkey
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.sourcePubkey = null;

        /**
         * Destination is the party that receives payments through this channel
         * @member {Uint8Array} destination
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.destination = $util.newBuffer([]);

        /**
         * payment channel.
         * @member {coin.ICoin|null|undefined} total
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.total = null;

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.memo = "";

        /**
         * (total) value. Transferred must never exceed total value.
         * @member {coin.ICoin|null|undefined} transferred
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.transferred = null;

        /**
         * Address of this entity. Set during creation and does not change.
         * @member {Uint8Array} address
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new PaymentChannel instance using the specified properties.
         * @function create
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel=} [properties] Properties to set
         * @returns {paychan.PaymentChannel} PaymentChannel instance
         */
        PaymentChannel.create = function create(properties) {
            return new PaymentChannel(properties);
        };

        /**
         * Encodes the specified PaymentChannel message. Does not implicitly {@link paychan.PaymentChannel.verify|verify} messages.
         * @function encode
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel} message PaymentChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey"))
                $root.crypto.PublicKey.encode(message.sourcePubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.destination);
            if (message.total != null && message.hasOwnProperty("total"))
                $root.coin.Coin.encode(message.total, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            if (message.transferred != null && message.hasOwnProperty("transferred"))
                $root.coin.Coin.encode(message.transferred, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified PaymentChannel message, length delimited. Does not implicitly {@link paychan.PaymentChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel} message PaymentChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentChannel message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.PaymentChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.PaymentChannel} PaymentChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.PaymentChannel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.sourcePubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.destination = reader.bytes();
                    break;
                case 5:
                    message.total = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                case 8:
                    message.transferred = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.PaymentChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.PaymentChannel} PaymentChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentChannel message.
         * @function verify
         * @memberof paychan.PaymentChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey")) {
                var error = $root.crypto.PublicKey.verify(message.sourcePubkey);
                if (error)
                    return "sourcePubkey." + error;
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.total != null && message.hasOwnProperty("total")) {
                var error = $root.coin.Coin.verify(message.total);
                if (error)
                    return "total." + error;
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.transferred != null && message.hasOwnProperty("transferred")) {
                var error = $root.coin.Coin.verify(message.transferred);
                if (error)
                    return "transferred." + error;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates a PaymentChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.PaymentChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.PaymentChannel} PaymentChannel
         */
        PaymentChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.PaymentChannel)
                return object;
            var message = new $root.paychan.PaymentChannel();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.PaymentChannel.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.sourcePubkey != null) {
                if (typeof object.sourcePubkey !== "object")
                    throw TypeError(".paychan.PaymentChannel.sourcePubkey: object expected");
                message.sourcePubkey = $root.crypto.PublicKey.fromObject(object.sourcePubkey);
            }
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.total != null) {
                if (typeof object.total !== "object")
                    throw TypeError(".paychan.PaymentChannel.total: object expected");
                message.total = $root.coin.Coin.fromObject(object.total);
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.transferred != null) {
                if (typeof object.transferred !== "object")
                    throw TypeError(".paychan.PaymentChannel.transferred: object expected");
                message.transferred = $root.coin.Coin.fromObject(object.transferred);
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from a PaymentChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.PaymentChannel} message PaymentChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                object.sourcePubkey = null;
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                object.total = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
                object.transferred = null;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey"))
                object.sourcePubkey = $root.crypto.PublicKey.toObject(message.sourcePubkey, options);
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = $root.coin.Coin.toObject(message.total, options);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.transferred != null && message.hasOwnProperty("transferred"))
                object.transferred = $root.coin.Coin.toObject(message.transferred, options);
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this PaymentChannel to JSON.
         * @function toJSON
         * @memberof paychan.PaymentChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentChannel;
    })();

    paychan.CreateMsg = (function() {

        /**
         * Properties of a CreateMsg.
         * @memberof paychan
         * @interface ICreateMsg
         * @property {weave.IMetadata|null} [metadata] CreateMsg metadata
         * @property {Uint8Array|null} [source] Source address (weave.Address).
         * @property {crypto.IPublicKey|null} [sourcePubkey] Source public key is for validating transfer message signature.
         * @property {Uint8Array|null} [destination] Destination address  (weave.Address).
         * @property {coin.ICoin|null} [total] Maximum amount that can be transferred via this channel.
         * @property {number|Long|null} [timeout] If reached, channel can be closed by anyone.
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new CreateMsg.
         * @memberof paychan
         * @classdesc in the transactions done via created payment channel.
         * @implements ICreateMsg
         * @constructor
         * @param {paychan.ICreateMsg=} [properties] Properties to set
         */
        function CreateMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.metadata = null;

        /**
         * Source address (weave.Address).
         * @member {Uint8Array} source
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.source = $util.newBuffer([]);

        /**
         * Source public key is for validating transfer message signature.
         * @member {crypto.IPublicKey|null|undefined} sourcePubkey
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.sourcePubkey = null;

        /**
         * Destination address  (weave.Address).
         * @member {Uint8Array} destination
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.destination = $util.newBuffer([]);

        /**
         * Maximum amount that can be transferred via this channel.
         * @member {coin.ICoin|null|undefined} total
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.total = null;

        /**
         * If reached, channel can be closed by anyone.
         * @member {number|Long} timeout
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.CreateMsg
         * @instance
         */
        CreateMsg.prototype.memo = "";

        /**
         * Creates a new CreateMsg instance using the specified properties.
         * @function create
         * @memberof paychan.CreateMsg
         * @static
         * @param {paychan.ICreateMsg=} [properties] Properties to set
         * @returns {paychan.CreateMsg} CreateMsg instance
         */
        CreateMsg.create = function create(properties) {
            return new CreateMsg(properties);
        };

        /**
         * Encodes the specified CreateMsg message. Does not implicitly {@link paychan.CreateMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.CreateMsg
         * @static
         * @param {paychan.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.source != null && message.hasOwnProperty("source"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey"))
                $root.crypto.PublicKey.encode(message.sourcePubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.destination);
            if (message.total != null && message.hasOwnProperty("total"))
                $root.coin.Coin.encode(message.total, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreateMsg message, length delimited. Does not implicitly {@link paychan.CreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.CreateMsg
         * @static
         * @param {paychan.ICreateMsg} message CreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.CreateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.source = reader.bytes();
                    break;
                case 3:
                    message.sourcePubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.destination = reader.bytes();
                    break;
                case 5:
                    message.total = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.CreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.CreateMsg} CreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateMsg message.
         * @function verify
         * @memberof paychan.CreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.source != null && message.hasOwnProperty("source"))
                if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                    return "source: buffer expected";
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey")) {
                var error = $root.crypto.PublicKey.verify(message.sourcePubkey);
                if (error)
                    return "sourcePubkey." + error;
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!(message.destination && typeof message.destination.length === "number" || $util.isString(message.destination)))
                    return "destination: buffer expected";
            if (message.total != null && message.hasOwnProperty("total")) {
                var error = $root.coin.Coin.verify(message.total);
                if (error)
                    return "total." + error;
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.CreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.CreateMsg} CreateMsg
         */
        CreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.CreateMsg)
                return object;
            var message = new $root.paychan.CreateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.CreateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.source != null)
                if (typeof object.source === "string")
                    $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                else if (object.source.length)
                    message.source = object.source;
            if (object.sourcePubkey != null) {
                if (typeof object.sourcePubkey !== "object")
                    throw TypeError(".paychan.CreateMsg.sourcePubkey: object expected");
                message.sourcePubkey = $root.crypto.PublicKey.fromObject(object.sourcePubkey);
            }
            if (object.destination != null)
                if (typeof object.destination === "string")
                    $util.base64.decode(object.destination, message.destination = $util.newBuffer($util.base64.length(object.destination)), 0);
                else if (object.destination.length)
                    message.destination = object.destination;
            if (object.total != null) {
                if (typeof object.total !== "object")
                    throw TypeError(".paychan.CreateMsg.total: object expected");
                message.total = $root.coin.Coin.fromObject(object.total);
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.CreateMsg
         * @static
         * @param {paychan.CreateMsg} message CreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.source = "";
                else {
                    object.source = [];
                    if (options.bytes !== Array)
                        object.source = $util.newBuffer(object.source);
                }
                object.sourcePubkey = null;
                if (options.bytes === String)
                    object.destination = "";
                else {
                    object.destination = [];
                    if (options.bytes !== Array)
                        object.destination = $util.newBuffer(object.destination);
                }
                object.total = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
            if (message.sourcePubkey != null && message.hasOwnProperty("sourcePubkey"))
                object.sourcePubkey = $root.crypto.PublicKey.toObject(message.sourcePubkey, options);
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = options.bytes === String ? $util.base64.encode(message.destination, 0, message.destination.length) : options.bytes === Array ? Array.prototype.slice.call(message.destination) : message.destination;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = $root.coin.Coin.toObject(message.total, options);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreateMsg to JSON.
         * @function toJSON
         * @memberof paychan.CreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateMsg;
    })();

    paychan.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof paychan
         * @interface IPayment
         * @property {string|null} [chainId] Payment chainId
         * @property {Uint8Array|null} [channelId] Payment channelId
         * @property {coin.ICoin|null} [amount] Payment amount
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new Payment.
         * @memberof paychan
         * @classdesc Each Payment should be created with amount greater than the previous one.
         * @implements IPayment
         * @constructor
         * @param {paychan.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payment chainId.
         * @member {string} chainId
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.chainId = "";

        /**
         * Payment channelId.
         * @member {Uint8Array} channelId
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.channelId = $util.newBuffer([]);

        /**
         * Payment amount.
         * @member {coin.ICoin|null|undefined} amount
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.amount = null;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.memo = "";

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment=} [properties] Properties to set
         * @returns {paychan.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link paychan.Payment.verify|verify} messages.
         * @function encode
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channelId);
            if (message.amount != null && message.hasOwnProperty("amount"))
                $root.coin.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link paychan.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.Payment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chainId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.bytes();
                    break;
                case 3:
                    message.amount = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof paychan.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isString(message.chainId))
                    return "chainId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                var error = $root.coin.Coin.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.Payment)
                return object;
            var message = new $root.paychan.Payment();
            if (object.chainId != null)
                message.chainId = String(object.chainId);
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length)
                    message.channelId = object.channelId;
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".paychan.Payment.amount: object expected");
                message.amount = $root.coin.Coin.fromObject(object.amount);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.Payment
         * @static
         * @param {paychan.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chainId = "";
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.amount = null;
                object.memo = "";
            }
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.coin.Coin.toObject(message.amount, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof paychan.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Payment;
    })();

    paychan.TransferMsg = (function() {

        /**
         * Properties of a TransferMsg.
         * @memberof paychan
         * @interface ITransferMsg
         * @property {weave.IMetadata|null} [metadata] TransferMsg metadata
         * @property {paychan.IPayment|null} [payment] TransferMsg payment
         * @property {crypto.ISignature|null} [signature] TransferMsg signature
         */

        /**
         * Constructs a new TransferMsg.
         * @memberof paychan
         * @classdesc Signature is there to ensure that payment message was not altered.
         * @implements ITransferMsg
         * @constructor
         * @param {paychan.ITransferMsg=} [properties] Properties to set
         */
        function TransferMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.TransferMsg
         * @instance
         */
        TransferMsg.prototype.metadata = null;

        /**
         * TransferMsg payment.
         * @member {paychan.IPayment|null|undefined} payment
         * @memberof paychan.TransferMsg
         * @instance
         */
        TransferMsg.prototype.payment = null;

        /**
         * TransferMsg signature.
         * @member {crypto.ISignature|null|undefined} signature
         * @memberof paychan.TransferMsg
         * @instance
         */
        TransferMsg.prototype.signature = null;

        /**
         * Creates a new TransferMsg instance using the specified properties.
         * @function create
         * @memberof paychan.TransferMsg
         * @static
         * @param {paychan.ITransferMsg=} [properties] Properties to set
         * @returns {paychan.TransferMsg} TransferMsg instance
         */
        TransferMsg.create = function create(properties) {
            return new TransferMsg(properties);
        };

        /**
         * Encodes the specified TransferMsg message. Does not implicitly {@link paychan.TransferMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.TransferMsg
         * @static
         * @param {paychan.ITransferMsg} message TransferMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payment != null && message.hasOwnProperty("payment"))
                $root.paychan.Payment.encode(message.payment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signature != null && message.hasOwnProperty("signature"))
                $root.crypto.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransferMsg message, length delimited. Does not implicitly {@link paychan.TransferMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.TransferMsg
         * @static
         * @param {paychan.ITransferMsg} message TransferMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.TransferMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.TransferMsg} TransferMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.TransferMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payment = $root.paychan.Payment.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signature = $root.crypto.Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.TransferMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.TransferMsg} TransferMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferMsg message.
         * @function verify
         * @memberof paychan.TransferMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.payment != null && message.hasOwnProperty("payment")) {
                var error = $root.paychan.Payment.verify(message.payment);
                if (error)
                    return "payment." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                var error = $root.crypto.Signature.verify(message.signature);
                if (error)
                    return "signature." + error;
            }
            return null;
        };

        /**
         * Creates a TransferMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.TransferMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.TransferMsg} TransferMsg
         */
        TransferMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.TransferMsg)
                return object;
            var message = new $root.paychan.TransferMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.TransferMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.payment != null) {
                if (typeof object.payment !== "object")
                    throw TypeError(".paychan.TransferMsg.payment: object expected");
                message.payment = $root.paychan.Payment.fromObject(object.payment);
            }
            if (object.signature != null) {
                if (typeof object.signature !== "object")
                    throw TypeError(".paychan.TransferMsg.signature: object expected");
                message.signature = $root.crypto.Signature.fromObject(object.signature);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransferMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.TransferMsg
         * @static
         * @param {paychan.TransferMsg} message TransferMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.payment = null;
                object.signature = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.payment != null && message.hasOwnProperty("payment"))
                object.payment = $root.paychan.Payment.toObject(message.payment, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = $root.crypto.Signature.toObject(message.signature, options);
            return object;
        };

        /**
         * Converts this TransferMsg to JSON.
         * @function toJSON
         * @memberof paychan.TransferMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferMsg;
    })();

    paychan.CloseMsg = (function() {

        /**
         * Properties of a CloseMsg.
         * @memberof paychan
         * @interface ICloseMsg
         * @property {weave.IMetadata|null} [metadata] CloseMsg metadata
         * @property {Uint8Array|null} [channelId] CloseMsg channelId
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new CloseMsg.
         * @memberof paychan
         * @classdesc Source can close channel only if the timeout was reached.
         * @implements ICloseMsg
         * @constructor
         * @param {paychan.ICloseMsg=} [properties] Properties to set
         */
        function CloseMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.CloseMsg
         * @instance
         */
        CloseMsg.prototype.metadata = null;

        /**
         * CloseMsg channelId.
         * @member {Uint8Array} channelId
         * @memberof paychan.CloseMsg
         * @instance
         */
        CloseMsg.prototype.channelId = $util.newBuffer([]);

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.CloseMsg
         * @instance
         */
        CloseMsg.prototype.memo = "";

        /**
         * Creates a new CloseMsg instance using the specified properties.
         * @function create
         * @memberof paychan.CloseMsg
         * @static
         * @param {paychan.ICloseMsg=} [properties] Properties to set
         * @returns {paychan.CloseMsg} CloseMsg instance
         */
        CloseMsg.create = function create(properties) {
            return new CloseMsg(properties);
        };

        /**
         * Encodes the specified CloseMsg message. Does not implicitly {@link paychan.CloseMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.CloseMsg
         * @static
         * @param {paychan.ICloseMsg} message CloseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channelId);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CloseMsg message, length delimited. Does not implicitly {@link paychan.CloseMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.CloseMsg
         * @static
         * @param {paychan.ICloseMsg} message CloseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.CloseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.CloseMsg} CloseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.CloseMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelId = reader.bytes();
                    break;
                case 3:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.CloseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.CloseMsg} CloseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseMsg message.
         * @function verify
         * @memberof paychan.CloseMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CloseMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.CloseMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.CloseMsg} CloseMsg
         */
        CloseMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.CloseMsg)
                return object;
            var message = new $root.paychan.CloseMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.CloseMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length)
                    message.channelId = object.channelId;
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CloseMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.CloseMsg
         * @static
         * @param {paychan.CloseMsg} message CloseMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CloseMsg to JSON.
         * @function toJSON
         * @memberof paychan.CloseMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseMsg;
    })();

    return paychan;
})();

$root.sigs = (function() {

    /**
     * Namespace sigs.
     * @exports sigs
     * @namespace
     */
    var sigs = {};

    sigs.UserData = (function() {

        /**
         * Properties of a UserData.
         * @memberof sigs
         * @interface IUserData
         * @property {weave.IMetadata|null} [metadata] UserData metadata
         * @property {crypto.IPublicKey|null} [pubkey] UserData pubkey
         * @property {number|Long|null} [sequence] UserData sequence
         */

        /**
         * Constructs a new UserData.
         * @memberof sigs
         * @classdesc User is the entry point you want
         * @implements IUserData
         * @constructor
         * @param {sigs.IUserData=} [properties] Properties to set
         */
        function UserData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserData metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.metadata = null;

        /**
         * UserData pubkey.
         * @member {crypto.IPublicKey|null|undefined} pubkey
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.pubkey = null;

        /**
         * UserData sequence.
         * @member {number|Long} sequence
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserData instance using the specified properties.
         * @function create
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData=} [properties] Properties to set
         * @returns {sigs.UserData} UserData instance
         */
        UserData.create = function create(properties) {
            return new UserData(properties);
        };

        /**
         * Encodes the specified UserData message. Does not implicitly {@link sigs.UserData.verify|verify} messages.
         * @function encode
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData} message UserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                $root.crypto.PublicKey.encode(message.pubkey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sequence);
            return writer;
        };

        /**
         * Encodes the specified UserData message, length delimited. Does not implicitly {@link sigs.UserData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData} message UserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserData message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.UserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.UserData} UserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.UserData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sequence = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.UserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.UserData} UserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserData message.
         * @function verify
         * @memberof sigs.UserData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey")) {
                var error = $root.crypto.PublicKey.verify(message.pubkey);
                if (error)
                    return "pubkey." + error;
            }
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.UserData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.UserData} UserData
         */
        UserData.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.UserData)
                return object;
            var message = new $root.sigs.UserData();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".sigs.UserData.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pubkey != null) {
                if (typeof object.pubkey !== "object")
                    throw TypeError(".sigs.UserData.pubkey: object expected");
                message.pubkey = $root.crypto.PublicKey.fromObject(object.pubkey);
            }
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.UserData
         * @static
         * @param {sigs.UserData} message UserData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pubkey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = $root.crypto.PublicKey.toObject(message.pubkey, options);
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            return object;
        };

        /**
         * Converts this UserData to JSON.
         * @function toJSON
         * @memberof sigs.UserData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserData;
    })();

    sigs.StdSignature = (function() {

        /**
         * Properties of a StdSignature.
         * @memberof sigs
         * @interface IStdSignature
         * @property {number|Long|null} [sequence] StdSignature sequence
         * @property {crypto.IPublicKey|null} [pubkey] StdSignature pubkey
         * @property {crypto.ISignature|null} [signature] Removed Address, Pubkey is more powerful
         */

        /**
         * Constructs a new StdSignature.
         * @memberof sigs
         * @classdesc increasing by 1 each time (starting at 0)
         * @implements IStdSignature
         * @constructor
         * @param {sigs.IStdSignature=} [properties] Properties to set
         */
        function StdSignature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StdSignature sequence.
         * @member {number|Long} sequence
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StdSignature pubkey.
         * @member {crypto.IPublicKey|null|undefined} pubkey
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.pubkey = null;

        /**
         * Removed Address, Pubkey is more powerful
         * @member {crypto.ISignature|null|undefined} signature
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.signature = null;

        /**
         * Creates a new StdSignature instance using the specified properties.
         * @function create
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature=} [properties] Properties to set
         * @returns {sigs.StdSignature} StdSignature instance
         */
        StdSignature.create = function create(properties) {
            return new StdSignature(properties);
        };

        /**
         * Encodes the specified StdSignature message. Does not implicitly {@link sigs.StdSignature.verify|verify} messages.
         * @function encode
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature} message StdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StdSignature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                $root.crypto.PublicKey.encode(message.pubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.signature != null && message.hasOwnProperty("signature"))
                $root.crypto.Signature.encode(message.signature, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StdSignature message, length delimited. Does not implicitly {@link sigs.StdSignature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature} message StdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StdSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.StdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.StdSignature} StdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StdSignature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.StdSignature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.sequence = reader.int64();
                    break;
                case 3:
                    message.pubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = $root.crypto.Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StdSignature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.StdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.StdSignature} StdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StdSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StdSignature message.
         * @function verify
         * @memberof sigs.StdSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StdSignature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey")) {
                var error = $root.crypto.PublicKey.verify(message.pubkey);
                if (error)
                    return "pubkey." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                var error = $root.crypto.Signature.verify(message.signature);
                if (error)
                    return "signature." + error;
            }
            return null;
        };

        /**
         * Creates a StdSignature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.StdSignature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.StdSignature} StdSignature
         */
        StdSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.StdSignature)
                return object;
            var message = new $root.sigs.StdSignature();
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            if (object.pubkey != null) {
                if (typeof object.pubkey !== "object")
                    throw TypeError(".sigs.StdSignature.pubkey: object expected");
                message.pubkey = $root.crypto.PublicKey.fromObject(object.pubkey);
            }
            if (object.signature != null) {
                if (typeof object.signature !== "object")
                    throw TypeError(".sigs.StdSignature.signature: object expected");
                message.signature = $root.crypto.Signature.fromObject(object.signature);
            }
            return message;
        };

        /**
         * Creates a plain object from a StdSignature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.StdSignature} message StdSignature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StdSignature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
                object.pubkey = null;
                object.signature = null;
            }
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = $root.crypto.PublicKey.toObject(message.pubkey, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = $root.crypto.Signature.toObject(message.signature, options);
            return object;
        };

        /**
         * Converts this StdSignature to JSON.
         * @function toJSON
         * @memberof sigs.StdSignature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StdSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StdSignature;
    })();

    sigs.BumpSequenceMsg = (function() {

        /**
         * Properties of a BumpSequenceMsg.
         * @memberof sigs
         * @interface IBumpSequenceMsg
         * @property {weave.IMetadata|null} [metadata] BumpSequenceMsg metadata
         * @property {number|null} [increment] total increment value, including the default increment.
         */

        /**
         * Constructs a new BumpSequenceMsg.
         * @memberof sigs
         * @classdesc that signed the transaction.
         * @implements IBumpSequenceMsg
         * @constructor
         * @param {sigs.IBumpSequenceMsg=} [properties] Properties to set
         */
        function BumpSequenceMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BumpSequenceMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof sigs.BumpSequenceMsg
         * @instance
         */
        BumpSequenceMsg.prototype.metadata = null;

        /**
         * total increment value, including the default increment.
         * @member {number} increment
         * @memberof sigs.BumpSequenceMsg
         * @instance
         */
        BumpSequenceMsg.prototype.increment = 0;

        /**
         * Creates a new BumpSequenceMsg instance using the specified properties.
         * @function create
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg=} [properties] Properties to set
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg instance
         */
        BumpSequenceMsg.create = function create(properties) {
            return new BumpSequenceMsg(properties);
        };

        /**
         * Encodes the specified BumpSequenceMsg message. Does not implicitly {@link sigs.BumpSequenceMsg.verify|verify} messages.
         * @function encode
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg} message BumpSequenceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BumpSequenceMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.increment != null && message.hasOwnProperty("increment"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.increment);
            return writer;
        };

        /**
         * Encodes the specified BumpSequenceMsg message, length delimited. Does not implicitly {@link sigs.BumpSequenceMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg} message BumpSequenceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BumpSequenceMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BumpSequenceMsg message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BumpSequenceMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.BumpSequenceMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.increment = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BumpSequenceMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BumpSequenceMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BumpSequenceMsg message.
         * @function verify
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BumpSequenceMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.increment != null && message.hasOwnProperty("increment"))
                if (!$util.isInteger(message.increment))
                    return "increment: integer expected";
            return null;
        };

        /**
         * Creates a BumpSequenceMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         */
        BumpSequenceMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.BumpSequenceMsg)
                return object;
            var message = new $root.sigs.BumpSequenceMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".sigs.BumpSequenceMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.increment != null)
                message.increment = object.increment >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BumpSequenceMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.BumpSequenceMsg} message BumpSequenceMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BumpSequenceMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.increment = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.increment != null && message.hasOwnProperty("increment"))
                object.increment = message.increment;
            return object;
        };

        /**
         * Converts this BumpSequenceMsg to JSON.
         * @function toJSON
         * @memberof sigs.BumpSequenceMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BumpSequenceMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BumpSequenceMsg;
    })();

    return sigs;
})();

$root.validators = (function() {

    /**
     * Namespace validators.
     * @exports validators
     * @namespace
     */
    var validators = {};

    validators.ApplyDiffMsg = (function() {

        /**
         * Properties of an ApplyDiffMsg.
         * @memberof validators
         * @interface IApplyDiffMsg
         * @property {weave.IMetadata|null} [metadata] ApplyDiffMsg metadata
         * @property {Array.<weave.IValidatorUpdate>|null} [validatorUpdates] ApplyDiffMsg validatorUpdates
         */

        /**
         * Constructs a new ApplyDiffMsg.
         * @memberof validators
         * @classdesc ApplyDiffMsg is designed to update validator power
         * @implements IApplyDiffMsg
         * @constructor
         * @param {validators.IApplyDiffMsg=} [properties] Properties to set
         */
        function ApplyDiffMsg(properties) {
            this.validatorUpdates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplyDiffMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof validators.ApplyDiffMsg
         * @instance
         */
        ApplyDiffMsg.prototype.metadata = null;

        /**
         * ApplyDiffMsg validatorUpdates.
         * @member {Array.<weave.IValidatorUpdate>} validatorUpdates
         * @memberof validators.ApplyDiffMsg
         * @instance
         */
        ApplyDiffMsg.prototype.validatorUpdates = $util.emptyArray;

        /**
         * Creates a new ApplyDiffMsg instance using the specified properties.
         * @function create
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {validators.IApplyDiffMsg=} [properties] Properties to set
         * @returns {validators.ApplyDiffMsg} ApplyDiffMsg instance
         */
        ApplyDiffMsg.create = function create(properties) {
            return new ApplyDiffMsg(properties);
        };

        /**
         * Encodes the specified ApplyDiffMsg message. Does not implicitly {@link validators.ApplyDiffMsg.verify|verify} messages.
         * @function encode
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {validators.IApplyDiffMsg} message ApplyDiffMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyDiffMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.validatorUpdates != null && message.validatorUpdates.length)
                for (var i = 0; i < message.validatorUpdates.length; ++i)
                    $root.weave.ValidatorUpdate.encode(message.validatorUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplyDiffMsg message, length delimited. Does not implicitly {@link validators.ApplyDiffMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {validators.IApplyDiffMsg} message ApplyDiffMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyDiffMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplyDiffMsg message from the specified reader or buffer.
         * @function decode
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.ApplyDiffMsg} ApplyDiffMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyDiffMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.ApplyDiffMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.validatorUpdates && message.validatorUpdates.length))
                        message.validatorUpdates = [];
                    message.validatorUpdates.push($root.weave.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplyDiffMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.ApplyDiffMsg} ApplyDiffMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyDiffMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplyDiffMsg message.
         * @function verify
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplyDiffMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.validatorUpdates != null && message.hasOwnProperty("validatorUpdates")) {
                if (!Array.isArray(message.validatorUpdates))
                    return "validatorUpdates: array expected";
                for (var i = 0; i < message.validatorUpdates.length; ++i) {
                    var error = $root.weave.ValidatorUpdate.verify(message.validatorUpdates[i]);
                    if (error)
                        return "validatorUpdates." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApplyDiffMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.ApplyDiffMsg} ApplyDiffMsg
         */
        ApplyDiffMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.ApplyDiffMsg)
                return object;
            var message = new $root.validators.ApplyDiffMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".validators.ApplyDiffMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.validatorUpdates) {
                if (!Array.isArray(object.validatorUpdates))
                    throw TypeError(".validators.ApplyDiffMsg.validatorUpdates: array expected");
                message.validatorUpdates = [];
                for (var i = 0; i < object.validatorUpdates.length; ++i) {
                    if (typeof object.validatorUpdates[i] !== "object")
                        throw TypeError(".validators.ApplyDiffMsg.validatorUpdates: object expected");
                    message.validatorUpdates[i] = $root.weave.ValidatorUpdate.fromObject(object.validatorUpdates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApplyDiffMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.ApplyDiffMsg
         * @static
         * @param {validators.ApplyDiffMsg} message ApplyDiffMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApplyDiffMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.validatorUpdates = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.validatorUpdates && message.validatorUpdates.length) {
                object.validatorUpdates = [];
                for (var j = 0; j < message.validatorUpdates.length; ++j)
                    object.validatorUpdates[j] = $root.weave.ValidatorUpdate.toObject(message.validatorUpdates[j], options);
            }
            return object;
        };

        /**
         * Converts this ApplyDiffMsg to JSON.
         * @function toJSON
         * @memberof validators.ApplyDiffMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApplyDiffMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApplyDiffMsg;
    })();

    validators.Accounts = (function() {

        /**
         * Properties of an Accounts.
         * @memberof validators
         * @interface IAccounts
         * @property {weave.IMetadata|null} [metadata] Accounts metadata
         * @property {Array.<Uint8Array>|null} [addresses] Accounts addresses
         */

        /**
         * Constructs a new Accounts.
         * @memberof validators
         * @classdesc Accounts is a list of accounts allowed to update validators
         * @implements IAccounts
         * @constructor
         * @param {validators.IAccounts=} [properties] Properties to set
         */
        function Accounts(properties) {
            this.addresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Accounts metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof validators.Accounts
         * @instance
         */
        Accounts.prototype.metadata = null;

        /**
         * Accounts addresses.
         * @member {Array.<Uint8Array>} addresses
         * @memberof validators.Accounts
         * @instance
         */
        Accounts.prototype.addresses = $util.emptyArray;

        /**
         * Creates a new Accounts instance using the specified properties.
         * @function create
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts=} [properties] Properties to set
         * @returns {validators.Accounts} Accounts instance
         */
        Accounts.create = function create(properties) {
            return new Accounts(properties);
        };

        /**
         * Encodes the specified Accounts message. Does not implicitly {@link validators.Accounts.verify|verify} messages.
         * @function encode
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts} message Accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Accounts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.addresses[i]);
            return writer;
        };

        /**
         * Encodes the specified Accounts message, length delimited. Does not implicitly {@link validators.Accounts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts} message Accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Accounts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Accounts message from the specified reader or buffer.
         * @function decode
         * @memberof validators.Accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.Accounts} Accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Accounts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.Accounts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Accounts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.Accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.Accounts} Accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Accounts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Accounts message.
         * @function verify
         * @memberof validators.Accounts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Accounts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (var i = 0; i < message.addresses.length; ++i)
                    if (!(message.addresses[i] && typeof message.addresses[i].length === "number" || $util.isString(message.addresses[i])))
                        return "addresses: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an Accounts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.Accounts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.Accounts} Accounts
         */
        Accounts.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.Accounts)
                return object;
            var message = new $root.validators.Accounts();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".validators.Accounts.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".validators.Accounts.addresses: array expected");
                message.addresses = [];
                for (var i = 0; i < object.addresses.length; ++i)
                    if (typeof object.addresses[i] === "string")
                        $util.base64.decode(object.addresses[i], message.addresses[i] = $util.newBuffer($util.base64.length(object.addresses[i])), 0);
                    else if (object.addresses[i].length)
                        message.addresses[i] = object.addresses[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an Accounts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.Accounts
         * @static
         * @param {validators.Accounts} message Accounts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Accounts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (var j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = options.bytes === String ? $util.base64.encode(message.addresses[j], 0, message.addresses[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.addresses[j]) : message.addresses[j];
            }
            return object;
        };

        /**
         * Converts this Accounts to JSON.
         * @function toJSON
         * @memberof validators.Accounts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Accounts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Accounts;
    })();

    return validators;
})();

module.exports = $root;
